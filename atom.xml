<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>个人博客</title>
  
  
  <link href="https://wx51815.github.io/atom.xml" rel="self"/>
  
  <link href="https://wx51815.github.io/"/>
  <updated>2023-06-10T07:50:13.034Z</updated>
  <id>https://wx51815.github.io/</id>
  
  <author>
    <name>朱宽江</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>springboot常用注解</title>
    <link href="https://wx51815.github.io/page/Java%E6%A1%86%E6%9E%B6/springboot%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/"/>
    <id>https://wx51815.github.io/page/Java%E6%A1%86%E6%9E%B6/springboot%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/</id>
    <published>2023-06-10T09:39:37.242Z</published>
    <updated>2023-06-10T07:50:13.034Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="一、什么是Spring-Boot"><a href="#一、什么是Spring-Boot" class="headerlink" title="一、什么是Spring Boot"></a>一、什么是Spring Boot</h2><p>Spring Boot是一个快速开发框架，快速的将一些常用的第三方依赖整合（通过Maven子父亲工程的方式），简化xml配置，全部采用注解形式，内置Http服务器（Jetty和Tomcat），最终以Java应用程序进行执行。</p><h2 id="二、Spring常用注解"><a href="#二、Spring常用注解" class="headerlink" title="二、Spring常用注解"></a>二、Spring常用注解</h2><p><a href="https://blog.csdn.net/guorui_java/article/details/107347754" title="Spring常用注解（绝对经典）">Spring常用注解（绝对经典）</a></p><h2 id="三、Spring-Boot常用注解"><a href="#三、Spring-Boot常用注解" class="headerlink" title="三、Spring Boot常用注解"></a>三、Spring Boot常用注解</h2><p>1、@SpringBootApplication</p><p>替代 @SpringBootConfiguration、@EnableAutoConfiguration、@ComponentScan</p><p>2、@ImportAutoConfiguration</p><p>导入配置类，一般做测试的时候使用，正常优先使用@EnableAutoConfiguration </p><p>3、@SpringBootConfiguration</p><p>替代@Configuration</p><p>4、@ImportResource</p><p>将资源导入容器</p><p>5、@PropertySource </p><p>导入properties文件</p><p>6、PropertySources</p><p>@PropertySource 的集合</p><p>7、@Role</p><p>bean角色定义为ROLE_APPLICATION(默认值)、ROLE_SUPPORT(辅助角色)、ROLE_INFRASTRUCTURE(后台角色，用户无感)<br>8、@Scope</p><p>指定bean的作用域，默认singleton，其它包括prototype、request、session、globalSession</p><p>9、@Lazy</p><p>使bean懒加载，取消bean预初始化。</p><p>10、@Primary</p><p>自动装配时当出现多个Bean候选者时，被注解为@Primary的Bean将作为首选者，否者将抛出异常。</p><p>11、@Profile</p><p>指定Bean在哪个环境下被激活</p><p>12、@DependsOn</p><p>依赖的bean注册完成，才注册当前类，依赖bean不存在会报错。用于控制bean加载顺序</p><p>13、@PostConstruct</p><p>bean的属性都注入完毕后，执行注解标注的方式进行初始化工作</p><p>14、@Autowired</p><p>默认按类型装配，如果我们想使用按名称装配，可以结合@Qualifier注解一起使用。</p><p>15、@Lookup</p><p>根据方法返回的类型，去容器中捞出对应</p><p>16、@Qualifier</p><p>申明bean名字，且可以按bean名字加载bean</p><p>17、@Required</p><p>检查bean的属性setXXX()方法，要求属性砸死配置阶段必须已配置</p><p>18、@Description</p><p>添加bean的文字描述</p><p>19、@EnableAspectConfiguration</p><p>启动AspectJ自动配置</p><p>20、EnableLoadTimeWeaving</p><p>启动类加载器动态增强功能，使用instrumentation实现</p><p>21、@AutoConfigurationPackage</p><p>包含该注解的package会被AutoConfigurationPackages注册</p><p>22、@AutoConfigureBefore</p><p>在指定配置类初始化前加载</p><p>23、@AutoConfigureAfter</p><p>在指定配置类初始化后加载</p><p>24、@AutoConfigureOrder</p><p>指定配置类初始化顺序，越小初始化越早</p><p>25、@ModelAttribute</p><p><code>@ModelAttribute</code>注解可被应用在方法和方法参数上。</p><p>（1）对方法使用 @ModelAttribute 注解：</p><p>注解在方法上的<code>@ModelAttribute</code>说明了方法的作用是用于添加一个或多个属性到model上。这样的方法能接受与<code>@RequestMapping</code>注解相同的参数类型，只不过不能直接被映射到具体的请求上。</p><p>@ModelAttribute 方法会先被调用。</p><p>在同一个控制器中，注解了<code>@ModelAttribute</code>的方法实际上会在<code>@RequestMapping</code>方法之前被调用。以下是几个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ModelAttributeController</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ModelAttribute</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(Model model)</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;@RequestMapping方法&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/model-attribute&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;@ModelAttribute方法&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;model-attribute&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以使用 @ModelAttribute 标注的方法来设置其他 @ReqeustMapping 方法的公用参数 </p><p>使用 @ModelAttribute(“key”) 来显示指定属性名。</p><p>（2）@ModelAttribute 和 @RequestMapping 注解在同一个方法上</p><p>如果 @ModelAttribute 和 @RequestMapping 注解在同一个方法上，那么代表给这个请求单独设置 Model 参数。此时返回的值是 Model 的参数值，而不是跳转的地址。跳转的地址是根据请求的 url 自动转换而来的。比如下面的例子中跳转页面不是 HelloWorld.jsp 而是 model-attribute.jsp。并且参数只有在 model-attribute.jsp 中能够取得，而 demo.jsp 中不能取得。</p><p>（3）在方法参数上使用 @ModelAttribute 注解</p><p>① 数据绑定</p><p>注解在方法参数上的<code>@ModelAttribute</code>说明了该方法参数的值将由model中取得。如果model中找不到，那么该参数会先被实例化，然后被添加到model中。在model中存在以后，<strong>请求中所有名称匹配的参数都会填充到该参数中</strong>。这在Spring MVC中被称为数据绑定，一个非常有用的特性，节约了你每次都需要手动从表格数据中转换这些字段数据的时间。</p><p>② 和 BindingResult 配合使用</p><p>使用 <code>@ModelAttribute</code> 进行数据绑定之后，可以使用 <code>BindingResult</code> 来返回数据验证结果。数据验证可以使用 <strong>hibernate validation</strong> 的 <code>@Valid</code> 标签或者 <strong>spring Validator</strong> 校验机制的 <code>@Validated</code> 配合 BindingResult 使用。 或者自定义校验器来返回 BindingResult 对象来进行校验。你可以通过Spring的 <code>&lt;errors&gt;</code> 表单标签来在同一个表单上显示错误信息。</p><p>@Valid 校验器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(path = &quot;/owners/&#123;ownerId&#125;/pets/&#123;petId&#125;/edit&quot;, method = RequestMethod.POST)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">processSubmit</span><span class="params">(<span class="meta">@Valid</span> <span class="meta">@ModelAttribute(&quot;pet&quot;)</span> Pet pet, BindingResult result)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result.hasErrors()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;petForm&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@Validated 校验器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(path = &quot;/owners/&#123;ownerId&#125;/pets/&#123;petId&#125;/edit&quot;, method = RequestMethod.POST)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">processSubmit</span><span class="params">(<span class="meta">@Validated</span> <span class="meta">@ModelAttribute(&quot;pet&quot;)</span> Pet pet, BindingResult result)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result.hasErrors()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;petForm&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义校验器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(path = &quot;/owners/&#123;ownerId&#125;/pets/&#123;petId&#125;/edit&quot;, method = RequestMethod.POST)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">processSubmit</span><span class="params">(<span class="meta">@ModelAttribute(&quot;pet&quot;)</span> Pet pet, BindingResult result)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自己编写一个校验方法来处理 result 对象</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">PetValidator</span>().validate(pet, result);</span><br><span class="line">    <span class="keyword">if</span> (result.hasErrors()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;petForm&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、选择器"><a href="#四、选择器" class="headerlink" title="四、选择器"></a>四、选择器</h2><p>@Conditional，当指定的条件都满足时，组件才被注册<br>@ConditionalOnBean，指定bean在上下文中时，才注册当前bean。用在方法上，则默认依赖类为方法的返回类型<br>@ConditionalOnClass，指定类在classpath上时，才初始化当前bean。用在方法上，则默认依赖类为方法的返回类型<br>@ConditionalOnCloudPlatform，在指定云平台才注册配置<br>@ConditionalOnExpression，指定spel为true时注册配置<br>@ConditionalOnJava，在指定java版本时注册配置<br>@ConditionalOnJndi<br>@ConditionalOnMissingBean，指定bean不在上下文中时，才初始化当前bean。用在方法上，则默认依赖类为方法的返回类型<br>@ConditionalOnMissingClass，指定类不在classpath上时，才初始化当前bean。用在方法上，则默认依赖类为方法的返回类型<br>@ConditionalOnNotWebApplication，不是在web环境才注册配置<br>@ConditionalOnProperty，配置文件中的值与指定值是否相等，相等才注册配置<br>@ConditionalOnResource，指定resources都在classpath上才注册配置<br>@ConditionalOnSingleCandidate，上下文中只有一个候选者bean时才注册配置<br>@ConditionalOnWebApplication，是在web环境才注册配置</p><h2 id="五、缓存"><a href="#五、缓存" class="headerlink" title="五、缓存"></a>五、缓存</h2><p>@EnableCaching，开启缓存配置，支持子类代理或者AspectJ增强<br>@CacheConfig，在一个类下，提供公共缓存配置<br>@Cacheable，放着方法和类上，缓存方法或类下所有方法的返回值<br>@CachePut，每次先执行方法，再将结果放入缓存<br>@CacheEvict，删除缓存<br>@Caching，可以配置@Cacheable、@CachePut、@CacheEvict</p><h2 id="六、定时器"><a href="#六、定时器" class="headerlink" title="六、定时器"></a>六、定时器</h2><p>@EnableScheduling，开启定时任务功能<br>@Scheduled，按指定执行周期执行方法<br>@Schedules，包含多个@Scheduled，可同时运行多个周期配置<br>@EnableAsync，开启方法异步执行的能力，通过@Async或者自定义注解找到需要异步执行的方法。通过实现AsyncConfigurer接口的getAsyncExecutor()和getAsyncUncaughtExceptionHandler()方法自定义Executor和异常处理。<br>@Async，标记方法为异步线程中执行</p><h2 id="七、注入配置文件properties"><a href="#七、注入配置文件properties" class="headerlink" title="七、注入配置文件properties"></a>七、注入配置文件properties</h2><p>@EnableConfigurationProperties，启动@ConfigurationProperties功能<br>@ConfigurationProperties，将properties文件里的内容，自动注入bean对应的属性中<br>@DeprecatedConfigurationProperty，用在配置文件的getter()方法上，标记字段已经过期，并提示替换的字段。一般给spring-boot-configuration-processor使用。<br>@NestedConfigurationProperty，标记在配置文件的字段上，提示spring-boot-configuration-processor，配置包含嵌套的配置。<br>spring-configuration-metadata.json 提供配置的元信息，在写properties配置时，会有语法提示。在项目中引入spring-boot-configuration-processor项目，会扫描@ConfigurationProperties注解，自动生成spring-configuration-metadata.json</p><h2 id="八、Jpa"><a href="#八、Jpa" class="headerlink" title="八、Jpa"></a>八、Jpa</h2><h3 id="1、-Entity-，-Table-name-x3D-””"><a href="#1、-Entity-，-Table-name-x3D-””" class="headerlink" title="1、@Entity ，@Table(name&#x3D;””)"></a>1、@Entity ，@Table(name&#x3D;””)</h3><p>表明这是一个实体类，一般用于jpa，这两个注解一块使用，但是如果表名和实体类名相同的话，@Table可以省略。</p><h3 id="2、-MappedSuperClass"><a href="#2、-MappedSuperClass" class="headerlink" title="2、@MappedSuperClass"></a>2、@MappedSuperClass</h3><p>基于代码复用和模型分离的思想，在项目开发中使用jpa的@MappedSuperClass注解，将实体类的多个属性分别封装到不同的非实体类中。例如，数据库表中都需要id来表示编号，id是这些映射实体类的通用属性，交给jpa统一生产主键id编号，那么使用一个父类来封装这些通用属性，并用@MappedSuperClass标识。</p><p>注意：</p><ul><li>标注为@MappedSuperClass的类将不是一个完整的实体类，它将不会映射到数据库表，但是它的属性都映射到其子类的数据库字段中。</li><li>标注@MappedSuperClass的类不能再标注@#Entity或@Table注解，也无需实现序列化接口。</li></ul><h3 id="3、-NoRepositoryBean"><a href="#3、-NoRepositoryBean" class="headerlink" title="3、@NoRepositoryBean"></a>3、@NoRepositoryBean</h3><p>一般用做父类的repository，有这个注解，spring不会去实例化该repository。</p><h3 id="4、-Column"><a href="#4、-Column" class="headerlink" title="4、@Column"></a>4、@Column</h3><p>如果字段名和列名相同，则可以省略。</p><h3 id="5、-Id"><a href="#5、-Id" class="headerlink" title="5、@Id"></a>5、@Id</h3><p>表示该属性为主键。</p><h3 id="6、-Transient"><a href="#6、-Transient" class="headerlink" title="6、@Transient"></a>6、@Transient</h3><p>表示该属性并非一个到数据库表的字段的映射，ORM框架将忽略该属性。</p><p>如果一个属性并非数据库表的字段映射，就务必将其标注为@Transient，否则，ORM框架默认将其注解为@Basic。</p><h3 id="7、-Basic"><a href="#7、-Basic" class="headerlink" title="7、@Basic"></a>7、@Basic</h3><p>@Basic 是实体类与数据库字段映射时最简单的类型。</p><p>类型支持Java基本类型（byte、short、int、long、float、double、char、boolean），包装类，枚举类，以及实现了serializable接口的类型。</p><p>@basic注解有两个属性：</p><ul><li>fetch用来指定属性的加载机制</li></ul><p>有两个选项：EAGER（即时加载，默认值）和LAZY（懒加载），即时加载意味着当实例化对象的时候必须加载该属性值，懒加载是指当实例化对象时不加载该对象，只有当调用该属性时才加载。</p><ul><li>optional用来指定属性是否可空</li></ul><p>有两个选项：true（可空，默认值）和false</p><p>如果你的实体类上不加@Basic注解，它也会自动加上@Basic，并使用默认值。</p><h3 id="8、-JsonIgnore"><a href="#8、-JsonIgnore" class="headerlink" title="8、@JsonIgnore"></a>8、@JsonIgnore</h3><p>在实体类向前台返回数据时用来忽略不想传递给前台的属性或接口。</p><p>Bean实体中会有某些运维字段，返回信息给前台的时候，不希望将对应值一并返回。此时可以在对应属性上加上@JsonIgnore，或者可以在User类上加上注解@JsonIgnoreProperties(value&#x3D;”{password}”)</p><h3 id="9、-JoinColumn、-OneToOne、-OneToMany、-ManyToOne"><a href="#9、-JoinColumn、-OneToOne、-OneToMany、-ManyToOne" class="headerlink" title="9、@JoinColumn、@OneToOne、@OneToMany、@ManyToOne"></a>9、@JoinColumn、@OneToOne、@OneToMany、@ManyToOne</h3><h2 id="九、导入配置文件"><a href="#九、导入配置文件" class="headerlink" title="九、导入配置文件"></a>九、导入配置文件</h2><p>1、@PropertySource</p><p>引入单个properties文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PropertySource(value = &#123;&quot;classpath:xxxx/xxxx.properties&quot;&#125;)</span></span><br></pre></td></tr></table></figure><p>引入多个properties文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PropertySource(value = &#123;&quot;classpath:xxxx/xxxx.properties&quot;,&quot;classpath:xxxx/xxxx.properties&quot;&#125;)</span></span><br></pre></td></tr></table></figure><p>2、 @ImportResource导入xml配置文件</p><p>可以分为两种模式，相对路径的classpath，绝对路径的file。</p><p>注意：单文件可以不写value或locations。</p><p>取值：使用@Value注解取配置文件中的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;$&#123;properties中的键&#125;&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String xxx;</span><br></pre></td></tr></table></figure><p>3、@Import导入额外的配置文件</p><p>功能类似XML配置的，用来导入配置类，可以导入带有@Configuration注解的配置类或实现了ImportSelector&#x2F;ImportBeanDefinitionRegistrar。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@Import(&#123;SmsConfig.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(DemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="十、事务注解"><a href="#十、事务注解" class="headerlink" title="十、事务注解"></a>十、事务注解</h2><p>@Transactional</p><p>在Spring中，事务有两种实现，分别是编程式事务和声明式事务。</p><p>编程式事务：</p><p>编程式事务使用TransationTemplate或者直接使用底层的PlatformTransactionManager。对于编程式事务，spring推荐使用TransationTemplate。</p><p>声明式事务：</p><p>建立在AOP基础上，其本质是对方法前后进行拦截，然后再目标方法开始之前创建或者加入一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务，通过@Transactional就可以进行事务操作，更快捷而且简单。推荐使用。</p><h2 id="十一、Spring-Cloud"><a href="#十一、Spring-Cloud" class="headerlink" title="十一、Spring Cloud"></a>十一、Spring Cloud</h2><h3 id="1、-EnableEurekaServer"><a href="#1、-EnableEurekaServer" class="headerlink" title="1、@EnableEurekaServer"></a>1、@EnableEurekaServer</h3><p>用在springboot启动类上，表示这是一个eureka服务注册中心；</p><h3 id="2、-EnableDiscoveryClient"><a href="#2、-EnableDiscoveryClient" class="headerlink" title="2、@EnableDiscoveryClient"></a>2、@EnableDiscoveryClient</h3><p>用在springboot启动类上，表示这是一个服务，可以被注册中心找到；</p><h3 id="3、-LoadBalanced"><a href="#3、-LoadBalanced" class="headerlink" title="3、@LoadBalanced"></a>3、@LoadBalanced</h3><p>开启负载均衡能力；</p><h3 id="4、-EnableCircuitBreaker"><a href="#4、-EnableCircuitBreaker" class="headerlink" title="4、@EnableCircuitBreaker"></a>4、@EnableCircuitBreaker</h3><p>用在启动类上，开启断路器功能；</p><h3 id="5、-HystrixCommand-fallbackMethod-x3D-”backMethod”"><a href="#5、-HystrixCommand-fallbackMethod-x3D-”backMethod”" class="headerlink" title="5、@HystrixCommand(fallbackMethod&#x3D;”backMethod”)"></a>5、@HystrixCommand(fallbackMethod&#x3D;”backMethod”)</h3><p>用在方法上，fallbackMethod指定断路回调方法；</p><h3 id="6、-EnableConfigServer"><a href="#6、-EnableConfigServer" class="headerlink" title="6、@EnableConfigServer"></a>6、@EnableConfigServer</h3><p>用在启动类上，表示这是一个配置中心，开启Config Server；</p><h3 id="7、-EnableZuulProxy"><a href="#7、-EnableZuulProxy" class="headerlink" title="7、@EnableZuulProxy"></a>7、@EnableZuulProxy</h3><p>开启zuul路由，用在启动类上；</p><h3 id="8、-SpringCloudApplication"><a href="#8、-SpringCloudApplication" class="headerlink" title="8、@SpringCloudApplication"></a>8、@SpringCloudApplication</h3><ul><li>@SpringBootApplication</li><li>@EnableDiscovertyClient</li><li>@EnableCircuitBreaker</li></ul><p>分别是SpringBoot注解、注册服务中心Eureka注解、断路器注解。对于SpringCloud来说，这是每一微服务必须应有的三个注解，所以才推出了@SpringCloudApplication这一注解集合。</p><h3 id="9、-ConfigurationProperties"><a href="#9、-ConfigurationProperties" class="headerlink" title="9、@ConfigurationProperties"></a>9、@ConfigurationProperties</h3><p>（1）@ConfigurationProperties注解简介</p><p>Spring源码中大量使用了ConfigurationProperties注解，比如server.port就是由该注解获取到的，通过与其他注解配合使用，能够实现Bean的按需配置。 </p><p>该注解有一个prefix属性，通过指定的前缀，绑定配置文件中的配置，该注解可以放在类上，也可以放在方法上。</p><p>（2）代码实例</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.url=jdbc:mysql://127.0.0.1:8888/test?useUnicode=false&amp;autoReconnect=true&amp;characterEncoding=utf-8</span><br><span class="line">spring.datasource.username=root</span><br><span class="line">spring.datasource.password=root</span><br><span class="line">spring.datasource.driver-class-name=com.mysql.jdbc.Driver</span><br><span class="line">spring.datasource.type=com.alibaba.druid.pool.DruidDataSource</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;spring.datasource&quot;)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DatasourcePro</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="comment">// 配置文件中是driver-class-name, 转驼峰命名便可以绑定成</span></span><br><span class="line">    <span class="keyword">private</span> String driverClassName;</span><br><span class="line">    <span class="keyword">private</span> String type;</span><br><span class="line"> </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 以上代码就实现了通过配置文件对属性的赋值。</p><p>（3）注意事项</p><ol><li>@ConfigurationProperties 和 @value 有着相同的功能，但是 @ConfigurationProperties的写法更为方便；</li><li>@ConfigurationProperties 的 POJO类的命名比较严格,因为它必须和prefix的后缀名要一致, 不然值会绑定不上, 特殊的后缀名是“driver-class-name”这种带横杠的情况,在POJO里面的命名规则是 <strong>下划线转驼峰</strong> 就可以绑定成功，所以就是 “driverClassName”。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;一、什么是Spring-Boot&quot;&gt;&lt;a href=&quot;#一、什么是Spring-Boot&quot; class=&quot;headerlink&quot; title=&quot;一、什么是Spring Boot&quot;&gt;&lt;/a&gt;一、什么是Spring Boot&lt;/h2&gt;&lt;p&gt;S</summary>
      
    
    
    
    <category term="Java框架" scheme="https://wx51815.github.io/categories/Java%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="springboot" scheme="https://wx51815.github.io/tags/springboot/"/>
    
    <category term="注释" scheme="https://wx51815.github.io/tags/%E6%B3%A8%E9%87%8A/"/>
    
  </entry>
  
  <entry>
    <title>maven仓库</title>
    <link href="https://wx51815.github.io/page/Java%E6%A1%86%E6%9E%B6/maven%E4%BB%93%E5%BA%93/"/>
    <id>https://wx51815.github.io/page/Java%E6%A1%86%E6%9E%B6/maven%E4%BB%93%E5%BA%93/</id>
    <published>2023-05-09T07:26:21.000Z</published>
    <updated>2023-06-10T07:50:13.033Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1-Maven-是什么"><a href="#1-Maven-是什么" class="headerlink" title="1. Maven 是什么"></a>1. Maven 是什么</h2><p>Maven 是 Apache 软件基金会组织维护的一款专门为 Java 项目提供<strong>构建</strong>和<strong>依赖</strong>管理支持的工具。</p><p>一个 Maven 工程有约定的目录结构，约定的目录结构对于 Maven 实现自动化构建而言是必不可少的一环，就拿自动编译来说，Maven 必须 能找到 Java 源文件，下一步才能编译，而编译之后也必须有一个准确的位置保持编译得到的字节码文件。 我们在开发中如果需要让第三方工具或框架知道我们自己创建的资源在哪，那么基本上就是两种方式：</p><ol><li>通过配置的形式明确告诉它</li><li>基于第三方工具或框架的约定 Maven 对工程目录结构的要求</li></ol><p><img src="/./../images/maven%E4%BB%93%E5%BA%93/5caee599cddb3eee7b66528dfcb79e75.png" alt="image-20220531105056629"></p><h3 id="1-1-构建"><a href="#1-1-构建" class="headerlink" title="1.1 构建"></a>1.1 构建</h3><p>Java 项目开发过程中，构建指的是使用『<strong>原材料生产产品</strong>』的过程。</p><p><img src="/./../images/maven%E4%BB%93%E5%BA%93/161771e3556ddd018c353fd2d3fcfe58.png" alt="image-20220531103123865"></p><p>构建过程主要包含以下环节：</p><p><img src="/./../images/maven%E4%BB%93%E5%BA%93/b03866debd1879ab57c106fab12018a8.png" alt="image-20220531110053525"></p><h3 id="1-2-依赖"><a href="#1-2-依赖" class="headerlink" title="1.2 依赖"></a>1.2 依赖</h3><p>Maven 中最关键的部分，我们使用 Maven 最主要的就是使用它的依赖管理功能。当 A jar 包用到了 B jar 包中的某些类时，A 就对 B 产生了依赖，那么我们就可以说 A 依赖 B。</p><p>依赖管理中要解决的具体问题：</p><ul><li>jar 包的下载：使用 Maven 之后，jar 包会从规范的远程仓库下载到本地</li><li>jar 包之间的依赖：通过依赖的传递性自动完成</li><li>jar 包之间的冲突：通过对依赖的配置进行调整，让某些 jar 包不会被导入</li></ul><h2 id="2-Maven-开发环境配置"><a href="#2-Maven-开发环境配置" class="headerlink" title="2. Maven 开发环境配置"></a>2. Maven 开发环境配置</h2><h3 id="2-1-下载安装"><a href="#2-1-下载安装" class="headerlink" title="2.1 下载安装"></a>2.1 下载安装</h3><p>首页：</p><p><a href="https://maven.apache.org/">Maven – Welcome to Apache Maven</a></p><p>下载页面：</p><p><a href="https://maven.apache.org/download.cgi">Maven – Download Apache Maven</a></p><p><img src="/./../images/maven%E4%BB%93%E5%BA%93/bb7204b33b9d8ab0635cd911b8a8f068.png" alt="image-20220531111722652"></p><p>或者你也可以选择之前的版本：</p><p><img src="/./../images/maven%E4%BB%93%E5%BA%93/42cc3a773b64b951bbd3bfe2ce56e1d9.png" alt="image-20220531111953804"></p><p>然后里面选择自己对应的版本下载即可：</p><p><img src="/./../images/maven%E4%BB%93%E5%BA%93/a7fe1bf9c9bee28202c11d4ed1cb9eb2.png" alt="image-20220531112022942"></p><p>下载之后解压到<strong>非中文、没有空格</strong>的目录，如下：</p><p><img src="/./../images/maven%E4%BB%93%E5%BA%93/a54317b7bc3e4769e123f8732e2f2879.png" alt="image-20220531112226829"></p><h3 id="2-2-指定本地仓库"><a href="#2-2-指定本地仓库" class="headerlink" title="2.2 指定本地仓库"></a>2.2 指定本地仓库</h3><p>本地仓库默认值：用户家目录&#x2F;.m2&#x2F;repository。由于本地仓库的默认位置是在用户的家目录下，而家目录往往是在 C 盘，也就是系统盘。将来 Maven 仓库中 jar 包越来越多，仓库体积越来越大，可能会拖慢 C 盘运行速度，影响系统性能。所以建议将 Maven 的本地仓库放在其他盘符下。配置方式如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- localRepository</span></span><br><span class="line"><span class="comment">| The path to the local repository maven will use to store artifacts.</span></span><br><span class="line"><span class="comment">|</span></span><br><span class="line"><span class="comment">| Default: $&#123;user.home&#125;/.m2/repository</span></span><br><span class="line"><span class="comment">&lt;localRepository&gt;/path/to/local/repo&lt;/localRepository&gt;</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">localRepository</span>&gt;</span>D:\software\maven-repository<span class="tag">&lt;/<span class="name">localRepository</span>&gt;</span></span><br></pre></td></tr></table></figure><p>本地仓库这个目录，我们手动创建一个空的目录即可。</p><p><strong>记住</strong>：一定要把 localRepository 标签<strong>从注释中拿出来</strong>。</p><p><strong>注意</strong>：本地仓库本身也需要使用一个<strong>非中文、没有空格</strong>的目录。</p><h3 id="2-3-配置阿里云提供的镜像仓库"><a href="#2-3-配置阿里云提供的镜像仓库" class="headerlink" title="2.3 配置阿里云提供的镜像仓库"></a>2.3 配置阿里云提供的镜像仓库</h3><p>Maven 下载 jar 包默认访问境外的中央仓库，而国外网站速度很慢。改成阿里云提供的镜像仓库，<strong>访问国内网站</strong>，可以让 Maven 下载 jar 包的时候速度更快。配置的方式是：</p><ol><li><p>将原有的例子配置注释掉</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- &lt;mirror&gt;</span></span><br><span class="line"><span class="comment">  &lt;id&gt;maven-default-http-blocker&lt;/id&gt;</span></span><br><span class="line"><span class="comment">  &lt;mirrorOf&gt;external:http:*&lt;/mirrorOf&gt;</span></span><br><span class="line"><span class="comment">  &lt;name&gt;Pseudo repository to mirror external repositories initially using HTTP.&lt;/name&gt;</span></span><br><span class="line"><span class="comment">  &lt;url&gt;http://0.0.0.0/&lt;/url&gt;</span></span><br><span class="line"><span class="comment">  &lt;blocked&gt;true&lt;/blocked&gt;</span></span><br><span class="line"><span class="comment">&lt;/mirror&gt; --&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>加入自己的配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-aliyun<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>Nexus aliyun<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="2-4-配置基础-JDK-版本"><a href="#2-4-配置基础-JDK-版本" class="headerlink" title="2.4 配置基础 JDK 版本"></a>2.4 配置基础 JDK 版本</h3><p>如果按照默认配置运行，Java 工程使用的默认 JDK 版本是 1.5，而我们熟悉和常用的是 JDK 1.8 版本。修改配置的方式是：将 <code>profile</code> 标签整个复制到 settings.xml 文件的 <code>profiles</code> 标签内。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>jdk-1.8<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jdk</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">jdk</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">maven.compiler.compilerVersion</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.compilerVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-5-配置环境变量"><a href="#2-5-配置环境变量" class="headerlink" title="2.5 配置环境变量"></a>2.5 配置环境变量</h3><p>Maven 是一个用 Java 语言开发的程序，它必须基于 JDK 来运行，需要通过 JAVA_HOME 来找到 JDK 的安装位置。</p><p><img src="/./../images/maven%E4%BB%93%E5%BA%93/82b95009ea03eb7bf1f45134bd7f8a83.png" alt="image-20220531113102962"></p><p>可以使用下面的命令验证：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\Administrator&gt;echo %JAVA_HOME%</span><br><span class="line">D:\software\Java</span><br><span class="line"></span><br><span class="line">C:\Users\Administrator&gt;java -version</span><br><span class="line">java version &quot;1.8.0_141&quot;</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_141-b15)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.141-b15, mixed mode)</span><br></pre></td></tr></table></figure><p>然后新建环境变量：</p><p><img src="/./../images/maven%E4%BB%93%E5%BA%93/7f3180ce87599ffe9a0a845053d2b67d.png" alt="image-20220531113203150"></p><blockquote><p>配置环境变量的规律：</p><p>XXX_HOME 通常指向的是 bin 目录的上一级</p><p>PATH 指向的是 bin 目录</p></blockquote><p>在配置 PATH</p><p><img src="/./../images/maven%E4%BB%93%E5%BA%93/bf4844ecff63c16fa35476be994b0fd1.png" alt="image-20220531113255988"></p><p>通过 <code>mvn -v</code> 验证：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\Administrator&gt;mvn -v</span><br><span class="line">Apache Maven 3.3.9 (bb52d8502b132ec0a5a3f4c09453c07478323dc5; 2015-11-11T00:41:47+08:00)</span><br><span class="line">Maven home: D:\software\apache-maven-3.3.9\bin\..</span><br><span class="line">Java version: 1.8.0_333, vendor: Oracle Corporation</span><br><span class="line">Java home: D:\software\jdk1.8\jre</span><br><span class="line">Default locale: zh_CN, platform encoding: GBK</span><br><span class="line">OS name: &quot;windows 11&quot;, version: &quot;10.0&quot;, arch: &quot;amd64&quot;, family: &quot;dos&quot;</span><br></pre></td></tr></table></figure><h2 id="3-Maven-的使用"><a href="#3-Maven-的使用" class="headerlink" title="3. Maven 的使用"></a>3. Maven 的使用</h2><h3 id="3-1-核心概念：坐标"><a href="#3-1-核心概念：坐标" class="headerlink" title="3.1 核心概念：坐标"></a>3.1 核心概念：坐标</h3><p><strong>数学中的坐标</strong>使用 x、y、z 三个『<strong>向量</strong>』作为空间的坐标系，可以在『<strong>空间</strong>』中唯一的定位到一个『<strong>点</strong>』。</p><p><img src="/./../images/maven%E4%BB%93%E5%BA%93/810f3f9052ec57e97d736091a638673b.png" alt="image-20220531115849117"></p><p><strong>Maven中的坐标</strong>使用三个『<strong>向量</strong>』在『<strong>Maven的仓库</strong>』中<strong>唯一</strong>的定位到一个『<strong>jar</strong>』包。</p><ul><li><p><strong>groupId</strong>：公司或组织的 id，即公司或组织域名的倒序，通常也会加上项目名称</p><p>例如：groupId：com.javatv.maven</p></li><li><p><strong>artifactId</strong>：一个项目或者是项目中的一个模块的 id，即模块的名称，将来作为 Maven 工程的工程名</p><p>例如：artifactId：auth</p></li><li><p><strong>version</strong>：版本号</p><p>例如：version：1.0.0</p></li></ul><p>提示：坐标和仓库中 jar 包的存储路径之间的对应关系，如下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面坐标对应的 jar 包在 Maven 本地仓库中的位置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Maven本地仓库根目录\javax\servlet\servlet-api\2.5\servlet-api-2.5.jar</span><br></pre></td></tr></table></figure><h3 id="3-2-pom-xml"><a href="#3-2-pom-xml" class="headerlink" title="3.2 pom.xml"></a>3.2 pom.xml</h3><p>POM：<strong>P</strong>roject <strong>O</strong>bject <strong>M</strong>odel，项目对象模型。和 POM 类似的是：DOM（Document Object Model），文档对象模型。它们都是模型化思想的具体体现。</p><p>POM 表示将工程抽象为一个模型，再用程序中的对象来描述这个模型。这样我们就可以用程序来管理项目了。我们在开发过程中，最基本的做法就是将现实生活中的事物抽象为模型，然后封装模型相关的数据作为一个对象，这样就可以在程序中计算与现实事物相关的数据。</p><p>POM 理念集中体现在 Maven 工程根目录下 <strong>pom.xml</strong> 这个配置文件中。所以这个 pom.xml 配置文件就是 Maven 工程的核心配置文件。其实学习 Maven 就是学这个文件怎么配置，各个配置有什么用。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 当前Maven工程的坐标 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>demo<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 当前Maven工程的打包方式，可选值有下面三种： --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- jar：表示这个工程是一个Java工程  --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- war：表示这个工程是一个Web工程 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- pom：表示这个工程是“管理其他工程”的工程 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 工程构建过程中读取源码时使用的字符集 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 当前工程所依赖的jar包 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用dependency配置一个具体的依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 在dependency标签内使用具体的坐标依赖我们需要的一个jar包 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- scope标签配置依赖的范围 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-3-依赖"><a href="#3-3-依赖" class="headerlink" title="3.3 依赖"></a>3.3 依赖</h3><p>上面说到我们使用 Maven 最主要的就是使用它的依赖管理功能，引入依赖存在一个范围，maven的依赖范围包括： <code>compile</code>，<code>provide</code>，<code>runtime</code>，<code>test</code>，<code>system</code>。</p><ul><li><strong>compile</strong>：表示编译范围，指 A 在编译时依赖 B，该范围为<strong>默认依赖范围</strong>。编译范围的依赖会用在编译，测试，运行，由于运行时需要，所以编译范围的依赖会被打包。</li><li><strong>provided</strong>：provied 依赖只有当 jdk 或者一个容器已提供该依赖之后才使用。provide 依赖在编译和测试时需要，在运行时不需要。例如：servlet api被Tomcat容器提供了。</li><li><strong>runtime</strong>：runtime 依赖在运行和测试系统时需要，但在编译时不需要。例如：jdbc 的驱动包。由于运行时需要，所以 runtime 范围的依赖会被打包。</li><li><strong>test</strong>：test 范围依赖在编译和运行时都不需要，只在测试编译和测试运行时需要。例如：Junit。由于运行时不需要，所以 test 范围依赖不会被打包。</li><li><strong>system</strong>：system 范围依赖与 provide 类似，但是必须显示的提供一个对于本地系统中 jar 文件的路径。一般不推荐使用。</li></ul><table><thead><tr><th>依赖范围</th><th>编译</th><th>测试</th><th>运行时</th><th>是否会被打入jar包</th></tr></thead><tbody><tr><td>compile</td><td>√</td><td>√</td><td>√</td><td>√</td></tr><tr><td>provided</td><td>√</td><td>√</td><td>×</td><td>×</td></tr><tr><td>runtime</td><td>×</td><td>√</td><td>√</td><td>√</td></tr><tr><td>test</td><td>×</td><td>√</td><td>×</td><td>×</td></tr><tr><td>system</td><td>√</td><td>√</td><td>×</td><td>√</td></tr></tbody></table><p>而在实际开发中，我们常用的就是 <code>compile</code>、<code>test</code>、<code>provided</code> 。</p><h3 id="3-4-依赖的传递"><a href="#3-4-依赖的传递" class="headerlink" title="3.4 依赖的传递"></a>3.4 依赖的传递</h3><p>A 依赖 B，B 依赖 C，那么在 A 没有配置对 C 的依赖的情况下，A 里面能不能直接使用 C？</p><p>再以上的前提下，C 是否能够传递到 A，取决于 B 依赖 C 时使用的依赖范围。</p><ul><li>B 依赖 C 时使用 compile 范围：可以传递</li><li>B 依赖 C 时使用 test 或 provided 范围：不能传递，所以需要这样的 jar 包时，就必须在需要的地方明确配置依赖才可以。</li></ul><h3 id="3-5-依赖的排除"><a href="#3-5-依赖的排除" class="headerlink" title="3.5 依赖的排除"></a>3.5 依赖的排除</h3><p>当 A 依赖 B，B 依赖 C 而且 C 可以传递到 A 的时候，A 不想要 C，需要在 A 里面把 C 排除掉。而往往这种情况都是为了避免 jar 包之间的冲突。</p><p><img src="/./../images/maven%E4%BB%93%E5%BA%93/b5e2a57beb18d9009f48d4198e15abd9.png" alt="image-20220531154214396"></p><p>所以配置依赖的排除其实就是阻止某些 jar 包的传递。因为这样的 jar 包传递过来会和其他 jar 包冲突。</p><p>一般通过使用<code>excludes</code>标签配置依赖的排除：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.javatv.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>auth<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">&lt;!-- 使用excludes标签配置依赖的排除--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 在exclude标签中配置一个具体的排除 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 指定要排除的依赖的坐标（不需要写version） --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-6-继承"><a href="#3-6-继承" class="headerlink" title="3.6 继承"></a>3.6 继承</h3><h4 id="3-6-1-概念"><a href="#3-6-1-概念" class="headerlink" title="3.6.1 概念"></a>3.6.1 概念</h4><p>Maven工程之间，A 工程继承 B 工程</p><ul><li>B 工程：父工程</li><li>A 工程：子工程</li></ul><p>本质上是 A 工程的 pom.xml 中的配置继承了 B 工程中 pom.xml 的配置。</p><h4 id="3-6-2-作用"><a href="#3-6-2-作用" class="headerlink" title="3.6.2 作用"></a>3.6.2 作用</h4><p>在父工程中统一管理项目中的依赖信息，具体来说是管理依赖信息的版本。</p><p>它的背景是：</p><ul><li>对一个比较大型的项目进行了模块拆分。</li><li>一个 project 下面，创建了很多个 module。</li><li>每一个 module 都需要配置自己的依赖信息。</li></ul><p>它背后的需求是：</p><ul><li>在每一个 module 中各自维护各自的依赖信息很容易发生出入，不易统一管理。</li><li>使用同一个框架内的不同 jar 包，它们应该是同一个版本，所以整个项目中使用的框架版本需要统一。</li><li>使用框架时所需要的 jar 包组合（或者说依赖信息组合）需要经过长期摸索和反复调试，最终确定一个可用组合。这个耗费很大精力总结出来的方案不应该在新的项目中重新摸索。</li></ul><p>通过在父工程中为整个项目维护依赖信息的组合既<strong>保证了整个项目使用规范、准确的 jar 包</strong>；又能够将<strong>以往的经验沉淀</strong>下来，节约时间和精力。</p><h4 id="3-6-3-一个例子"><a href="#3-6-3-一个例子" class="headerlink" title="3.6.3 一个例子"></a>3.6.3 一个例子</h4><p><strong>① 一般再模块化开发中一般都会创建一个父工程，如下</strong>：</p><p><img src="/./../images/maven%E4%BB%93%E5%BA%93/5fdb5181781bb398f9dfac37cfc80d0b.png" alt="image-20220531160955790"></p><p><img src="/./../images/maven%E4%BB%93%E5%BA%93/d10d8ea95fae614fe718c2f1e6921ade.png" alt="image-20220531161201700"></p><p>父工程创建好之后，要修改它的打包方式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 当前工程作为父工程，它要去管理子工程，所以打包方式必须是 pom --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br></pre></td></tr></table></figure><p>只有打包方式为 pom 的 Maven 工程能够管理其他 Maven 工程。打包方式为 pom 的 Maven 工程中不写业务代码，它是专门管理其他 Maven 工程的工程，所以可以将生成的 src 目录删除。</p><p><strong>② 创建模块工程</strong></p><p><img src="/./../images/maven%E4%BB%93%E5%BA%93/0b3276756c64efd1d850939d689297e3.png" alt="image-20220531161702343"></p><p><img src="/./../images/maven%E4%BB%93%E5%BA%93/c31ac74fc6c09d3b9486e17f077f69fd.png" alt="image-20220531161801726"></p><p><img src="/./../images/maven%E4%BB%93%E5%BA%93/21bbd4820f125c53200fcd3527feb3c1.png" alt="image-20220531161912958"></p><p>然后可以再<strong>父工程</strong>的 pom 文件中看到：</p><p><img src="/./../images/maven%E4%BB%93%E5%BA%93/068050f0bb66af9a84cdfb4acdb89237.png" alt="image-20220531162441081"></p><p>而<strong>子工程</strong>的 pom 如下：</p><p><img src="/./../images/maven%E4%BB%93%E5%BA%93/a524a1d4a5d0e9fa83fec38b5eb75be5.png" alt="image-20220531162755291"></p><p><strong>③ 在父工程中配置依赖的统一管理</strong></p><p>使用<code>dependencyManagement</code>标签配置对依赖的管理，如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.javatv.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-demo-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>demo-module<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-beans<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.19<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.19<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.19<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.19<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>而实际上<strong>被管理的依赖并没有真正被引入到工程</strong>。</p><p><strong>④ 子工程中引用那些被父工程管理的依赖</strong></p><p>关键点：省略版本号</p><p>子工程引用父工程中的依赖信息时，可以把版本号去掉。把版本号去掉就表示子工程中这个依赖的版本由父工程决定，具体来说是由父工程的dependencyManagement来决定。</p><p>子工程 pom 如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 使用parent标签指定当前工程的父工程 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-demo-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.javatv.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 子工程的坐标 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 如果子工程坐标中的groupId和version与父工程一致，那么可以省略 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>demo-module<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-beans<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此时，<strong>被管理的依赖才被引入到工程</strong>。</p><p><img src="/./../images/maven%E4%BB%93%E5%BA%93/d4b543a419b8276ec8236989cd7e257c.png" alt="image-20220531163659123"></p><p><strong>⑤ 修改父工程依赖信息的版本</strong></p><p>这个修改可以是降级，也可以是升级，但一般来说都是升级。</p><p><img src="/./../images/maven%E4%BB%93%E5%BA%93/26c1e05830b65e3f90b42e04cb89d946.png" alt="image-20220531164037374"></p><p><strong>⑥ 父工程中声明自定义属性</strong></p><p>对同一个框架的一组 jar 包最好使用相同的版本，为了方便升级框架，可以将 jar 包的版本信息统一提取出来，统一声明版本号 ：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 通过自定义属性，统一指定Spring的版本 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 自定义标签，维护Spring版本数据 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">spring.version</span>&gt;</span>5.3.19<span class="tag">&lt;/<span class="name">spring.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在需要的地方使用<code>$&#123;&#125;</code>的形式来引用自定义的属性名，真正实现<strong>一处修改，处处生效</strong>。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.javatv.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-demo-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>demo-module<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 通过自定义属性，统一指定Spring的版本 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 自定义标签，维护Spring版本数据 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">spring.version</span>&gt;</span>5.3.19<span class="tag">&lt;/<span class="name">spring.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-beans<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>编写一套符合要求、开发各种功能都能正常工作的依赖组合并不容易。如果公司里已经有人总结了成熟的组合方案，那么再开发新项目时，如果不使用原有的积累，而是重新摸索，会浪费大量的时间。为了提高效率，我们可以使用工程继承的机制，让成熟的依赖组合方案能够保留下来。如下：</p><p><img src="/./../images/maven%E4%BB%93%E5%BA%93/44323676a4e064bdd970da10d85dc3b7.png" alt="image-20220531164745206"></p><p>如上图所示，公司级的父工程中管理的就是成熟的依赖组合方案，各个新项目、子系统各取所需即可。</p><h3 id="3-7-聚合"><a href="#3-7-聚合" class="headerlink" title="3.7 聚合"></a>3.7 聚合</h3><p>聚合，指分散的聚集到一起，即部分组成整体。</p><h4 id="3-7-1-Maven-中的聚合"><a href="#3-7-1-Maven-中的聚合" class="headerlink" title="3.7.1 Maven 中的聚合"></a>3.7.1 Maven 中的聚合</h4><p>使用一个<strong>总工程</strong>将各个<strong>模块工程</strong>汇集起来，作为一个整体对应完整的项目，实际就是 <code>module</code> 标签。</p><ul><li>项目：整体</li><li>模块：部分</li></ul><h4 id="3-7-2-继承和聚合的对应关系"><a href="#3-7-2-继承和聚合的对应关系" class="headerlink" title="3.7.2 继承和聚合的对应关系"></a>3.7.2 继承和聚合的对应关系</h4><p>从继承关系角度来看：</p><ul><li>父工程</li><li>子工程</li></ul><p>从聚合关系角度来看：</p><ul><li>总工程</li><li>模块工程</li></ul><h4 id="3-7-3-聚合的配置"><a href="#3-7-3-聚合的配置" class="headerlink" title="3.7.3 聚合的配置"></a>3.7.3 聚合的配置</h4><p>在总工程中配置 modules 即可：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>demo-module<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="3-7-4-依赖循环问题"><a href="#3-7-4-依赖循环问题" class="headerlink" title="3.7.4 依赖循环问题"></a>3.7.4 依赖循环问题</h4><p>如果 A 工程依赖 B 工程，B 工程依赖 C 工程，C 工程又反过来依赖 A 工程，那么在执行构建操作时会报下面的错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DANGER</span><br><span class="line"></span><br><span class="line">[ERROR] [ERROR] The projects in the reactor contain a cyclic reference:</span><br></pre></td></tr></table></figure><p>这个错误的含义是：循环引用。</p><h2 id="4-build-标签"><a href="#4-build-标签" class="headerlink" title="4. build 标签"></a>4. build 标签</h2><p>在实际使用 Maven 的过程中，我们会发现 build 标签有时候有，有时候没，这是怎么回事呢？其实通过有效 POM 我们能够看到，build 标签的相关配置其实一直都在，只是在我们需要定制构建过程的时候才会通过配置 build 标签覆盖默认值或补充配置。这一点我们可以通过打印有效 POM 来看到。</p><blockquote><p>打印有效 pom</p><p>mvn help:effective-pom</p></blockquote><p>当默认配置无法满足需求的定制构建的时候，就需要使用 build 标签。</p><h3 id="4-1-build-标签的组成"><a href="#4-1-build-标签的组成" class="headerlink" title="4.1 build 标签的组成"></a>4.1 build 标签的组成</h3><p>build 标签的子标签大致包含三个主体部分：</p><p><img src="/./../images/maven%E4%BB%93%E5%BA%93/f381458286b3ad1b5b8c230b821c0a16.png" alt="image-20220601152649666"></p><h4 id="4-1-1-定义约定的目录结构"><a href="#4-1-1-定义约定的目录结构" class="headerlink" title="4.1.1 定义约定的目录结构"></a>4.1.1 定义约定的目录结构</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sourceDirectory</span>&gt;</span>D:\product\maven-demo-parent\demo-module\src\main\java<span class="tag">&lt;/<span class="name">sourceDirectory</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scriptSourceDirectory</span>&gt;</span>D:\product\maven-demo-parent\demo-module\src\main\scripts<span class="tag">&lt;/<span class="name">scriptSourceDirectory</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">testSourceDirectory</span>&gt;</span>D:\product\maven-demo-parent\demo-module\src\test\java<span class="tag">&lt;/<span class="name">testSourceDirectory</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">outputDirectory</span>&gt;</span>D:\product\maven-demo-parent\demo-module\target\classes<span class="tag">&lt;/<span class="name">outputDirectory</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">testOutputDirectory</span>&gt;</span>D:\product\maven-demo-parent\demo-module\target\test-classes<span class="tag">&lt;/<span class="name">testOutputDirectory</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">directory</span>&gt;</span>D:\product\maven-demo-parent\demo-module\src\main\resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">testResources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">testResource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">directory</span>&gt;</span>D:\product\maven-demo-parent\demo-module\src\test\resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">testResource</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">testResources</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">directory</span>&gt;</span>D:\product\maven-demo-parent\demo-module\target<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">finalName</span>&gt;</span>demo-module-1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br></pre></td></tr></table></figure><p>各个目录的作用如下：</p><table><thead><tr><th>目录名</th><th>作用</th></tr></thead><tbody><tr><td>sourceDirectory</td><td>主体源程序存放目录</td></tr><tr><td>scriptSourceDirectory</td><td>脚本源程序存放目录</td></tr><tr><td>testSourceDirectory</td><td>测试源程序存放目录</td></tr><tr><td>outputDirectory</td><td>主体源程序编译结果输出目录</td></tr><tr><td>testOutputDirectory</td><td>测试源程序编译结果输出目录</td></tr><tr><td>resources</td><td>主体资源文件存放目录</td></tr><tr><td>testResources</td><td>测试资源文件存放目录</td></tr><tr><td>directory</td><td>构建结果输出目录</td></tr></tbody></table><h4 id="4-1-2-备用插件管理"><a href="#4-1-2-备用插件管理" class="headerlink" title="4.1.2 备用插件管理"></a>4.1.2 备用插件管理</h4><p>pluginManagement 标签存放着几个极少用到的插件：</p><ul><li>maven-antrun-plugin</li><li>maven-assembly-plugin</li><li>maven-dependency-plugin</li><li>maven-release-plugin</li></ul><p>通过 pluginManagement 标签管理起来的插件就像 dependencyManagement 一样，子工程使用时可以省略版本号，起到在父工程中统一管理版本的效果。</p><h4 id="4-1-3-生命周期插件"><a href="#4-1-3-生命周期插件" class="headerlink" title="4.1.3 生命周期插件"></a>4.1.3 生命周期插件</h4><p>plugins 标签存放的是默认生命周期中实际会用到的插件，这些插件想必大家都不陌生，所以抛开插件本身不谈，plugin 标签的结构如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>default-compile<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">phase</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">goal</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>default-testCompile<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">phase</span>&gt;</span>test-compile<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">goal</span>&gt;</span>testCompile<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>① 坐标部分</strong></p><p>artifactId 和 version 标签定义了插件的坐标，作为 Maven 的自带插件这里省略了 groupId。</p><p><strong>② 执行部分</strong></p><p>executions 标签内可以配置多个 execution 标签，execution 标签内：</p><ul><li><p>id：指定唯一标识</p></li><li><p>phase：关联的生命周期阶段</p></li><li><p>goals&#x2F;goal：关联指定生命周期的目标</p><p>goals 标签中可以配置多个 goal 标签，表示一个生命周期环节可以对应当前插件的多个目标。</p></li></ul><h3 id="4-2-典型应用：指定-JDK-版本"><a href="#4-2-典型应用：指定-JDK-版本" class="headerlink" title="4.2 典型应用：指定 JDK 版本"></a>4.2 典型应用：指定 JDK 版本</h3><p>前面我们在 settings.xml 中配置了 JDK 版本，那么将来把 Maven 工程部署都服务器上，脱离了 settings.xml 配置，如何保证程序正常运行呢？思路就是我们直接把 JDK 版本信息告诉负责编译操作的 maven-compiler-plugin 插件，让它在构建过程中，按照我们指定的信息工作。如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- build 标签：意思是告诉 Maven，你的构建行为，我要开始定制了！ --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- plugins 标签：Maven 你给我听好了，你给我构建的时候要用到这些插件！ --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- plugin 标签：这是我要指定的一个具体的插件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 插件的坐标。此处引用的 maven-compiler-plugin 插件不是第三方的，是一个 Maven 自带的插件。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">&lt;!-- configuration 标签：配置 maven-compiler-plugin 插件 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 具体配置信息会因为插件不同、需求不同而有所差异 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">encoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">encoding</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>settings.xml 中配置：仅在本地生效，如果脱离当前 settings.xml 能够覆盖的范围，则无法生效。</li><li>在当前 Maven 工程 pom.xml 中配置：无论在哪个环境执行编译等构建操作都有效。</li></ul><h3 id="4-3-典型应用：SpringBoot-定制化打包"><a href="#4-3-典型应用：SpringBoot-定制化打包" class="headerlink" title="4.3 典型应用：SpringBoot 定制化打包"></a>4.3 典型应用：SpringBoot 定制化打包</h3><p>很显然 spring-boot-maven-plugin 并不是 Maven 自带的插件，而是 SpringBoot 提供的，用来改变 Maven 默认的构建行为。具体来说是改变打包的行为。默认情况下 Maven 调用 maven-jar-plugin 插件的 jar 目标，生成普通的 jar 包。</p><p>普通 jar 包没法使用 java -jar xxx.jar 这样的命令来启动、运行，但是 SpringBoot 的设计理念就是每一个『微服务』导出为一个 jar 包，这个 jar 包可以使用 java -jar xxx.jar 这样的命令直接启动运行。</p><p>这样一来，打包的方式肯定要进行调整。所以 SpringBoot 提供了 spring-boot-maven-plugin 这个插件来定制打包行为。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="5-依赖配置补充"><a href="#5-依赖配置补充" class="headerlink" title="5. 依赖配置补充"></a>5. 依赖配置补充</h2><p>管理依赖最基本的办法是继承父工程，但是和 Java 类一样，Maven 也是单继承的。如果不同体系的依赖信息封装在不同 POM 中了，没办法继承多个父工程怎么办？这时就可以使用 import 依赖范围。</p><h3 id="5-1-import"><a href="#5-1-import" class="headerlink" title="5.1 import"></a>5.1 import</h3><p>典型案例当然是在项目中引入 SpringBoot、SpringCloud 依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- SpringCloud 微服务 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!-- SpringCloud Alibaba 微服务 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-cloud-alibaba.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><p>import 依赖范围使用要求：</p><ul><li>打包类型必须是 pom</li><li>必须放在 dependencyManagement 中</li></ul><blockquote><p>官网说明如下：</p><p>This scope is only supported on a dependency of type <code>pom</code> in the <code>&lt;dependencyManagement&gt;</code> section. It indicates the dependency is to be replaced with the effective list of dependencies in the specified POM’s <code>&lt;dependencyManagement&gt;</code> section. Since they are replaced, dependencies with a scope of <code>import</code> do not actually participate in limiting the transitivity of a dependency.</p></blockquote><h3 id="5-2-system"><a href="#5-2-system" class="headerlink" title="5.2 system"></a>5.2 system</h3><p>以 Windows 系统环境下开发为例，假设现在 <code>D:\product\maven-demo-parent\demo-module\target\demo-module-1.0-SNAPSHOT.jar</code> 想要引入到我们的项目中，此时我们就可以将依赖配置为 system 范围：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.javatv.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>demo-module<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">systemPath</span>&gt;</span>D:\product\maven-demo-parent\demo-module\target\demo-module-1.0-SNAPSHOT.jar<span class="tag">&lt;/<span class="name">systemPath</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>system<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>但是很明显：这样引入依赖完全不具有可移植性，所以<strong>不要使用</strong>。</p><h3 id="5-3-runtime"><a href="#5-3-runtime" class="headerlink" title="5.3 runtime"></a>5.3 runtime</h3><p>专门用于编译时不需要，但是运行时需要的 jar 包。比如：编译时我们根据接口调用方法，但是实际运行时需要的是接口的实现类。典型案例是：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--热部署 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="6-profile"><a href="#6-profile" class="headerlink" title="6. profile"></a>6. profile</h2><h3 id="6-1-profile-概述"><a href="#6-1-profile-概述" class="headerlink" title="6.1 profile 概述"></a>6.1 profile 概述</h3><p><img src="/./../images/maven%E4%BB%93%E5%BA%93/201f157c51c9a8a97f9787ec0132cf8a.png" alt="image-20220601162525659"></p><p>这里我们可以对接 profile 这个单词中『侧面』这个含义：项目的每一个运行环境，相当于是项目整体的一个侧面。</p><p><img src="/./../images/maven%E4%BB%93%E5%BA%93/e003e64fda9fbe59e0b0918ecf5eab6c.png" alt="image-20220601162550102"></p><p>通常情况下，我们项目至少有三种运行环境：</p><ul><li>开发环境：供不同开发工程师开发的各个模块之间互相调用、访问；内部使用</li><li>测试环境：供测试工程师对项目的各个模块进行功能测试；内部使用</li><li>生产环境：供最终用户访问——所以这是正式的运行环境，对外提供服务</li></ul><p><img src="/./../images/maven%E4%BB%93%E5%BA%93/b824b4360f6df944bb91e4bb8a0b6d60.png" alt="image-20220601162840282"></p><p>而我们这里的『环境』仍然只是一个笼统的说法，实际工作中一整套运行环境会包含很多种不同服务器：</p><ul><li>MySQL</li><li>Redis</li><li>ElasticSearch</li><li>RabbitMQ</li><li>FastDFS</li><li>Nginx</li><li>Tomcat</li><li>……</li></ul><p>就拿其中的 MySQL 来说，不同环境下的访问参数肯定完全不同，可是代码只有一套。如果在 jdbc.properties 里面来回改，那就太麻烦了，而且很容易遗漏或写错，增加调试的难度和工作量。所以最好的办法就是把适用于各种不同环境的配置信息分别准备好，部署哪个环境就激活哪个配置。</p><p>在 Maven 中，使用 profile 机制来管理不同环境下的配置信息。但是解决同类问题的类似机制在其他框架中也有，而且从模块划分的角度来说，持久化层的信息放在构建工具中配置也违反了『高内聚，低耦合』的原则。</p><p>实际上，即使我们在 pom.xml 中不配置 profile 标签，也已经用到 profile了。为什么呢？因为根标签 project 下所有标签相当于都是在设定默认的 profile。这样一来我们也就很容易理解下面这句话：project 标签下除了 modelVersion 和坐标标签之外，其它标签都可以配置到 profile 中。</p><h3 id="6-2-profile-配置"><a href="#6-2-profile-配置" class="headerlink" title="6.2 profile 配置"></a>6.2 profile 配置</h3><h4 id="6-2-1-外部视角：配置文件"><a href="#6-2-1-外部视角：配置文件" class="headerlink" title="6.2.1 外部视角：配置文件"></a>6.2.1 外部视角：配置文件</h4><p>从外部视角来看，profile 可以在下面两种配置文件中配置：</p><ul><li>settings.xml：全局生效。其中我们最熟悉的就是配置 JDK 1.8。</li><li>pom.xml：当前 POM 生效</li></ul><h4 id="6-2-2-内部实现：具体标签"><a href="#6-2-2-内部实现：具体标签" class="headerlink" title="6.2.2 内部实现：具体标签"></a>6.2.2 内部实现：具体标签</h4><p>从内部视角来看，配置 profile 有如下语法要求：</p><p><strong>① profiles&#x2F;profile 标签</strong></p><ul><li>由于 profile 天然代表众多可选配置中的一个所以由复数形式的 profiles 标签统一管理。</li><li>由于 profile 标签覆盖了 pom.xml 中的默认配置，所以 profiles 标签通常是 pom.xml 中的最后一个标签。</li></ul><p><strong>② id 标签</strong></p><p>每个 profile 都必须有一个 id 标签，指定该 profile 的唯一标识。这个 id 标签的值会在命令行调用 profile 时被用到。这个命令格式是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-D&lt;profile id&gt;</span><br></pre></td></tr></table></figure><p><strong>③ 其它允许出现的标签</strong></p><p>一个 profile 可以覆盖项目的最终名称、项目依赖、插件配置等各个方面以影响构建行为。</p><ul><li>build<ul><li>defaultGoal</li><li>finalName</li><li>resources</li><li>testResources</li><li>plugins</li></ul></li><li>reporting</li><li>modules</li><li>dependencies</li><li>dependencyManagement</li><li>repositories</li><li>pluginRepositories</li><li>properties</li></ul><h3 id="6-3-激活-profile"><a href="#6-3-激活-profile" class="headerlink" title="6.3 激活 profile"></a>6.3 激活 profile</h3><p><strong>① 默认配置默认被激活</strong></p><p>前面提到了，POM 中没有在 profile 标签里的就是默认的 profile，当然默认被激活。</p><p><strong>② 基于环境信息激活</strong></p><p>环境信息包含：JDK 版本、操作系统参数、文件、属性等各个方面。一个 profile 一旦被激活，那么它定义的所有配置都会覆盖原来 POM 中对应层次的元素。可参考下面的标签结构：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span>&gt;</span>dev<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 配置是否默认激活 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>false<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jdk</span>&gt;</span>1.5<span class="tag">&lt;/<span class="name">jdk</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">os</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>Windows XP<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">family</span>&gt;</span>Windows<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">arch</span>&gt;</span>x86<span class="tag">&lt;/<span class="name">arch</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.2600<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">os</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>mavenVersion<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>2.0.5<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">file</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exists</span>&gt;</span>file2.properties<span class="tag">&lt;/<span class="name">exists</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">missing</span>&gt;</span>file1.properties<span class="tag">&lt;/<span class="name">missing</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里有个问题是：多个激活条件之间是什么关系呢？</p><ul><li>Maven <strong>3.2.2 之前</strong>：遇到第一个满足的条件即可激活——<strong>或</strong>的关系。</li><li>Maven <strong>3.2.2 开始</strong>：各条件均需满足——<strong>且</strong>的关系。</li></ul><p>下面我们来看一个具体例子。假设有如下 profile 配置，在 JDK 版本为 1.6 时被激活：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>JDK1.6<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 指定激活条件为：JDK 1.6 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jdk</span>&gt;</span>1.6<span class="tag">&lt;/<span class="name">jdk</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">        ……</span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里需要指出的是：Maven 会自动检测当前环境安装的 JDK 版本，只要 JDK 版本是以 1.6 开头都算符合条件。下面几个例子都符合：</p><ul><li>1.6.0_03</li><li>1.6.0_02</li><li>……</li></ul><h3 id="6-4-Maven-profile-多环境管理"><a href="#6-4-Maven-profile-多环境管理" class="headerlink" title="6.4 Maven profile 多环境管理"></a>6.4 Maven profile 多环境管理</h3><p>在开发过程中，我们的软件会面对不同的运行环境，比如开发环境、测试环境、生产环境，而我们的软件在不同的环境中，有的配置可能会不一样，比如数据源配置、日志文件配置、以及一些软件运行过程中的基本配置，那每次我们将软件部署到不同的环境时，都需要修改相应的配置文件，这样来回修改，很容易出错，而且浪费劳动力。</p><p>因此我们可以利用 Maven 的 profile 来进行定义多个 profile，然后每个profile对应不同的激活条件和配置信息，从而达到不同环境使用不同配置信息的效果。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- profile对资源的操作 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 先排除所有环境相关的配置文件 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>application*.yml<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 是否替换 @xx@ 表示的maven properties属性值 --&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--通过开启 filtering，maven 会将文件中的 @xx@ 替换 profile 中定义的 xx 变量/属性--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>application.yml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>application-$&#123;profileActive&#125;.yml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--多环境文件配置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--开发环境--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>dev<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--默认激活--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">profileActive</span>&gt;</span>dev<span class="tag">&lt;/<span class="name">profileActive</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--测试环境--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>test<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">profileActive</span>&gt;</span>test<span class="tag">&lt;/<span class="name">profileActive</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--正式环境--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>prod<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">profileActive</span>&gt;</span>prod<span class="tag">&lt;/<span class="name">profileActive</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在 idea 中可以看到，因此，当你需要打包哪一个环境的就勾选即可：</p><p><img src="/./../images/maven%E4%BB%93%E5%BA%93/eb3e2a464b7f86539ad800baff1451d7.png" alt="image-20220606114707970"></p><p>同时，SpringBoot 天然支持多环境配置，一般来说，<code>application.yml</code>存放公共的配置，<code>application-dev.yml</code>、<code>application-test.yml</code>、<code>application.prod.yml</code>分别存放三个环境的配置。如下：</p><p><img src="/./../images/maven%E4%BB%93%E5%BA%93/18446fb5fe30675d690c83dd87933e2b.png" alt="image-20220606112441832"></p><p><code>application.yml</code> 中配置<code>spring.profiles.active=prod</code>（或者dev、test）指定使用的配置文件，如下：</p><p><img src="/./../images/maven%E4%BB%93%E5%BA%93/a870d4ecfca2efde614817e33a2b1fc9.png" alt="image-20220606115635516"></p><p>注：<code>profileActive</code>，就是上面我们自定义的标签。</p><p>然后当我们勾选哪一个环境，打包的配置文件就是那一个环境：</p><p><img src="/./../images/maven%E4%BB%93%E5%BA%93/6497a5864c43a5bde7c4dfbef0b8ba5f.png" alt="image-20220606142000391"></p><p>同时我们再在 resource 标签下看到 includes 和 excludes 标签。它们的作用是：</p><ul><li>includes：指定执行 resource 阶段时要包含到目标位置的资源</li><li>excludes：指定执行 resource 阶段时要排除的资源</li></ul><h2 id="7-搭建-Maven-私服：Nexus"><a href="#7-搭建-Maven-私服：Nexus" class="headerlink" title="7. 搭建 Maven 私服：Nexus"></a>7. 搭建 Maven 私服：Nexus</h2><p>很多公司都是搭建自己的 Maven 私有仓库，主要用于项目的公共模块的迭代更新等。</p><p><img src="/./../images/maven%E4%BB%93%E5%BA%93/98eeaeed40e2429b0d4691bd40d08572.png" alt="image-20220606143030533"></p><h3 id="7-1-Nexus-下载安装"><a href="#7-1-Nexus-下载安装" class="headerlink" title="7.1 Nexus 下载安装"></a>7.1 Nexus 下载安装</h3><p>下载地址：<a href="https://download.sonatype.com/nexus/3/latest-unix.tar.gz">https://download.sonatype.com/nexus/3/latest-unix.tar.gz</a></p><p>百度网盘：<a href="https://pan.baidu.com/s/12IjpSSUSZa6wHZoQ8wHsxg">https://pan.baidu.com/s/12IjpSSUSZa6wHZoQ8wHsxg</a> （提取码：5bu6）</p><p>然后将下载的文件上传到 Linux 系统，解压后即可使用，不需要安装。但是需要<strong>注意</strong>：必须提前安装 JDK。（我这里放在 &#x2F;root&#x2F;nexus 下）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf nexus-3.25.1-04-unix.tar.gz</span><br></pre></td></tr></table></figure><p>解压后如下：</p><p><img src="/./../images/maven%E4%BB%93%E5%BA%93/b937802c534604151e0cccf81868f36f.png" alt="image-20220606144656822"></p><p>通过以下命令启动：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 启动</span><br><span class="line">/root/nexus/nexus-3.25.1-04/bin/nexus start</span><br><span class="line"># 查看状态</span><br><span class="line">/root/nexus/nexus-3.25.1-04/bin/nexus status</span><br></pre></td></tr></table></figure><p><img src="/./../images/maven%E4%BB%93%E5%BA%93/c321eec247673cb477b995790b1e923c.png" alt="image-20220606145226352"></p><p>如果显示<code>nexus is stopped.</code>则说明启动失败，通过命令查看端口占用情况：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstart -luntp|grep java</span><br></pre></td></tr></table></figure><p><img src="/./../images/maven%E4%BB%93%E5%BA%93/46961b85df32c1ef2df1a060565f9c5d.png" alt="image-20220606145457084"></p><p>可以看到 8081 端口被占用，而 nexus 的默认端口为 8081，我们可以修改其默认端口号，其配置文件在 <code>etc</code>目录下的<code>nexus-default.properties</code>，如下：</p><p><img src="/./../images/maven%E4%BB%93%E5%BA%93/31a6f1370420c4688e663b7d91e2bf55.png" alt="image-20220606145845965"></p><p>打开后修改为自己需要设置的端口，注意开启对外防火墙：</p><p><img src="/./../images/maven%E4%BB%93%E5%BA%93/23d5679f50097dacbf8c56a7fcd1630c.png" alt="image-20220606145927153"></p><p><strong>提示</strong>：</p><blockquote><p>bin目录下 nexus.vmoptions 文件，可调整内存参数，防止占用内存太大。</p><p>etc目录下 nexus-default.properties 文件可配置默认端口和host及访问根目录。</p></blockquote><p>然后访问 <code>http://[Linux 服务器地址]:8081/</code>进入首页：</p><p><img src="/./../images/maven%E4%BB%93%E5%BA%93/524b51f5570dee0a177d993c405e34df.png" alt="image-20220606151654339"></p><h3 id="7-2-初始设置"><a href="#7-2-初始设置" class="headerlink" title="7.2 初始设置"></a>7.2 初始设置</h3><p>点击右上角的登录：</p><p><img src="/./../images/maven%E4%BB%93%E5%BA%93/4e4cd547ffde54f3c26cdbb64751c7d8.png" alt="image-20220606152046968"></p><p>这里参考提示：</p><ul><li>用户名：admin</li><li>密码：查看 &#x2F;opt&#x2F;sonatype-work&#x2F;nexus3&#x2F;admin.password 文件</li></ul><p>然后输入密码进行下一步：</p><p><img src="/./../images/maven%E4%BB%93%E5%BA%93/476278e527a1f1a8d6eb6b2c2afe76d1.png" alt="image-20220606152336266"></p><p>匿名登录，启用还是禁用？由于启用匿名登录后，后续操作比较简单，这里我们演示禁用匿名登录的操作方式：</p><p><img src="/./../images/maven%E4%BB%93%E5%BA%93/68007085b267592e871bc92b69629e38.png" alt="image-20220606152408234"></p><p>除了默认账号 admin，admin 具有全部权限，还有 anonymous，anonymous 作为匿名用户，只具有查看权限，但可以查看仓库并下载依赖。</p><p>完成：</p><p><img src="/./../images/maven%E4%BB%93%E5%BA%93/2cc66ebefa3a70ee04116998c41c7a04.png" alt="image-20220606152430477"></p><h3 id="7-3-Nexus-Repository"><a href="#7-3-Nexus-Repository" class="headerlink" title="7.3 Nexus Repository"></a>7.3 Nexus Repository</h3><p>nexus 默认创建了几个仓库，如下：</p><p><img src="/./../images/maven%E4%BB%93%E5%BA%93/fba9f2538094de570ec22c4592034779.png" alt="image-20220606152951773"></p><p>其中仓库 Type 类型为：</p><table><thead><tr><th>仓库类型</th><th>说明</th></tr></thead><tbody><tr><td>proxy</td><td>某个远程仓库的代理</td></tr><tr><td>group</td><td>存放：通过 Nexus 获取的第三方 jar 包</td></tr><tr><td>hosted</td><td>存放：本团队其他开发人员部署到 Nexus 的 jar 包</td></tr></tbody></table><p>仓库名称：</p><table><thead><tr><th>仓库名称</th><th>说明</th></tr></thead><tbody><tr><td>maven-central</td><td>Nexus 对 Maven 中央仓库的代理</td></tr><tr><td>maven-public</td><td>Nexus 默认创建，供开发人员下载使用的组仓库</td></tr><tr><td>maven-releasse</td><td>Nexus 默认创建，供开发人员部署自己 jar 包的宿主仓库，要求 releasse 版本</td></tr><tr><td>maven-snapshots</td><td>Nexus 默认创建，供开发人员部署自己 jar 包的宿主仓库，要求 snapshots 版本</td></tr></tbody></table><p>其中 maven-public 相当于仓库总和，默认把其他 3 个仓库加进来一起对外提供服务了，另外，如果有自己建的仓库，也要加进该仓库才有用。</p><p>初始状态下，这几个仓库都没有内容：</p><p><img src="/./../images/maven%E4%BB%93%E5%BA%93/94d8020f127d1569af0f26c539e69a54.png" alt="image-20220606153439317"></p><h3 id="7-4-创建-Nexus-Repository"><a href="#7-4-创建-Nexus-Repository" class="headerlink" title="7.4 创建 Nexus Repository"></a>7.4 创建 Nexus Repository</h3><p>除了自带的仓库，有时候我们需要单独创建自己的仓库，按照默认创建的仓库类型来创建我们自己的仓库。</p><h4 id="7-4-1-创建-Nexus-宿主仓库"><a href="#7-4-1-创建-Nexus-宿主仓库" class="headerlink" title="7.4.1 创建 Nexus 宿主仓库"></a>7.4.1 创建 Nexus 宿主仓库</h4><p>点击左边导航栏中的 Repositories，如下图：</p><p><img src="/./../images/maven%E4%BB%93%E5%BA%93/f54117299931782d02944da402a92dbe.png" alt="image-20220606182445347"></p><p>然后创建仓库，如下：</p><p><img src="/./../images/maven%E4%BB%93%E5%BA%93/f0b9a2c0595404ec3d1c792420973076.png" alt="image-20220606182816648"></p><p>同理创建 releases 仓库，然后查看列表：</p><p><img src="/./../images/maven%E4%BB%93%E5%BA%93/c1b9fda9caa39434669622787dc57003.png" alt="image-20220606182955022"></p><p>宿主仓库配置如下：</p><table><thead><tr><th>配置</th><th>说明</th></tr></thead><tbody><tr><td>Repository ID</td><td>仓库 ID。</td></tr><tr><td>Repository Name</td><td>仓库名称。</td></tr><tr><td>Repository Type</td><td>仓库的类型，如 hosted、proxy 等等。</td></tr><tr><td>Provider</td><td>用来确定仓库的格式，一般默认选择 Maven2。</td></tr><tr><td>Repository Policy</td><td>仓库的策略。</td></tr><tr><td>Default Local Storage Location</td><td>仓库默认存储目录，例如 D:\nexus-2.14.20-02-bundle\sonatype-work\nexus\indexer\bianchengbang_Snapshot_hosted_ctx。</td></tr><tr><td>Override Local Storage Location</td><td>自定义仓库存储目录。</td></tr><tr><td>Deployment Policy</td><td>仓库的部署策略。</td></tr><tr><td>Allow File Browsing</td><td>用来控制是否允许浏览仓库内容，一般选择 true。</td></tr><tr><td>Include in Search</td><td>用来控制该仓库是否创建索引并提供搜索功能。</td></tr><tr><td>Publish URL</td><td>用来控制是否通过 URL 提供服务。</td></tr><tr><td>Not Found Cache TTL</td><td>缓存某构件不存在信息的时间，默认取值为 1440，表示若某一个构件在仓库中没有找到，在 1440 分钟内再次接收到该构件的请求，则直接返回不存在信息，不会再次查找。</td></tr></tbody></table><h4 id="7-4-2-创建-Nexus-代理仓库"><a href="#7-4-2-创建-Nexus-代理仓库" class="headerlink" title="7.4.2 创建 Nexus 代理仓库"></a>7.4.2 创建 Nexus 代理仓库</h4><p>然后建一个代理仓库，用来下载和缓存中央仓库（或者阿里云仓库）的构件，这里选择 proxy：</p><p><img src="/./../images/maven%E4%BB%93%E5%BA%93/1138614f6cf17ce8c4055afb740a70cb.png" alt="image-20220606183224448"></p><p>然后创建：</p><p><img src="/./../images/maven%E4%BB%93%E5%BA%93/23524ca99b42957fb371f2bd5174c67d.png" alt="image-20220606183625913"></p><p>代理仓库配置中，仓库 ID、仓库名称、Provider、Policy 以及 Default Local Storage Location 等配置的含义与宿主仓库相同，不再赘述。需要注意的是，代理仓库的 Repository Type 的取值是 proxy。</p><p>代理仓库配置如下表：</p><table><thead><tr><th>配置</th><th>说明</th></tr></thead><tbody><tr><td>Remote Storage Location</td><td>远程仓库或中央仓库的地址，它是 Nexus 代理仓库最重要得配置，必须输入有效值，通常取值为 <a href="https://repo1.maven.org/maven2/%E3%80%82">https://repo1.maven.org/maven2/。</a></td></tr><tr><td>Download Remote Indexes</td><td>是否下载远程仓库的索引。</td></tr><tr><td>Auto Blocking Enabled</td><td>是否启用自动阻止，即当 Nexus 无法连接中央仓库或远程仓库时，是否一直等待。取值为 true 表示不再等待，直接通知客户端无法连接，并返回。</td></tr><tr><td>File Content Validation</td><td>是否启用文件内容校验。</td></tr><tr><td>Checksum Policy</td><td>配置校验和出错时的策略，用户可以选择忽略、警告、记录警告信息或拒绝下载等多种策略。</td></tr><tr><td>Artifact Max Age</td><td>构件缓存的最长时间，对于发布版本仓库来说，默认值为 -1，表示构件缓存后，就一直保存着，不再重新下载。对于快照版本仓库来说，默认值为 1440 分钟，表示每隔一天重新缓存一次代理的构件。</td></tr><tr><td>Metadata Max Age</td><td>仓库元数据缓存的最长时间。</td></tr><tr><td>Item Max Age</td><td>项目缓存的最长时间。</td></tr></tbody></table><h4 id="7-4-3-创建-Nexus-仓库组"><a href="#7-4-3-创建-Nexus-仓库组" class="headerlink" title="7.4.3 创建 Nexus 仓库组"></a>7.4.3 创建 Nexus 仓库组</h4><p>下面我们将创建一个仓库组，并将刚刚创建的 3 个仓库都聚合起来，这里选择 group，如下：</p><p><img src="/./../images/maven%E4%BB%93%E5%BA%93/0370368341bc7e864c9a1f788cd64509.png" alt="image-20220606183938914"></p><p>查看 Nexus 仓库列表，可以看到创建的仓库组已经创建完成，如下图：</p><p><img src="/./../images/maven%E4%BB%93%E5%BA%93/6ac9ab661782d42e2b04db3d01f14273.png" alt="image-20220606184518165"></p><h3 id="7-5-通过-Nexus-下载-jar-包"><a href="#7-5-通过-Nexus-下载-jar-包" class="headerlink" title="7.5 通过 Nexus 下载 jar 包"></a>7.5 通过 Nexus 下载 jar 包</h3><p>由于初始状态下都没有内容，所以我们需要进行配置，我们先在本地的 Maven 的配置文件中新建一个空的本地仓库作为测试。</p><p><img src="/./../images/maven%E4%BB%93%E5%BA%93/55abb53e47571a1ae7abfdeacf41e642.png" alt="image-20220606154105497"></p><p>然后，把我们原来配置阿里云仓库地址的 mirror 标签改成下面这样：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span>&gt;</span>maven-public<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>Maven public<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://106.15.15.213:8090/repository/maven-public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里的 url 标签是这么来的：</p><p><img src="/./../images/maven%E4%BB%93%E5%BA%93/80e3f670a3c88e71b7ea9270b8614ac8.png" alt="image-20220606154441373"></p><p>把上图中看到的地址复制出来即可。如果我们在前面允许了匿名访问，到这里就够了。但如果我们禁用了匿名访问，那么接下来我们还要继续配置 settings.xml：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span>&gt;</span>maven-public<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">username</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">password</span>&gt;</span>@123456<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：server 标签内的 id 标签值必须和 mirror 标签中的 id 值一样。</p><p>然后找一个用到框架的 Maven 工程，编译 compile，下载过程日志：</p><p><img src="/./../images/maven%E4%BB%93%E5%BA%93/b945792a8e38bb5c8e82b9a0f541d682.png" alt="image-20220606160556887"></p><p>下载后，Nexus 服务器上就有了 jar 包：</p><p><img src="/./../images/maven%E4%BB%93%E5%BA%93/6e85771e6c14358cf5ef350cbef627b7.png" alt="image-20220606160657138"></p><h3 id="7-6-将-jar-包部署到-Nexus"><a href="#7-6-将-jar-包部署到-Nexus" class="headerlink" title="7.6 将 jar 包部署到 Nexus"></a>7.6 将 jar 包部署到 Nexus</h3><p>这一步的作用是将通用的模块打成 jar 包，发布到 Nexus 私服，让其他的项目来引用，以更简洁高效的方式来实现复用和管理。</p><p>需要配置 server：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span>&gt;</span>maven-public<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">username</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">password</span>&gt;</span>@123456<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span>&gt;</span>maven-releases<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">username</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">password</span>&gt;</span>@123456<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span>&gt;</span>maven-snapshots<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">username</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">password</span>&gt;</span>@123456<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在我们需要上传的 maven 项目中的<code>pom.xml</code>添加如下配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 这里的 id 要和上面的 server 的 id 保持一致,name 随意写--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">distributionManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>maven-releases<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>Releases Repository<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://106.15.15.213:8090/repository/maven-releases/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">snapshotRepository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>maven-snapshots<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>Snapshot Repository<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://106.15.15.213:8090/repository/maven-snapshots/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">snapshotRepository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">distributionManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="7-6-1-上传到-maven-snapshots"><a href="#7-6-1-上传到-maven-snapshots" class="headerlink" title="7.6.1 上传到 maven-snapshots"></a>7.6.1 上传到 maven-snapshots</h4><p>执行命令 <code>mvn deploy</code> 将当前 SNAPSHOT（快照版）上传到私服 maven-snapshots。</p><p><img src="/./../images/maven%E4%BB%93%E5%BA%93/305e58fefea822e872166e5d6689754a.png" alt="image-20220606165417072"></p><h4 id="7-6-2-上传到-maven-releases"><a href="#7-6-2-上传到-maven-releases" class="headerlink" title="7.6.2 上传到 maven-releases"></a>7.6.2 上传到 maven-releases</h4><p>修改项目的版本，如下：</p><p><img src="/./../images/maven%E4%BB%93%E5%BA%93/5f248655c6d2d81f2f1ac0882d9301a9.png" alt="image-20220606165516336"></p><p>执行命令 <code>mvn deploy</code>：</p><p><img src="/./../images/maven%E4%BB%93%E5%BA%93/7bf06b148f2d1afad36c9b8fda2c1c5f.png" alt="image-20220606165553247"></p><p>查看：</p><p><img src="/./../images/maven%E4%BB%93%E5%BA%93/e7a977664da960b331d6a7f7aeab1b75.png" alt="image-20220606165642474"></p><blockquote><p>package 命令完成了项目编译、单元测试、打包功能。</p><p>install 命令完成了项目编译、单元测试、打包功能，同时把打好的可执行jar包（war包或其它形式的包）布署到本地maven仓库。</p><p>deploy 命令完成了项目编译、单元测试、打包功能，同时把打好的可执行jar包（war包或其它形式的包）布署到本地maven仓库和远程maven私服仓库。</p></blockquote><h2 id="8-jar-包冲突问题"><a href="#8-jar-包冲突问题" class="headerlink" title="8. jar 包冲突问题"></a>8. jar 包冲突问题</h2><p>先给结论：编订依赖列表的程序员。初次设定一组依赖，因为尚未经过验证，所以确实有可能存在各种问题，需要做有针对性的调整。那么谁来做这件事呢？我们最不希望看到的就是：团队中每个程序员都需要自己去找依赖，即使是做同一个项目，每个模块也各加各的依赖，没有统一管理。那前人踩过的坑，后人还要再踩一遍。而且大家用的依赖有很多细节都不一样，版本更是五花八门，这就让事情变得更加复杂。</p><p>所以虽然初期需要根据项目开发和实际运行情况对依赖配置不断调整，最终确定一个各方面都 OK 的版本。但是一旦确定下来，放在父工程中做依赖管理，各个子模块各取所需，这样基本上就能很好的避免问题的扩散。</p><p>即使开发中遇到了新问题，也可以回到源头检查、调整 dependencyManagement 配置的列表——而不是每个模块都要改。</p><h3 id="8-1-表现形式"><a href="#8-1-表现形式" class="headerlink" title="8.1 表现形式"></a>8.1 表现形式</h3><p>由于实际开发时我们往往都会整合使用很多大型框架，所以一个项目中哪怕只是一个模块也会涉及到大量 jar 包。数以百计的 jar 包要彼此协调、精密配合才能保证程序正常运行。而规模如此庞大的 jar 包组合在一起难免会有磕磕碰碰。最关键的是由于 jar 包冲突所导致的问题非常诡异，这里我们只能罗列较为典型的问题，而没法保证穷举。</p><p>但是我们仍然能够指出一点：一般来说，由于我们自己编写代码、配置文件写错所导致的问题通常能够在异常信息中看到我们自己类的全类名或配置文件的所在路径。如果整个错误信息中完全没有我们负责的部分，全部是框架、第三方工具包里面的类报错，这往往就是 jar 包的问题所引起的。</p><p>而具体的表现形式中，主要体现为找不到类或找不到方法。</p><h4 id="8-1-1-抛异常：找不到类"><a href="#8-1-1-抛异常：找不到类" class="headerlink" title="8.1.1 抛异常：找不到类"></a>8.1.1 抛异常：找不到类</h4><p>此时抛出的常见的异常类型：</p><ul><li>java.lang.<strong>ClassNotFoundException</strong>：编译过程中找不到类</li><li>java.lang.<strong>NoClassDefFoundError</strong>：运行过程中找不到类</li><li>java.lang.<strong>LinkageError</strong>：不同类加载器分别加载的多个类有相同的全限定名</li></ul><p>我们来举个例子：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.httpcomponents<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>httpclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.x.x<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>httpclient 这个 jar 包中有一个类：org.apache.http.conn.ssl.NoopHostnameVerifier。这个类在较低版本中没有，但在较高版本存在。比如：</p><table><thead><tr><th>jar 包版本</th><th>是否存在</th></tr></thead><tbody><tr><td>4.3.6</td><td>否</td></tr><tr><td>4.4</td><td>是</td></tr></tbody></table><p>那当我们确实需要用到 NoopHostnameVerifier 这个类，我们看到 Maven 通过依赖传递机制引入了这个 jar 包，所以没有明确地显式声明对这个 jar 包的依赖。可是 Maven 传递过来的 jar 包是 4.3.6 版本，里面没有包含我们需要的类，就会抛出异常。</p><p>而『冲突』体现在：4.3.6 和 4.4 这两个版本的 jar 包都被框架所依赖的 jar 包给传递进来了，但是假设 Maven 根据**『版本仲裁』**规则实际采纳的是 4.3.6。</p><blockquote><p><strong>版本仲裁</strong></p><p>Maven 的版本仲裁机制只是在没有人为干预的情况下，自主决定 jar 包版本的一个办法。而实际上我们要使用具体的哪一个版本，还要取决于项目中的实际情况。所以在项目正常运行的情况下，jar 包版本可以由 Maven 仲裁，不必我们操心；而发生冲突时 Maven 仲裁决定的版本无法满足要求，此时就应该由程序员明确指定 jar 包版本。</p></blockquote><p>版本仲裁遵循以下规则：</p><ul><li><p><strong>最短路径优先</strong></p><p>在下图的例子中，对模块 pro25-module-a 来说，Maven 会采纳 1.2.12 版本。</p><p><img src="/./../images/maven%E4%BB%93%E5%BA%93/13787beebac48a4140781a9cf6424a5a.png" alt="image-20220607101311677"></p></li><li><p><strong>路径相同时先声明者优先</strong></p><p>此时 Maven 采纳哪个版本，取决于在 pro29-module-x 中，对 pro30-module-y 和 pro31-module-z 两个模块的依赖哪一个先声明。</p><p><img src="/./../images/maven%E4%BB%93%E5%BA%93/07e027c80eddb5caa23251ccac5c4495.png" alt="image-20220607101401799"></p></li></ul><h4 id="8-1-2-抛异常：找不到方法"><a href="#8-1-2-抛异常：找不到方法" class="headerlink" title="8.1.2 抛异常：找不到方法"></a>8.1.2 抛异常：找不到方法</h4><p>程序找不到符合预期的方法。这种情况多见于通过反射调用方法，所以经常会导致：java.lang.NoSuchMethodError。</p><h4 id="8-1-3-没报错但结果不对"><a href="#8-1-3-没报错但结果不对" class="headerlink" title="8.1.3 没报错但结果不对"></a>8.1.3 没报错但结果不对</h4><p>发生这种情况比较典型的原因是：两个 jar 包中的类分别实现了同一个接口，这本来是很正常的。但是问题在于：由于没有注意命名规范，两个不同实现类恰巧是同一个名字。</p><p><img src="/./../images/maven%E4%BB%93%E5%BA%93/ca0c35da596a8af0e6319b770230fb02.png" alt="image-20220607101724531"></p><p>具体例子是实际工作中遇到过：项目中部分模块使用 log4j 打印日志；其它模块使用 logback，编译运行都不会冲突，但是会引起日志服务降级，让你的 log 配置文件失效。比如：你指定了 error 级别输出，但是冲突就会导致 info、debug 都在输出。</p><h3 id="8-2-本质"><a href="#8-2-本质" class="headerlink" title="8.2 本质"></a>8.2 本质</h3><p>以上表现形式归根到底是<strong>两种基本情况</strong>导致的：</p><ul><li><strong>同一 jar 包的不同版本</strong></li></ul><p><img src="/./../images/maven%E4%BB%93%E5%BA%93/b2d110c5d4574b9c8ee5bf90e9c46d00.png" alt="在这里插入图片描述"></p><ul><li><p><strong>不同 jar 包中包含同名类</strong></p><p>这里我们拿 netty 来举个例子，netty 是一个类似 Tomcat 的 Servlet 容器。通常我们不会直接依赖它，所以基本上都是框架传递进来的。那么当我们用到的框架很多时，就会有不同的框架用不同的坐标导入 netty。可以参照下表对比一下两组坐标：</p><table><thead><tr><th>截止到3.2.10.Final版本以前的坐标形式：</th><th>从3.3.0.Final版本开始以后的坐标形式：</th></tr></thead><tbody><tr><td><strong>org.jboss.netty</strong> <strong>netty</strong> <strong>3.2.10.Final</strong></td><td><strong>io.netty</strong> <strong>netty</strong> <strong>3.9.2.Final</strong></td></tr></tbody></table><p>但是偏偏这两个『<strong>不同的包</strong>』里面又有很多『<strong>全限定名相同</strong>』的类。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">org.jboss.netty.channel.socket.ServerSocketChannelConfig.<span class="keyword">class</span></span><br><span class="line"><span class="title class_">org</span>.jboss.netty.channel.socket.nio.NioSocketChannelConfig.<span class="keyword">class</span></span><br><span class="line"><span class="title class_">org</span>.jboss.netty.util.internal.jzlib.Deflate.<span class="keyword">class</span></span><br><span class="line"><span class="title class_">org</span>.jboss.netty.handler.codec.serialization.ObjectDecoder.<span class="keyword">class</span></span><br><span class="line"><span class="title class_">org</span>.jboss.netty.util.internal.ConcurrentHashMap$HashIterator.<span class="keyword">class</span></span><br><span class="line"><span class="title class_">org</span>.jboss.netty.util.internal.jzlib.Tree.<span class="keyword">class</span></span><br><span class="line"><span class="title class_">org</span>.jboss.netty.util.internal.ConcurrentIdentityWeakKeyHashMap$Segment.<span class="keyword">class</span></span><br><span class="line"><span class="title class_">org</span>.jboss.netty.handler.logging.LoggingHandler.<span class="keyword">class</span></span><br><span class="line"><span class="title class_">org</span>.jboss.netty.channel.ChannelHandlerLifeCycleException.<span class="keyword">class</span></span><br><span class="line"><span class="title class_">org</span>.jboss.netty.util.internal.ConcurrentIdentityHashMap$ValueIterator.<span class="keyword">class</span></span><br><span class="line"><span class="title class_">org</span>.jboss.netty.util.internal.ConcurrentIdentityWeakKeyHashMap$Values.<span class="keyword">class</span></span><br><span class="line"><span class="title class_">org</span>.jboss.netty.util.internal.UnterminatableExecutor.<span class="keyword">class</span></span><br><span class="line"><span class="title class_">org</span>.jboss.netty.handler.codec.compression.ZlibDecoder.<span class="keyword">class</span></span><br><span class="line"><span class="title class_">org</span>.jboss.netty.handler.codec.rtsp.RtspHeaders$Values.<span class="keyword">class</span></span><br><span class="line"><span class="title class_">org</span>.jboss.netty.handler.codec.replay.ReplayError.<span class="keyword">class</span></span><br><span class="line"><span class="title class_">org</span>.jboss.netty.buffer.HeapChannelBufferFactory.class</span><br><span class="line"></span><br><span class="line">……</span><br></pre></td></tr></table></figure></li></ul><h3 id="8-3-解决办法"><a href="#8-3-解决办法" class="headerlink" title="8.3 解决办法"></a>8.3 解决办法</h3><p>很多情况下常用框架之间的整合容易出现的冲突问题都有人总结过了，拿抛出的异常搜索一下基本上就可以直接找到对应的 jar 包。我们接下来要说的是通用方法。</p><p>不管具体使用的是什么工具，基本思路无非是这么两步：</p><ul><li>第一步：把彼此冲突的 jar 包找到</li><li>第二步：在冲突的 jar 包中选定一个。具体做法无非是通过 exclusions 排除依赖，或是明确声明依赖。</li></ul><h4 id="8-3-1-IDEA-的-Maven-Helper-插件"><a href="#8-3-1-IDEA-的-Maven-Helper-插件" class="headerlink" title="8.3.1 IDEA 的 Maven Helper 插件"></a>8.3.1 IDEA 的 Maven Helper 插件</h4><p>这个插件是 IDEA 中安装的插件，不是 Maven 插件。它能够给我们罗列出来同一个 jar 包的不同版本，以及它们的来源。但是对不同 jar 包中同名的类没有办法。</p><p><img src="/./../images/maven%E4%BB%93%E5%BA%93/4cebe6c8ba1159a1a4dff198bc495af5.png" alt="image-20220607103315557"></p><p>然后基于 pom.xml 的依赖冲突分析，如下：</p><p><img src="/./../images/maven%E4%BB%93%E5%BA%93/2d80d17c31d2f236411f37aa40b851a1.png" alt="image-20220607103654229"></p><p>查看冲突分析结果：</p><p><img src="/./../images/maven%E4%BB%93%E5%BA%93/96b5cfd93330859869647df847feff83.png" alt="image-20220607103711944"></p><h4 id="8-3-2-Maven-的-enforcer-插件"><a href="#8-3-2-Maven-的-enforcer-插件" class="headerlink" title="8.3.2 Maven 的 enforcer 插件"></a>8.3.2 Maven 的 enforcer 插件</h4><p>使用 Maven 的 enforcer 插件既可以检测同一个 jar 包的不同版本，又可以检测不同 jar 包中同名的类。</p><p>这里我们引入两个对 netty 的依赖，展示不同 jar 包中有同名类的情况作为例子。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.jboss.netty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>netty<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.10.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.netty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>netty<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.9.2.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后配置 enforcer 插件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pluginManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-enforcer-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">id</span>&gt;</span>enforce-dependencies<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">phase</span>&gt;</span>validate<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>display-info<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>enforce<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.codehaus.mojo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>extra-enforcer-rules<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-beta-4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">rules</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">banDuplicateClasses</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">findAllDuplicates</span>&gt;</span>true<span class="tag">&lt;/<span class="name">findAllDuplicates</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">banDuplicateClasses</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">rules</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">pluginManagement</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>执行如下 Maven 命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean package enforcer:enforce</span><br></pre></td></tr></table></figure><p>部分运行结果：</p><p><img src="/./../images/maven%E4%BB%93%E5%BA%93/fc4ba4151fe9c69c99373f06b45337df.png" alt="image-20220607113428085"><br>总结于：<a href="https://www.bilibili.com/video/BV12q4y147e4?spm%5C_id%5C_from=333.337.search-card.all.click">https://www.bilibili.com/video/BV12q4y147e4?spm\_id\_from=333.337.search-card.all.click</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;1-Maven-是什么&quot;&gt;&lt;a href=&quot;#1-Maven-是什么&quot; class=&quot;headerlink&quot; title=&quot;1. Maven 是什么&quot;&gt;&lt;/a&gt;1. Maven 是什么&lt;/h2&gt;&lt;p&gt;Maven 是 Apache 软件基金</summary>
      
    
    
    
    <category term="Java框架" scheme="https://wx51815.github.io/categories/Java%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="Java" scheme="https://wx51815.github.io/tags/Java/"/>
    
    <category term="框架" scheme="https://wx51815.github.io/tags/%E6%A1%86%E6%9E%B6/"/>
    
    <category term="maven" scheme="https://wx51815.github.io/tags/maven/"/>
    
  </entry>
  
  <entry>
    <title>java泛型</title>
    <link href="https://wx51815.github.io/page/Java%E5%9F%BA%E7%A1%80/java%E6%B3%9B%E5%9E%8B/"/>
    <id>https://wx51815.github.io/page/Java%E5%9F%BA%E7%A1%80/java%E6%B3%9B%E5%9E%8B/</id>
    <published>2023-05-09T07:25:25.000Z</published>
    <updated>2023-06-10T07:50:13.031Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>泛型在java中有很重要的地位，无论是开源框架还是JDK源码都能看到它。</p><p><strong>毫不夸张的说，泛型是通用设计上必不可少的元素，所以真正理解与正确使用泛型，是一门必修课。</strong></p><h2 id="一：泛型的本质"><a href="#一：泛型的本质" class="headerlink" title="一：泛型的本质"></a>一：泛型的本质</h2><p>Java 泛型（generics）是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。</p><p>泛型的本质是参数化类型，即给类型指定一个参数，然后在使用时再指定此参数具体的值，那样这个类型就可以在使用时决定了。这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。</p><p><img src="/./../images/java%E6%B3%9B%E5%9E%8B/5320f006cb635c0195e03831afb9b019.png"></p><h2 id="二：为什么使用泛型"><a href="#二：为什么使用泛型" class="headerlink" title="二：为什么使用泛型"></a>二：为什么使用泛型</h2><p>泛型的好处是在编译的时候检查类型安全，并且所有的强制转换都是自动和隐式的，提高代码的重用率。</p><p><img src="/./../images/java%E6%B3%9B%E5%9E%8B/8dcb51aa95dcbb37bd796ae583c53758.png"></p><h3 id="（1）保证了类型的安全性。"><a href="#（1）保证了类型的安全性。" class="headerlink" title="（1）保证了类型的安全性。"></a><strong>（1）保证了类型的安全性。</strong></h3><p>在没有泛型之前，从集合中读取到的每一个对象都必须进行类型转换，如果不小心插入了错误的类型对象，在运行时的转换处理就会出错。</p><p>比如：没有泛型的情况下使用集合：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">noGeneric</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">ArrayList</span> <span class="variable">names</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">names.add(<span class="string">&quot;mikechen的互联网架构&quot;</span>);</span><br><span class="line">names.add(<span class="number">123</span>); <span class="comment">//编译正常</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>有泛型的情况下使用集合：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">useGeneric</span><span class="params">()</span> &#123;</span><br><span class="line">ArrayList&lt;String&gt; names = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">names.add(<span class="string">&quot;mikechen的互联网架构&quot;</span>);</span><br><span class="line">names.add(<span class="number">123</span>); <span class="comment">//编译不通过</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了泛型后，定义好的集合names在编译的时候add(123)就会编译不通过。</p><p>相当于告诉编译器每个集合接收的对象类型是什么，编译器在编译期就会做类型检查，告知是否插入了错误类型的对象，使得程序更加安全，增强了程序的健壮性。</p><h3 id="（2）-消除强制转换"><a href="#（2）-消除强制转换" class="headerlink" title="（2） 消除强制转换"></a>（2） 消除强制转换</h3><p>泛型的一个附带好处是，消除源代码中的许多强制类型转换，这使得代码更加可读，并且减少了出错机会。<br>还是举例说明，以下没有泛型的代码段需要强制转换：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">list.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> (String) list.get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>当重写为使用泛型时，代码不需要强制转换：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">list.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> list.get(<span class="number">0</span>); <span class="comment">// no cast</span></span><br></pre></td></tr></table></figure><h3 id="（3）避免了不必要的装箱、拆箱操作，提高程序的性能"><a href="#（3）避免了不必要的装箱、拆箱操作，提高程序的性能" class="headerlink" title="（3）避免了不必要的装箱、拆箱操作，提高程序的性能"></a>（3）避免了不必要的装箱、拆箱操作，提高程序的性能</h3><p>在非泛型编程中，将筒单类型作为Object传递时会引起Boxing（装箱）和Unboxing（拆箱）操作，这两个过程都是具有很大开销的。引入泛型后，就不必进行Boxing和Unboxing操作了，所以运行效率相对较高，特别在对集合操作非常频繁的系统中，这个特点带来的性能提升更加明显。</p><p>泛型变量固定了类型，使用的时候就已经知道是值类型还是引用类型，避免了不必要的装箱、拆箱操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">object a=<span class="number">1</span>;<span class="comment">//由于是object类型，会自动进行装箱操作。</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> b=(<span class="type">int</span>)a;<span class="comment">//强制转换，拆箱操作。这样一去一来，当次数多了以后会影响程序的运行效率。</span></span><br></pre></td></tr></table></figure><p>使用泛型之后</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> T GetValue&lt;T&gt;(T a)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">　　<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">Main</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">　　<span class="type">int</span> b=GetValue&lt;<span class="type">int</span>&gt;(<span class="number">1</span>);<span class="comment">//使用这个方法的时候已经指定了类型是int，所以不会有装箱和拆箱的操作。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="（4）提高了代码的重用性。"><a href="#（4）提高了代码的重用性。" class="headerlink" title="（4）提高了代码的重用性。"></a>（4）提高了代码的重用性。</h3><h2 id="三：如何使用泛型"><a href="#三：如何使用泛型" class="headerlink" title="三：如何使用泛型"></a>三：如何使用泛型</h2><p>泛型有三种使用方式，分别为：泛型类、泛型接口和泛型方法。</p><p><img src="/./../images/java%E6%B3%9B%E5%9E%8B/2dc13535ff35f8b493440a56fca6b306.png"></p><h3 id="1、泛型类"><a href="#1、泛型类" class="headerlink" title="1、泛型类"></a>1、泛型类</h3><p>泛型类：把泛型定义在类上</p><p>定义格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class 类名 &lt;泛型类型<span class="number">1</span>,...&gt; &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/./../images/java%E6%B3%9B%E5%9E%8B/1db3182a6d057494269abdce8295bc36.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class 类名 &lt;泛型类型<span class="number">1</span>,...&gt; &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意事项：泛型类型必须是引用类型（非基本数据类型）</p><p>定义泛型类，在类名后添加一对尖括号，并在尖括号中填写类型参数，参数可以有多个，多个参数使用逗号分隔：</p><p>public class GenericClass&lt;ab,a,c&gt; {}</p><p>当然，这个后面的参数类型也是有规范的，不能像上面一样随意，通常类型参数我们都使用大写的单个字母表示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">T：任意类型 type</span><br><span class="line">E：集合中元素的类型 element</span><br><span class="line">K：key-value形式 key</span><br><span class="line">V： key-value形式 value</span><br><span class="line">示例代码：</span><br></pre></td></tr></table></figure><p>泛型类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericClass</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T value;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GenericClass</span><span class="params">(T value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(T value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TODO 1:泛型类</span></span><br><span class="line">GenericClass&lt;String&gt; name = <span class="keyword">new</span> <span class="title class_">GenericClass</span>&lt;&gt;(<span class="string">&quot;mikechen的互联网架构&quot;</span>);</span><br><span class="line">System.out.println(name.getValue());</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">GenericClass&lt;Integer&gt; number = <span class="keyword">new</span> <span class="title class_">GenericClass</span>&lt;&gt;(<span class="number">123</span>);</span><br><span class="line">System.out.println(number.getValue());</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/./../images/java%E6%B3%9B%E5%9E%8B/6f304f380f77128aa0b4059953de4501.png"></p><h3 id="2、泛型接口"><a href="#2、泛型接口" class="headerlink" title="2、泛型接口"></a>2、泛型接口</h3><p>泛型方法概述：把泛型定义在方法上</p><p><img src="/./../images/java%E6%B3%9B%E5%9E%8B/ed46d1a9cd3bd4a129b4cefffb49a7ef.png"></p><p>定义格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;泛型类型&gt; 返回类型 方法名（泛型类型 变量名） &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意要点：方法声明中定义的形参只能在该方法里使用，而接口、类声明中定义的类型形参则可以在整个接口、类中使用。当调用fun()方法时，根据传入的实际对象，编译器就会判断出类型形参T所代表的实际类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">GenericInterface</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(T value)</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringShowImpl</span> <span class="keyword">implements</span> <span class="title class_">GenericInterface</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(String value)</span> &#123;</span><br><span class="line">        System.out.println(value);</span><br><span class="line">    &#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NumberShowImpl</span> <span class="keyword">implements</span> <span class="title class_">GenericInterface</span>&lt;Integer&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(Integer value)</span> &#123;</span><br><span class="line">        System.out.println(value);</span><br><span class="line">    &#125;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意：使用泛型的时候，前后定义的泛型类型必须保持一致，否则会出现编译异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GenericInterface&lt;String&gt; genericInterface = <span class="keyword">new</span> <span class="title class_">NumberShowImpl</span>();<span class="comment">//编译异常</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>或者干脆不指定类型，那么 new 什么类型都是可以的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GenericInterface g1 = new NumberShowImpl();</span><br><span class="line">GenericInterface g2 = new StringShowImpl();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>3、泛型方法</p><p>泛型方法，是在调用方法的时候指明泛型的具体类型 。</p><p><img src="/./../images/java%E6%B3%9B%E5%9E%8B/cbd36e763feb3d7b14c3820a3457d8bc.png">定义格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修饰符 &lt;代表泛型的变量&gt; 返回值类型 方法名(参数)&#123; &#125;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t 传入泛型的参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt; 泛型的类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> T 返回值为T类型</span></span><br><span class="line"><span class="comment">     * 说明：</span></span><br><span class="line"><span class="comment">     *   1）public 与 返回值中间&lt;T&gt;非常重要，可以理解为声明此方法为泛型方法。</span></span><br><span class="line"><span class="comment">     *   2）只有声明了&lt;T&gt;的方法才是泛型方法，泛型类中的使用了泛型的成员方法并不是泛型方法。</span></span><br><span class="line"><span class="comment">     *   3）&lt;T&gt;表明该方法将使用泛型类型T，此时才可以在方法中使用泛型类型T。</span></span><br><span class="line"><span class="comment">     *   4）与泛型类的定义一样，此处T可以随便写为任意标识，常见的如T、E等形式的参数常用于表示泛型。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">genercMethod</span><span class="params">(T t)</span>&#123;</span><br><span class="line">        System.out.println(t.getClass());</span><br><span class="line">        System.out.println(t);</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    GenericsClassDemo&lt;String&gt; genericString  = <span class="keyword">new</span> <span class="title class_">GenericsClassDemo</span>(<span class="string">&quot;helloGeneric&quot;</span>); <span class="comment">//这里的泛型跟下面调用的泛型方法可以不一样。</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> genericString.genercMethod(<span class="string">&quot;hello&quot;</span>);<span class="comment">//传入的是String类型,返回的也是String类型</span></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> genericString.genercMethod(<span class="number">123</span>);<span class="comment">//传入的是Integer类型,返回的也是Integer类型</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">java</span>.lang.String</span><br><span class="line">hello</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">java</span>.lang.Integer</span><br><span class="line"><span class="number">123</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里可以看出，泛型方法随着我们的传入参数类型不同，他得到的类型也不同。泛型方法能使方法独立于类而产生变化。</p><h2 id="四：泛型通配符"><a href="#四：泛型通配符" class="headerlink" title="四：泛型通配符"></a>四：泛型通配符</h2><p><strong>Java泛型的通配符是用于解决泛型之间引用传递问题的特殊语法, 主要有以下三类:</strong></p><p><img src="/./../images/java%E6%B3%9B%E5%9E%8B/dd75905a8af533dd3f90a52877e8c84b.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//表示类型参数可以是任何类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Apple</span>&lt;?&gt;&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//表示类型参数必须是A或者是A的子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Apple</span>&lt;T <span class="keyword">extends</span> <span class="title class_">A</span>&gt;&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//表示类型参数必须是A或者是A的超类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Apple</span>&lt;T supers A&gt;&#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>无边界的通配符(Unbounded Wildcards), 就是<?>, 比如List<?></li></ol><p>无边界的通配符的主要作用就是让泛型能够接受未知类型的数据.</p><ol start="2"><li>固定上边界的通配符(Upper Bounded Wildcards)，采用&lt;? extends E&gt;的形式</li></ol><p>使用固定上边界的通配符的泛型, 就能够接受指定类及其子类类型的数据。</p><p>要声明使用该类通配符, 采用&lt;? extends E&gt;的形式, 这里的E就是该泛型的上边界。</p><p>注意: 这里虽然用的是extends关键字, 却不仅限于继承了父类E的子类, 也可以代指显现了接口E的类</p><ol start="3"><li>固定下边界的通配符(Lower Bounded Wildcards)，采用&lt;? super E&gt;的形式</li></ol><p>使用固定下边界的通配符的泛型, 就能够接受指定类及其父类类型的数据.。</p><p>要声明使用该类通配符, 采用&lt;? super E&gt;的形式, 这里的E就是该泛型的下边界.。</p><p>注意: 你可以为一个泛型指定上边界或下边界, 但是不能同时指定上下边界。</p><h2 id="五：泛型中KTVE的含义"><a href="#五：泛型中KTVE的含义" class="headerlink" title="五：泛型中KTVE的含义"></a>五：泛型中KTVE的含义</h2><p>果点开JDK中一些泛型类的源码，我们会看到下面这些代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMap</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">AbstractMap</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K,V&gt;, Cloneable, Serializable &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这些泛型类定义中的泛型参数E、K和V都是什么意思呢？其实这些参数名称是可以任意指定，就想方法的参数名一样可以任意指定，但是我们通常会起一个有意义的名称，让别人一看就知道是什么意思。泛型参数也一样，E一般是指元素，用来集合类中。</p><p>常见泛型参数名称有如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">E： Element (在集合中使用，因为集合中存放的是元素)</span><br><span class="line">T：Type（Java 类）</span><br><span class="line">K： Key（键）</span><br><span class="line">V： Value（值）</span><br><span class="line">N： Number（数值类型）</span><br><span class="line">？： 表示不确定的java类型</span><br></pre></td></tr></table></figure><h2 id="六：泛型的实现原理"><a href="#六：泛型的实现原理" class="headerlink" title="六：泛型的实现原理"></a>六：泛型的实现原理</h2><p>泛型本质是将数据类型参数化，它通过擦除的方式来实现，即编译器会在编译期间「擦除」泛型语法并相应的做出一些类型转换动作。</p><p>看一个例子就应该清楚了，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Caculate</span>&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">private</span> T num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们定义了一个泛型类，定义了一个属性成员，该成员的类型是一个泛型类型，这个 T 具体是什么类型，我们也不知道，它只是用于限定类型的。</p><p>反编译一下这个 Caculate 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Caculate</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Caculate</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"><span class="keyword">private</span> Object num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现编译器擦除 Caculate 类后面的两个尖括号，并且将 num 的类型定义为 Object 类型。</p><p>那么是不是所有的泛型类型都以 Object 进行擦除呢？大部分情况下，泛型类型都会以 Object 进行替换，而有一种情况则不是。那就是使用到了extends和super语法的有界类型，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Caculate</span>&lt;T <span class="keyword">extends</span> <span class="title class_">String</span>&gt; &#123;</span><br><span class="line"><span class="keyword">private</span> T num;</span><br><span class="line">&#125;</span><br><span class="line">这种情况的泛型类型，num 会被替换为 String 而不再是 Object。</span><br></pre></td></tr></table></figure><p>这是一个类型限定的语法，它限定 T 是 String 或者 String 的子类，也就是你构建 Caculate 实例的时候只能限定 T 为 String 或者 String 的子类，所以无论你限定 T 为什么类型，String 都是父类，不会出现类型不匹配的问题，于是可以使用 String 进行类型擦除。</p><p>实际上编译器会正常的将使用泛型的地方编译并进行类型擦除，然后返回实例。但是除此之外的是，如果构建泛型实例时使用了泛型语法，那么编译器将标记该实例并关注该实例后续所有方法的调用，每次调用前都进行安全检查，非指定类型的方法都不能调用成功。</p><p>实际上编译器不仅关注一个泛型方法的调用，它还会为某些返回值为限定的泛型类型的方法进行强制类型转换，由于类型擦除，返回值为泛型类型的方法都会擦除成 Object 类型，当这些方法被调用后，编译器会额外插入一行 checkcast 指令用于强制类型转换，这一个过程就叫做『泛型翻译』。</p><p>参考地址：<a href="https://blog.csdn.net/ChenRui_yz/article/details/122935621?ops_request_misc=%7B%22request_id%22:%22168275874316800180688175%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168275874316800180688175&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-122935621-null-null.142%5Ev86%5Einsert_down1,239%5Ev2%5Einsert_chatgpt&utm_term=Java%E6%B3%9B%E5%9E%8B&spm=1018.2226.3001.4187"> Java泛型详解，史上最全图文详解_mikechen的互联网架构的博客-CSDN博客</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;泛型在java中有很重要的地位，无论是开源框架还是JDK源码都能看到它。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;毫不夸张的说，泛型是通用设计上必不可少的元素，所以真正理解与正确使用泛型，是一门必修课。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;一：泛型的本</summary>
      
    
    
    
    <category term="Java基础" scheme="https://wx51815.github.io/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Java" scheme="https://wx51815.github.io/tags/Java/"/>
    
    <category term="泛型" scheme="https://wx51815.github.io/tags/%E6%B3%9B%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>git的使用</title>
    <link href="https://wx51815.github.io/page/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/git%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://wx51815.github.io/page/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/git%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2023-05-09T07:25:02.000Z</published>
    <updated>2023-06-10T07:50:13.030Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本篇文章的环境是在Debian&#x2F;Linux环境下编写。</p><p>在日常工作中git少不了，所以编写本篇文章教大家如何使用git，便于日后工作与学习。</p><p>同时本篇文章也积累了很多博主在工作开发中包括自己日常开发中都用到的一些git技巧，在本文的最后整理了一份关于git的常用命令表。</p><p>git命令很多，但是常用的只有十多个。</p><p>编写不易，喜欢可以关注点赞三连，谢谢！</p><h2 id="发展过程"><a href="#发展过程" class="headerlink" title="发展过程"></a>发展过程</h2><p>Git最初是由Linux开发者Linus用了仅仅两周时间纯C语言编写而成，在编写完成之后就立马上手接管Linux源代码，不过在此之前Linux是由BitMover公司开发的BitKeeper分布式版本控制系统所管理源代码，它是商业收费的分布式版本控制器，但BitMover公司看中Linux开源精神，免费授权给Linux社区使用，在2002年时，Linux开始使用BitKeeper分布式版本控制系统管理源代码，但好景不长，有一天Linux社区成员Andrew（samba（局域网共享文件c&#x2F;s程序）的作者）试图破解BitKeeper共享给所有人使用，被BitMover公司发现并收回了免费使用的版权，随后Linus就用了两周时间开发出了git(两周时间包括测试)，也就是目前为止最好用的分布式版本控制系统。</p><p>大名鼎鼎的github用的就是git系统来管理它们的网站，这里需要区分一下，github和git是两个东西，github是一个社区，git是一个服务系统，github只支持git分布式系统，所以故名成为github。</p><h2 id="集中式与分布式的区别"><a href="#集中式与分布式的区别" class="headerlink" title="集中式与分布式的区别"></a>集中式与分布式的区别</h2><p>除了git还有svn、cvs这样的版本控制系统，它们的区别在于一个是分布式一个是集中式</p><p>集中式就是svn和csv这样的版本控制系统，分布式是git</p><p>区别在于集中式的版本控制系统每次在写代码时都需要从服务器中拉取一份下来，并且如果服务器丢失了，那么所有的就都丢失了，你本机客户端仅保存当前的版本信息，换句话说，集中式就是把代码放在一个服务器上集中管理，你的所有回滚等操作都需要服务器的支持。</p><p>分布式的区别在于，每个人的电脑都是服务器，当你从主仓库拉取一份代码下来后，你的电脑就是服务器，无需担心主仓库被删或者找不到的情况，你可以自由在本地回滚，提交，当你想把自己的代码提交到主仓库时，只需要合并推送到主仓库就可以了，同时你可以把自己的代码新建一份仓库分享给其它人。</p><p>像集中式它们都有一个主版本号，所有的版本迭代都以这个版本号为主，而分布式因为每个客户端都是服务器，git没有固定的版本号，但是有一个由哈希算法算出的id，用来回滚用的，同时也有一个master仓库，这个仓库是一切分支仓库的主仓库，我们可以推送提交到master并合并到主仓库上，主仓库的版本号会迭代一次，我们客户端上的git版本号无论迭代多少次，都跟master无关，只有合并时，master才会迭代一次。</p><h2 id="Debian-x2F-Linux安装Git"><a href="#Debian-x2F-Linux安装Git" class="headerlink" title="Debian&#x2F;Linux安装Git"></a>Debian&#x2F;Linux安装Git</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install git</span><br></pre></td></tr></table></figure><p>如果找不到使用search命令检索一下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt search git</span><br></pre></td></tr></table></figure><h2 id="配置git环境：git-config-–global"><a href="#配置git环境：git-config-–global" class="headerlink" title="配置git环境：git config –global"></a>配置git环境：git config –global</h2><p>参数讲解：</p><blockquote><p>config：参数是用来配置git环境的</p><p>--global：长命令表示配置整个git环境</p></blockquote><p>初次使用git需要设置你的用户名以及邮箱，这将作为当前机器git的标识，如果你用它来下载远程仓库一些需要登录权限的仓库会要求登录，git默认使用配置邮箱以及用户名登入，但会要求你手动输入密码</p><p>用户名配置</p><blockquote><p>user代表用户，.name代表配置用户的名称</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;你的用户名&quot;</span></span><br></pre></td></tr></table></figure><p>邮箱配置</p><blockquote><p>user代表用户，.email代表配置用户的邮箱</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.email <span class="string">&quot;你的邮箱&quot;</span></span><br></pre></td></tr></table></figure><p>不配置也行，当遇到要求登录权限的远程仓库会让你在手动输入用户名、邮箱、以及密码</p><h2 id="创建本地空仓库：git-init"><a href="#创建本地空仓库：git-init" class="headerlink" title="创建本地空仓库：git init"></a>创建本地空仓库：git init</h2><blockquote><p>init：初始化当前目录为仓库，初始化后会自动将当前仓库设置为master</p></blockquote><p>创建本地仓库的条件是需要一个空目录，然后在空目录中初始化你的项目</p><p>如我想创建一个名为“test”的空项目</p><p>1.创建目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>2.进入目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>3.使用git init初始化当前仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><p><img src="/./../images/git%E7%9A%84%E4%BD%BF%E7%94%A8/20201229120401474.png"></p><p>初始化后会生成git的配置文件目录，普通的”ls”命令是看不到的，我们需要使用ls -ah查看隐藏目录</p><p><img src="/./../images/git%E7%9A%84%E4%BD%BF%E7%94%A8/20201229120449115.png"></p><p>进入目录后可以看到它的相关配置文件</p><p><img src="/./../images/git%E7%9A%84%E4%BD%BF%E7%94%A8/20201229120528503.png"></p><h2 id="新建文件添加到本地仓库：git-add、git-commit-m"><a href="#新建文件添加到本地仓库：git-add、git-commit-m" class="headerlink" title="新建文件添加到本地仓库：git add、git commit -m"></a>新建文件添加到本地仓库：git add、git commit -m</h2><blockquote><p>add：将文件添加到缓存区</p><p>commit：提交到本地仓库</p></blockquote><p>用我刚刚上一节所创建的空仓库test为例，我们用touch命令新建一个文件，名为test.c</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">touch</span> test.c</span><br></pre></td></tr></table></figure><p><img src="/./../images/git%E7%9A%84%E4%BD%BF%E7%94%A8/20201229120818287.png"></p><p>使用git add命令将文件添加到本地仓库的提交缓存</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add test.c </span><br></pre></td></tr></table></figure><p>这个时候还不算添加到了本地仓库，我们还需要使用git commit命令为其添加修改的描述信息</p><p>注意在使用git commit时我们只需要简单描述一下我们做了什么，不要像写注释那样写一大堆，不然将来在回滚代码或者查看历史版本时，很难审阅。</p><p>我们需要使用-m命令来简写描述我们的信息，如果不使用-m，会调用终端的注释编辑器让你输入描述信息，但是不建议使用，因为注释编辑器比较难用，不舒服。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">&quot;add new file \&quot;test.c\&quot;&quot;</span></span><br></pre></td></tr></table></figure><p>git commit 会为我们生成40位的哈希值，用于作为id，并把刚刚用git add添加到提交缓存区里的文件提交到本地仓库中，便于我们回滚，至此，这个文件就已经添加到本地仓库中了，同时本地仓库也迭代了一个版本。</p><h2 id="改写提交：git-commit-–amend"><a href="#改写提交：git-commit-–amend" class="headerlink" title="改写提交：git commit –amend"></a>改写提交：git commit –amend</h2><blockquote><p>--amend：重写上一次的提交信息</p></blockquote><p>就像刚刚的列子里一样，我们提交了仓库，但是发现注释写错了，我们可以使用 –amend长命令选项来改写提交</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend</span><br></pre></td></tr></table></figure><p>输入上面的命令后会进入如下编辑器界面：</p><p><img src="/./../images/git%E7%9A%84%E4%BD%BF%E7%94%A8/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JqYnpfY3h5,size_16,color_FFFFFF,t_70.png"></p><p>我们输入Y选中是</p><p>可以看到刚刚的注释信息</p><p><img src="/./../images/git%E7%9A%84%E4%BD%BF%E7%94%A8/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JqYnpfY3h5,size_16,color_FFFFFF,t_70-1683254816223-1.png"></p><p>在界面中按下“i”即可进入编辑界面</p><p><img src="/./../images/git%E7%9A%84%E4%BD%BF%E7%94%A8/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JqYnpfY3h5,size_16,color_FFFFFF,t_70-1683254816223-2.png"></p><p>修改完成后按下ctrl+o键</p><p><img src="/./../images/git%E7%9A%84%E4%BD%BF%E7%94%A8/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JqYnpfY3h5,size_16,color_FFFFFF,t_70-1683254816224-3.png"></p><p>在按下回车，就会提示已写入，用#是注释，不会被提交，git会自动过滤</p><p><img src="/./../images/git%E7%9A%84%E4%BD%BF%E7%94%A8/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JqYnpfY3h5,size_16,color_FFFFFF,t_70-1683254816224-4.png"></p><p>下面的^G和^O这种符号^在ascii里对应ctrl键，所以就是ctrl+x</p><p><img src="/./../images/git%E7%9A%84%E4%BD%BF%E7%94%A8/20201229123400641.png"></p><p>按下ctrl+x(不分大小写)即可退出编辑界面</p><h2 id="查看历史提交日志：git-log"><a href="#查看历史提交日志：git-log" class="headerlink" title="查看历史提交日志：git log"></a>查看历史提交日志：git log</h2><blockquote><p>log：查看日志</p></blockquote><p>正如刚刚改写提交的，想要确定是否改写成功，我们可以使用git log查看一下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span></span><br></pre></td></tr></table></figure><p><img src="/./../images/git%E7%9A%84%E4%BD%BF%E7%94%A8/2020122912354456.png"></p><p>可以看到没有生成新的版本号，而是直接改写了刚刚提交的注释</p><p>这里来解释一下上面提交的信息是什么意思</p><p>第一行的commit是哈希算法算出的id，正如一开始所说，分布式是没有一个主版本号的，它们都是用id来做标志的，同时用master作为主仓库，其它的分支怎么迭代都不会影响到master，后面我会介绍如何使用分支</p><p>目前我们的仓库就是master，因为我们没有拉取分支是直接用git init创建的，就是master。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">commit b9e3a0d708ee5a81ea5ff383c6dabe716eec8cf1 (HEAD -&gt; master)</span><br></pre></td></tr></table></figure><p>后面的head是指向的意思，表示这次提交到哪儿，head-&gt;master代表这次提交到master主仓库，如果是head-&gt;分支仓库则代表提交到分支仓库</p><p>Author是提交者是谁的意思，显示格式是：用户名 &lt;邮箱&gt;</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Author: StephenZhou &lt;stephenzhou@StephenZhou.www.malloc.pro&gt;</span><br></pre></td></tr></table></figure><p>Date的意思是提交时间，后面的+0800这个是格林尼治时间，代表当前是以哪儿的时间地作为基准，这是世界时间，用它来作为基数与当前所在地时差进行计算，包括地球自转等公式。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Date:   Tue Dec 29 12:15:13 2020 +0800</span><br></pre></td></tr></table></figure><p>最下面的就是注释了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span> add new file <span class="string">&quot;test.c&quot;</span></span><br></pre></td></tr></table></figure><h2 id="回滚代码仓库：git-reset-–hard"><a href="#回滚代码仓库：git-reset-–hard" class="headerlink" title="回滚代码仓库：git reset –hard"></a>回滚代码仓库：git reset –hard</h2><p>reset参数是重置命令</p><p>--hard是重置代码仓库版本</p><p>有三种模式</p><p><code>--soft</code> 、<code>--mixed</code>以及<code>--hard</code>是三个恢复等级。</p><ul><li>使用<code>--soft</code>就仅仅将头指针恢复，已经add的暂存区以及工作空间的所有东西都不变。</li><li>如果使用<code>--mixed</code>，就将头恢复掉，已经add的暂存区也会丢失掉，工作空间的代码什么的是不变的。</li><li>如果使用<code>--hard</code>，那么一切就全都恢复了，头变，aad的暂存区消失，代码什么的也恢复到以前状态。</li></ul><p>1.回滚到指定历史版本</p><p>先使用git log查看历史版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span></span><br></pre></td></tr></table></figure><p>在使用git reset –hard命令回滚</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard 要回滚<span class="built_in">id</span></span><br></pre></td></tr></table></figure><p>示列：</p><p>使用git log回滚</p><p>第一行的commit后面的字符串就是我们的哈希id</p><p><img src="/./../images/git%E7%9A%84%E4%BD%BF%E7%94%A8/20201229124822787.png"></p><p>回滚的时候我们只需要字符，其它的都不需要！</p><p><img src="/./../images/git%E7%9A%84%E4%BD%BF%E7%94%A8/20201229124941393.png"></p><p>2.回滚当前仓库指向的版本</p><p>上面我们说过，HEAD是指向当前仓库的，历史版本中可能有别的分支，我们只想迭代我们仓库的上一个版本，这个很简单，我们只需要用HEAD来指向就可以了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD^</span><br></pre></td></tr></table></figure><p>^代表上一个版本的意思，HEAD代表当前仓库的指向，当前HEAD指向master，就代表回滚到master上一次提交的版本</p><p>当然我们也可以使用另外一种方式来回滚到当前仓库的指定版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD~3</span><br></pre></td></tr></table></figure><p>后面的~3，代表以当前版本为基数，回滚多少次。HEAD~3代表回滚master前三个版本</p><p>如果觉得log打印内容过多，可以加上–pretty&#x3D;oneline选项简洁输出</p><p><img src="/./../images/git%E7%9A%84%E4%BD%BF%E7%94%A8/20210101003411898.png"></p><h2 id="查看提交之后文件是否做了改动：git-status"><a href="#查看提交之后文件是否做了改动：git-status" class="headerlink" title="查看提交之后文件是否做了改动：git status"></a>查看提交之后文件是否做了改动：git status</h2><blockquote><p>status：查看当前仓库状态</p></blockquote><p>我们在提交完成之后，有时候可能自己不小心改动了某个文件，或者别人，我们可以使用git status查看文件是否被改动</p><p>我们修改一下刚刚提交的test.c文件，在里面随便输点字符</p><p><img src="/./../images/git%E7%9A%84%E4%BD%BF%E7%94%A8/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JqYnpfY3h5,size_16,color_FFFFFF,t_70-1683254816226-5.png"></p><p>保存退出，然后使用git status查看</p><p><img src="/./../images/git%E7%9A%84%E4%BD%BF%E7%94%A8/20201229125744948.png"></p><p>可以看到报出了修改，这里我的环境语言是中文，如果是英文则对应的修改是AM，A是未修改</p><p>如果你添加了新文件，git status一样会报出来</p><p>这里我们添加一个新的文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">touch</span> min.c</span><br></pre></td></tr></table></figure><p>然后使用status查看一下</p><p><img src="/./../images/git%E7%9A%84%E4%BD%BF%E7%94%A8/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JqYnpfY3h5,size_16,color_FFFFFF,t_70-1683254816226-6.png"></p><p>如果不是中文会在后面写一个Untracked代表未提交</p><p>我们使用git add提交到缓存区文件后，使用git status也可以查看到当前文件的状态</p><p><img src="/./../images/git%E7%9A%84%E4%BD%BF%E7%94%A8/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JqYnpfY3h5,size_16,color_FFFFFF,t_70-1683254816226-7.png"></p><p>对应的英文是：modified</p><p>英文对应：</p><p>A：未修改</p><p>AM：修改</p><p>Untracked：未提交</p><p>modified：新文件，但未提交</p><p>如果提交了的文件，且没有改动的，不会显示到这个里面</p><h2 id="工作区与缓存区"><a href="#工作区与缓存区" class="headerlink" title="工作区与缓存区"></a>工作区与缓存区</h2><p>在git下有一个概念是缓存区，这是其它集中式版本控制系统没有的</p><p>工作区：工作区就是你当前的工作目录</p><p>缓存区：这里存放了你使用git add命令提交的文件描述信息，它位于.git目录下的index文件中</p><p><img src="/./../images/git%E7%9A%84%E4%BD%BF%E7%94%A8/20201229130440998.png"></p><p>有的低版本中叫stage</p><p>这些文件中存储了我们一些提交的缓存数据，git会解析它们，HEAD文件就是指向当前的仓库</p><p>最后使用git commit提交时git会提交到当前仓库中，当前的工作区也就成为了最新一次提交的仓库版本。</p><h2 id="修改缓存区内容：git-add、git-commit-m"><a href="#修改缓存区内容：git-add、git-commit-m" class="headerlink" title="修改缓存区内容：git add、git commit -m"></a>修改缓存区内容：git add、git commit -m</h2><p>比如我们使用git add添加了一个名为min.c的文件，但是还没有提交的时候我们修改了它的内容，修改完成之后在提交会发现内容并不是我们第二次修改的内容</p><p>这就要说一点，当我们使用git add添加到缓存区的内容后，我们在修改这个文件时，它跟缓冲区内容是没有任何关系的！我们使用git commit提交的时，它只会提交缓存区内容</p><p>如果想提交第二次修改，我们只需要在git add一次，然后在使用git commit提交就可以了，git会自动帮我们合并提交</p><p>示列：</p><p>1.将文件添加到缓存区中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add min.c</span><br></pre></td></tr></table></figure><p>2.修改文件内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim min.c</span><br><span class="line">xxxx</span><br><span class="line">:wq</span><br></pre></td></tr></table></figure><p>3.在此添加到缓存区</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add min.c</span><br></pre></td></tr></table></figure><p>4.提交</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">&quot;add min.c&quot;</span></span><br></pre></td></tr></table></figure><h2 id="将改动文件添加到缓存区：git-add"><a href="#将改动文件添加到缓存区：git-add" class="headerlink" title="将改动文件添加到缓存区：git add"></a>将改动文件添加到缓存区：git add</h2><p>平时我们可能写代码的时候不可能保证只改动了一个文件，我们切来切去最后都不知道自己改了哪些文件，为了保证所有的文件都能被准确提交，我们可以使用git add我们确定修改的文件，当git add后在使用status查看一下状态，看看是否有遗漏没有提交的文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add min.c </span><br></pre></td></tr></table></figure><p>在使用git status查看是否有没有添加的：</p><p><img src="/./../images/git%E7%9A%84%E4%BD%BF%E7%94%A8/20201229131825962.png"></p><p>可以看到test.c没有提交，在使用git add将test.c添加进来就可以了</p><h2 id="将所有改动文件添加到缓存区：git-add-–all、git-add"><a href="#将所有改动文件添加到缓存区：git-add-–all、git-add" class="headerlink" title="将所有改动文件添加到缓存区：git add –all、git add ."></a>将所有改动文件添加到缓存区：git add –all、git add .</h2><p>如果你实在不确信哪些文件是改动过的，你只需要使用git add –all</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add --all</span><br></pre></td></tr></table></figure><p>这个命令会将当前目录下包括子目录下所有改动的文件提交到暂存区，注意只包括改动的文件，不改动的不会放到缓存区。</p><p>这个命令还会把删除的文件也提交进去</p><p>如你在本地删除了min.c 这个命令会把删除信息也记录进去，然后在提交的时候把仓库里对应的min.c也删除掉，也就是说你在本地做的删除操作会被记录，提交仓库时会删除同样的文件，如果不想删除文件，可以使用git add .，注意后面有一个“.”点的符号，这个命令跟git add –all一样，但是不会记录删除操作。</p><p>最后别忘记使用git commit提交到仓库中</p><h2 id="将文件撤销回到最近一次修改的状态：git-checkout-–-file"><a href="#将文件撤销回到最近一次修改的状态：git-checkout-–-file" class="headerlink" title="将文件撤销回到最近一次修改的状态：git checkout – file"></a>将文件撤销回到最近一次修改的状态：git checkout – file</h2><blockquote><p>checkout：切换参数，通常用来切换分支仓库</p></blockquote><p>当我们在工作中修改了一个文件，猛然间发现内容好像改的不对，想重新修改，这个时又不知道自己改了什么代码，想撤销修改，有一个最简单的方法，就是git checkout – file，注意中间要有“–”，checkout这个命令是切换分支的功能，关于它我们后面在细说，你现在只需要知道这个命令加上“–”可以用来将文件切换到最近一次的状态</p><p>注意这个恢复只能恢复到上一次提交的状态，如你刚提交了这个文件到仓库，随后你修改了它，那么使用这个命令只会回到刚刚提交后的那个状态里，不能回到你还没有提交，但修改的状态中。</p><p>下面这个演示，我将min.c文件修改了，并使用git checkout – file回到了之前修改的状态</p><p><img src="/./../images/git%E7%9A%84%E4%BD%BF%E7%94%A8/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JqYnpfY3h5,size_16,color_FFFFFF,t_70-1683254816227-8.png"></p><p>注意这个功能不能一直迭代恢复，如你恢复到了修改前的版本，你想再次回滚回滚到修改前在之前的版本是不行的。</p><h2 id="查看单个文件可回滚版本：git-log-filename"><a href="#查看单个文件可回滚版本：git-log-filename" class="headerlink" title="查看单个文件可回滚版本：git log filename"></a>查看单个文件可回滚版本：git log filename</h2><p>当我们想回滚指定文件到指定版本时，需要查看该文件有多少个版本可以回滚时，可以使用git log filename命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> test.c</span><br></pre></td></tr></table></figure><p><img src="/./../images/git%E7%9A%84%E4%BD%BF%E7%94%A8/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JqYnpfY3h5,size_16,color_FFFFFF,t_70-1683254816227-9.png"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> min.c</span><br></pre></td></tr></table></figure><p><img src="/./../images/git%E7%9A%84%E4%BD%BF%E7%94%A8/20201229143532632.png"></p><p>可以看到min.c文件可回滚版本较少，因为它是后来添加进来的。</p><p>在使用git reset命令将其回滚就可用了，命令格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset 1a1e91bf37add6c3914ebf20428efc0a7cea33f3 min.c</span><br></pre></td></tr></table></figure><p>回退完成之后想要再次提交可以使用git add和git commit提交到本地仓库中，即可更新当前工作环境，让当前文件保持最新。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add min.c</span><br><span class="line">git commit -m <span class="string">&quot;new&quot;</span></span><br></pre></td></tr></table></figure><p>更新完成后可以在使用log查看一下，会发现多出一个历史版本</p><p><img src="/./../images/git%E7%9A%84%E4%BD%BF%E7%94%A8/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JqYnpfY3h5,size_16,color_FFFFFF,t_70-1683254816227-10.png"></p><p>即便你更新了一个文件，也会生成一个新的历史版本，注意历史版本里只包含了你更新的文件，你刚刚只add了min.c文件，所以新的历史版本里只有更新min.c文件，你当前的工作其它文件没有在这个历史版本里。</p><h2 id="删除文件：git-rm"><a href="#删除文件：git-rm" class="headerlink" title="删除文件：git rm"></a>删除文件：git rm</h2><p>如果我们使用普通的命令，rm删除文件，git状态会提示你删除了文件，你只需要使用add重新提交一次就可以了。</p><p><img src="/./../images/git%E7%9A%84%E4%BD%BF%E7%94%A8/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JqYnpfY3h5,size_16,color_FFFFFF,t_70-1683254816228-11.png"></p><p>当然你也可以使用git rm删除文件，但是也需要使用git commit提交一次</p><p><img src="/./../images/git%E7%9A%84%E4%BD%BF%E7%94%A8/20210101011026931.png"></p><p>可以看下status的状态</p><p><img src="/./../images/git%E7%9A%84%E4%BD%BF%E7%94%A8/20210101011057428.png"></p><h2 id="查看提交历史：git-reflog"><a href="#查看提交历史：git-reflog" class="headerlink" title="查看提交历史：git reflog"></a>查看提交历史：git reflog</h2><p>git reflog可以查看当前版本库的提交历史，凡是对仓库版本进行迭代的都会出现在这个里面，包括你回滚版本都会出现在这个历史中</p><p><img src="/./../images/git%E7%9A%84%E4%BD%BF%E7%94%A8/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JqYnpfY3h5,size_16,color_FFFFFF,t_70-1683254816228-12.png"></p><h2 id="git基本组成框架：Workspace、Index-x2F-Stage、Repository、Remote"><a href="#git基本组成框架：Workspace、Index-x2F-Stage、Repository、Remote" class="headerlink" title="git基本组成框架：Workspace、Index &#x2F; Stage、Repository、Remote"></a>git基本组成框架：Workspace、Index &#x2F; Stage、Repository、Remote</h2><blockquote><ul><li>Workspace：开发者工作区</li><li>Index &#x2F; Stage：暂存区&#x2F;缓存区</li><li>Repository：仓库区（或本地仓库）</li><li>Remote：远程仓库</li></ul></blockquote><p>Workspace：开发者工作区，也就是你当前写代码的目录，它一般保持的是最新仓库代码。</p><p>Index &#x2F; Stage：缓存区，最早叫Stage，现在新版本已经改成index，位于.git目录中，它用来存放临时动作，比如我们做了git add或者git rm，都是把文件提交到缓存区，这是可以撤销的，然后在通过git commit将缓存区的内容提交到本地仓库</p><p>Repository：仓库区，是仓库代码，你所有的提交都在这里，git会保存好每一个历史版本，存放在仓库区，它可以是服务端的也可以是本地的，因为在分布式中，任何人都可以是主仓库。</p><p>Remote：远程仓库，只能是别的电脑上的仓库，即服务器仓库。</p><h2 id="git-rm后恢复文件：git-rm、git-reset、git-checkout"><a href="#git-rm后恢复文件：git-rm、git-reset、git-checkout" class="headerlink" title="git rm后恢复文件：git rm、git reset、git checkout"></a>git rm后恢复文件：git rm、git reset、git checkout</h2><p>此方法仅限git rm，因为git rm会先将文件放入缓存区,且没有使用commit提交的情况下</p><p>首先使用git rm删除一个文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">rm</span> d.c</span><br></pre></td></tr></table></figure><p>在使用git reset重置所有缓存区操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset</span><br></pre></td></tr></table></figure><p>重置完成之后在使用git checkout命令将文件取消操作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout d.c</span><br></pre></td></tr></table></figure><p><img src="/./../images/git%E7%9A%84%E4%BD%BF%E7%94%A8/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JqYnpfY3h5,size_16,color_FFFFFF,t_70-1683254816229-13.png"></p><p>可以看到文件又恢复了</p><p>如果已经提交了想恢复怎么办？</p><p>这里给一个方法，就是把当前目录全部提交一次，这样做是为了防止我们等下回滚的时候导致一些修改的文件被替换掉了，然后我们回滚到有那个文件的版本，将那个文件copy到别的文件目录，这个文件目录要是你记得的，然后在回滚到最新版本代码，在将那个文件copy回来，在提交进去。</p><h2 id="git创建分支：git-branch、git-checkout"><a href="#git创建分支：git-branch、git-checkout" class="headerlink" title="git创建分支：git branch、git checkout"></a>git创建分支：git branch、git checkout</h2><p>使用git checkout -b参数来创建一个分支，创建完成分支后会自动切换过去</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b dev</span><br></pre></td></tr></table></figure><p>然后我们在使用branch来查看当前属于哪个分支，也就是查看HEAD的指向</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure><p><img src="/./../images/git%E7%9A%84%E4%BD%BF%E7%94%A8/20210101123559753.png"></p><p>git checkout -b等价于</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch dev</span><br><span class="line">git checkout dev</span><br></pre></td></tr></table></figure><p>git branch 如果后面跟着名字则会创建分支，但不会切换</p><p>git checkout 后面如果是分支名称则切换过去</p><h2 id="git切换分支：git-checkout"><a href="#git切换分支：git-checkout" class="headerlink" title="git切换分支：git checkout"></a>git切换分支：git checkout</h2><p>当我们想切换分支可以使用git checkout来切换，如刚刚我们创建了一个分支dev并切换了过去，现在切换回masterk</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br></pre></td></tr></table></figure><p><img src="/./../images/git%E7%9A%84%E4%BD%BF%E7%94%A8/20210101124051184.png"></p><p>git checkout的作用是检出，如果是文件的话，会放弃对文件的缓存区操作，但是要使用reset重置一下变更才行。</p><p>如果是分支的话会切换过去。</p><h2 id="git合并分支：git-merge"><a href="#git合并分支：git-merge" class="headerlink" title="git合并分支：git merge"></a>git合并分支：git merge</h2><p>当我们新建分支并做完工作之后，想要把分支提交至master，只需要切换到master仓库，并执行git merge 分支名就可以了</p><p>如我们在分支中新建了一个f.c和test.c的文件</p><p>然后在使用git checkout master切换到master</p><p>在使用git merge dev将其合并</p><p><img src="/./../images/git%E7%9A%84%E4%BD%BF%E7%94%A8/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JqYnpfY3h5,size_16,color_FFFFFF,t_70-1683254816229-14.png"></p><p>这里需要说一点，如果你在任何分支下创建文件，没有提交到仓库，那么它在所有仓库都是可见的，比如你在分支dev中创建了一个文件，没有使用git add和git commit提交，此时你切换到master，这个文件依旧存在的，因为你创建的文件在工作目录中，你切换仓库时git只会更新跟仓库有关的文件，无关的文件依然存放在工作区。</p><p>同时我们可以看到历史版本中有分支提交的历史</p><p><img src="/./../images/git%E7%9A%84%E4%BD%BF%E7%94%A8/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JqYnpfY3h5,size_16,color_FFFFFF,t_70-1683254816229-15.png"></p><h2 id="git查看分支：git-branch-a"><a href="#git查看分支：git-branch-a" class="headerlink" title="git查看分支：git branch -a"></a>git查看分支：git branch -a</h2><p>如果要查看当前所有分支可以使用：git branch -a</p><p>HEAD指向当前分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* master</span><br><span class="line">  remotes/origin/HEAD -&gt; origin/master</span><br><span class="line">  remotes/origin/master</span><br></pre></td></tr></table></figure><h2 id="git删除本地分支：git-branch-D"><a href="#git删除本地分支：git-branch-D" class="headerlink" title="git删除本地分支：git branch -D"></a>git删除本地分支：git branch -D</h2><p>git branch -D 分支名</p><h2 id="git删除远程分支：git-push-origin-–delete"><a href="#git删除远程分支：git-push-origin-–delete" class="headerlink" title="git删除远程分支：git push origin –delete"></a>git删除远程分支：git push origin –delete</h2><p>注意这里的远程分支名不需要加origin，输入分支名就可以了</p><p>git push origin –delete 远程分支名</p><h2 id="在开发中git分支的重要性"><a href="#在开发中git分支的重要性" class="headerlink" title="在开发中git分支的重要性"></a>在开发中git分支的重要性</h2><p>当我们在开发中，无论做什么操作都建议使用分支，因为在团队开发中，master只有一个，合作开发里任何人都可以从master里拉取代码，拉取时master后创建分支，分支名改为你要做的操作，比如修改某某文件，修改什么什么bug，单词以下划线做分割，然后在提交一个版本</p><p>分支名必须简洁，和标题一样，提交的commit在简单描述一下就可以了。</p><p>如我们的master中有个bug，是内存泄漏</p><p>我们可以常见一个分支名为Memory_Leak,然后在commit里简单描述一下修复了哪个模块的内存泄漏，不要写修复了什么什么代码，什么什么问题导致的，只需要简单描述一下就可以了。</p><p>一般情况下，我们都是拉取master后，想要修改功能或者添加功能，都是创建分支，在分支里修改不影响master，如果修改错了代码或者误删之类的，在从master上拉取一份就可以了。</p><h2 id="github的使用"><a href="#github的使用" class="headerlink" title="github的使用"></a>github的使用</h2><p>github是一款使用git命令作为基础框架的网站，它是一款开源分享网站，你开源把你的源代码放到github上，然后让人来start给你小星星，小星星越多代表你的项目越具有影响力，很多公司面试如果你有一个很多星星的项目，会大大提升你的录取率。</p><p>你也可以把你的一些项目分享到github上保存，github上是无限制代码的。</p><p>1.首先到github上注册一个你的账号</p><p>2.在本地创建一个ssh的key，因为github是使用ssh服务进行通讯的</p><blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;your_email@example.com&quot;</span><br></pre></td></tr></table></figure></blockquote><p>-t 指定密钥类型，默认是 rsa ，可以省略。<br>-C 设置注释文字，比如邮箱。<br>-f 指定密钥文件存储文件名，一般我们默认，让存储到默认路径以及默认文件名</p><p>它会要求输入Enter file in which to save the key (&#x2F;home&#x2F;stephenzhou&#x2F;.ssh&#x2F;id_rsa)</p><p>这里是生成的sshkey文件名，我们可以回车使用默认文件名</p><p>除此之外还会让你输入</p><p>Created directory ‘&#x2F;home&#x2F;stephenzhou&#x2F;.ssh’.<br>Enter passphrase (empty for no passphrase):<br>这个密码会在让你push提交时候要输入的，除了git登录密码，还要输入这个密码，直接回车则空密码，这里我们直接回车</p><p>接着会让你在此输入密码，验证这里依旧回车</p><p>Enter same passphrase again：</p><p>生成之后你就会看到这样的界面:</p><p><img src="/./../images/git%E7%9A%84%E4%BD%BF%E7%94%A8/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JqYnpfY3h5,size_16,color_FFFFFF,t_70-1683254816230-16.png"></p><p>生成的ssh文件如果不使用-f指定的话会生成在用户目录下的.ssh目录中，.ssh是隐藏文件，可以使用ls -ah看到，使用cd ~进入用户主目录，然后cd进入到.ssh目录中可以看到文件</p><p><img src="/./../images/git%E7%9A%84%E4%BD%BF%E7%94%A8/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JqYnpfY3h5,size_16,color_FFFFFF,t_70-1683254816230-17.png"></p><p>id_rsa是私匙，id_rsa.pub是公匙，id_rsa不能告诉任何人，只有公钥可以，ssh采用的是非对称加密。</p><p>接着在github上添加你的公钥</p><p><img src="/./../images/git%E7%9A%84%E4%BD%BF%E7%94%A8/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JqYnpfY3h5,size_16,color_FFFFFF,t_70-1683254816230-18.png"></p><p><img src="/./../images/git%E7%9A%84%E4%BD%BF%E7%94%A8/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JqYnpfY3h5,size_16,color_FFFFFF,t_70-1683254816230-19.png"></p><p>最后在输入你的登录密码就可以了</p><p><img src="/./../images/git%E7%9A%84%E4%BD%BF%E7%94%A8/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JqYnpfY3h5,size_16,color_FFFFFF,t_70-1683254816230-20.png"></p><p>这样ssh就添加成功了~</p><p><img src="/./../images/git%E7%9A%84%E4%BD%BF%E7%94%A8/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JqYnpfY3h5,size_16,color_FFFFFF,t_70-1683254816231-21.png"></p><p>你可以添加如很多个ssh，比如你有多台电脑，在每个电脑上都配置ssh然后添加进来就可以了，git需要这个是要确定你是主人，确定是主人的机器推送的才可以推送到仓库中，但是你可以创建公开仓库，别人只能拉取不能推送到这个仓库中，你可以给其它人权限。</p><p>找到你要开放的仓库，选择Manage access然后使用invite a cikkaborator添加成员就可以了。</p><p><img src="/./../images/git%E7%9A%84%E4%BD%BF%E7%94%A8/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzA2MjY2,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"></p><h2 id="github上创建仓库"><a href="#github上创建仓库" class="headerlink" title="github上创建仓库"></a>github上创建仓库</h2><p>我们可以在github上创建一个仓库</p><p><img src="/./../images/git%E7%9A%84%E4%BD%BF%E7%94%A8/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JqYnpfY3h5,size_16,color_FFFFFF,t_70-1683254816231-22.png"></p><p>创建时记得选上readme文件，因为这个文件是github上的md文件，用来显示项目简介的，建议选上，日后我会教大家如何去写md文件，或者可以去使用一些在线的md文件生成网站也可以。</p><p><img src="/./../images/git%E7%9A%84%E4%BD%BF%E7%94%A8/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JqYnpfY3h5,size_16,color_FFFFFF,t_70-1683254816231-23.png"></p><p>创建完成之后就是这个样子的</p><p><img src="/./../images/git%E7%9A%84%E4%BD%BF%E7%94%A8/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JqYnpfY3h5,size_16,color_FFFFFF,t_70-1683254816231-24.png"></p><p>什么也没有，只有一个readme文件</p><h2 id="github将本地仓库关联到远程仓库：git-remote-add-origin"><a href="#github将本地仓库关联到远程仓库：git-remote-add-origin" class="headerlink" title="github将本地仓库关联到远程仓库：git remote add origin"></a>github将本地仓库关联到远程仓库：git remote add origin</h2><p>我们本地有一个仓库，我们想把它推送到远程上去，很简单，我们只需要使用git remote add origin命令就可以了，ongin是github上的仓库名称，意思是远程仓库的意思。</p><p>首先选择仓库的code找到github生成的远程仓库链接</p><p><img src="/./../images/git%E7%9A%84%E4%BD%BF%E7%94%A8/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JqYnpfY3h5,size_16,color_FFFFFF,t_70-1683254816231-25.png"></p><p>然后关联</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@github.com:beiszhihao/test.git</span><br></pre></td></tr></table></figure><p>然后使用git push推送到远程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><p><img src="/./../images/git%E7%9A%84%E4%BD%BF%E7%94%A8/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JqYnpfY3h5,size_16,color_FFFFFF,t_70-1683254816232-26.png"></p><p>这里我来解释一下</p><blockquote><p>push：将本地仓库与远程仓库合并</p><p>-u：将本地仓库分支与远程仓库分支一起合并，就是说将master的分支也提交上去，这样你就可以在远程仓库上看到你在本地仓库的master中创建了多少分支，不加这个参数只将当前的master与远程的合并，没有分支的历史记录，也不能切换分支</p><p>origin：远程仓库的意思，如果这个仓库是远程的那么必须使用这个选项</p><p>master：提交本地matser分支仓库</p></blockquote><p>注意第一次提交ssh会让你验证是否来自github</p><p>The authenticity of host ‘github.com (13.229.188.59)’ can’t be established.<br>RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8.<br>Are you sure you want to continue connecting (yes&#x2F;no&#x2F;[fingerprint])? yes<br>Warning: Permanently added ‘github.com,13.229.188.59’ (RSA) to the list of known hosts.<br>这里输入yes就可以了</p><p>我们不需要登录，因为github上的ssh列表里有这台机器</p><p>注意第一次的时候加上-u就可以了，因为我们本地其它可能有很多分支也提交上去，以后只提交最新代码就可以了git push origin master，不需要在提交其它分支</p><p><img src="/./../images/git%E7%9A%84%E4%BD%BF%E7%94%A8/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JqYnpfY3h5,size_16,color_FFFFFF,t_70-1683254816232-27.png"></p><p>这个时候你可以在github上看到有提交记录</p><p><img src="/./../images/git%E7%9A%84%E4%BD%BF%E7%94%A8/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JqYnpfY3h5,size_16,color_FFFFFF,t_70-1683254816232-28.png"></p><p>但是什么都没有，因为这个分支是main，我们提交的是master</p><p>选中它然后切换到master</p><p><img src="/./../images/git%E7%9A%84%E4%BD%BF%E7%94%A8/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JqYnpfY3h5,size_16,color_FFFFFF,t_70-1683254816232-29.png"></p><p>默认是没有master的，这是我们新添加的分支</p><p><img src="/./../images/git%E7%9A%84%E4%BD%BF%E7%94%A8/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JqYnpfY3h5,size_16,color_FFFFFF,t_70-1683254816233-30.png"></p><p>看到有文件了。</p><p>github上已经默认是main作为主仓库了，这个原因是因为种族运动的原因，master也代表主人，类似奴隶制，所以github已经替换默认master为main</p><h2 id="git将远程仓库关联到本地和拉取指定分支、切换远程分支：git-clone"><a href="#git将远程仓库关联到本地和拉取指定分支、切换远程分支：git-clone" class="headerlink" title="git将远程仓库关联到本地和拉取指定分支、切换远程分支：git clone"></a>git将远程仓库关联到本地和拉取指定分支、切换远程分支：git clone</h2><p>当我们远程有仓库时，想要关联到本地只需要使用git clone就可以了</p><p>新建一个空目录，不要git init</p><p>使用git clone会自动帮我们初始化</p><p><img src="/./../images/git%E7%9A%84%E4%BD%BF%E7%94%A8/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JqYnpfY3h5,size_16,color_FFFFFF,t_70-1683254816233-31.png"></p><p>鉴于刚刚的，我们上传的代码在远程仓库中有一个默认的main和master，由于我们最初上传的分支是master，所以github给我们创建了一个新的分支叫master，并没有关联到mian中，我们拉取时，默认拉取的是main分支</p><p>所以我们可以使用git clone -b分支名 仓库地址来指定分支</p><p><img src="/./../images/git%E7%9A%84%E4%BD%BF%E7%94%A8/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JqYnpfY3h5,size_16,color_FFFFFF,t_70-1683254816233-32.png"></p><h2 id="github提交本地仓库到远程仓库：git-add、git-commit、git-push"><a href="#github提交本地仓库到远程仓库：git-add、git-commit、git-push" class="headerlink" title="github提交本地仓库到远程仓库：git add、git commit、git push"></a>github提交本地仓库到远程仓库：git add、git commit、git push</h2><p>我们修改了master上的分支代码，然后使用git add提交到缓存区，在使用commit提交到本地仓库，在使用push推送到远程就可以了，非常简单，命令都是我们学过的</p><p><img src="/./../images/git%E7%9A%84%E4%BD%BF%E7%94%A8/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JqYnpfY3h5,size_16,color_FFFFFF,t_70-1683254816235-33.png"></p><h2 id="git修改分支名称：git-branch"><a href="#git修改分支名称：git-branch" class="headerlink" title="git修改分支名称：git branch"></a>git修改分支名称：git branch</h2><p>使用-m选项</p><p>git branch -m 分支名 新的分支名</p><h2 id="git保存当前工作切换分支：git-stash"><a href="#git保存当前工作切换分支：git-stash" class="headerlink" title="git保存当前工作切换分支：git stash"></a>git保存当前工作切换分支：git stash</h2><p>在你当前工作区修改了文件或者其它功能时，你想要切换或者创建到其它分区是不可能的，如：</p><p><img src="/./../images/git%E7%9A%84%E4%BD%BF%E7%94%A8/20210101170120107.png"></p><p>我们分支修改了内容，想要切换到其它分区git会终止你这样操作，为的是防止丢失当前工作区内容。</p><p>我们可以使用git stash命令来保存当前工作状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash</span><br></pre></td></tr></table></figure><p>保存工作状态之后可以使用git stash list查看当前存储了多少工作状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash list</span><br></pre></td></tr></table></figure><p>那么此时我们就可以切换到其它分支了</p><p><img src="/./../images/git%E7%9A%84%E4%BD%BF%E7%94%A8/20210101170528706.png"></p><p>当在别的分支做完事情之后，在切换回刚刚的分支，然后在刚刚的分支中将状态恢复</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash pop</span><br></pre></td></tr></table></figure><p><img src="/./../images/git%E7%9A%84%E4%BD%BF%E7%94%A8/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JqYnpfY3h5,size_16,color_FFFFFF,t_70-1683254816235-34.png"></p><p>一般情况下，我们在修改代码时，突然来了一个新的需求，让我们先去做这个需求，但是此时我们正在写的代码还没有完成，是不可以提交的，所以我们先使用git stash保存当前工作状态，在拉取一个分支去这个分支里面干活，干完活之后回到之前的分支，在将工作内容恢复出来继续干活</p><p>git stash pop会将list保存的列表也给删除掉</p><p>git stash apply 不会删除列表里的内容会默认恢复第一个</p><p>如果想恢复指定内容可以使用git stash apply list名称</p><p>git stash drop list名称可以移除指定list</p><p>git stash clear 移除所有lsit</p><p>git stash show 查看栈中最新保存的stash和当前目录的差异。</p><p>注意stash是以栈的方式保存的，先进后出。</p><p>准确来说，这个命令的作用就是为了解决git不提交代码不能切换分支的问题。</p><h2 id="将别的分支修改转移到自己的分支：git-cherry-pick"><a href="#将别的分支修改转移到自己的分支：git-cherry-pick" class="headerlink" title="将别的分支修改转移到自己的分支：git cherry-pick"></a>将别的分支修改转移到自己的分支：git cherry-pick</h2><p>有的时候我们从别的仓库拉取分支下来，是有bug的分支，但是master修复了，我们分支仓库没有修复，但是我们难不成重复master操作去修改这个bug？不不太繁琐了，我们直接使用cherry-pick命令将改动copy到我们分支上就可以了，这个命令只会将master改动代码合并到我们分支上，不会修改我们的代码。</p><p>git会检查master做了哪些修改，然后同步到我们的分支上，此时我们的分支依然是我们自己的代码，且会生成一个版本仓库。</p><p>做这个操作之前建议提交一次，便于恢复。</p><p>使用git cherry-pick 分支名即可合并分支修改，再次之前要保证你仓库代码是提交的，才可以进行这个步骤。</p><p>其次你可以使用git log查看commit 然后使用git cherry-pick也是可以的，合并分支的指定历史版本</p><h2 id="git远程删除分支后本地git-branch-a依然看得到的问题：git-remote"><a href="#git远程删除分支后本地git-branch-a依然看得到的问题：git-remote" class="headerlink" title="git远程删除分支后本地git branch -a依然看得到的问题：git remote"></a>git远程删除分支后本地git branch -a依然看得到的问题：git remote</h2><p>这个问题是因为本地没有更新分支缓存</p><p>可以使用remote命令对远程仓库进行操作</p><p>使用 <code>git remote show origin命令查看远程仓库信息</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote show origin</span><br></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=""></a><img src="/./../images/git%E7%9A%84%E4%BD%BF%E7%94%A8/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JqYnpfY3h5,size_16,color_FFFFFF,t_70-1683254816235-35.png"></h2><p>如果在里面没有看到删除后的分支就代表这个分支在远程已经被删除了。</p><p>使用prune参数刷新本地分支仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote prune origin</span><br></pre></td></tr></table></figure><h2 id="git强制合并分支：–allow-unrelated-histories"><a href="#git强制合并分支：–allow-unrelated-histories" class="headerlink" title="git强制合并分支：–allow-unrelated-histories"></a>git强制合并分支：–allow-unrelated-histories</h2><p>当我们在使用两个不同的分支时或此分支不是从原生仓库中分支出来的，想要合并不符合GIT规则，所以会弹出：fatal: refusing to merge unrelated histories 的错误，比如当我们在本地开发好了，但是并没有在一开始关联远程仓库，若想提交就会出现这样的错误，我们先拉取下来以后合并分支在后面加上这条语句就可以了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge master --allow-unrelated-histories</span><br></pre></td></tr></table></figure><h2 id="-1"><a href="#-1" class="headerlink" title=""></a><img src="/./../images/git%E7%9A%84%E4%BD%BF%E7%94%A8/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JqYnpfY3h5,size_16,color_FFFFFF,t_70-1683254816236-36.png"></h2><h2 id="git拉取远程所有分支：git-fetch"><a href="#git拉取远程所有分支：git-fetch" class="headerlink" title="git拉取远程所有分支：git fetch"></a>git拉取远程所有分支：git fetch</h2><p>当我们在本地进行开发时，有时会发现有些分支看不见</p><p><img src="/./../images/git%E7%9A%84%E4%BD%BF%E7%94%A8/20210625150943249.png"></p><p>可以使用git fetch把远程全部分支拉取下来，同时也包括这些分支的仓库版本，log日志等，这个操作不会进行合并。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch</span><br></pre></td></tr></table></figure><p>拉取后结果如下：</p><p><img src="/./../images/git%E7%9A%84%E4%BD%BF%E7%94%A8/20210625151100522.png"></p><p>也可以拉取指定分支的最新内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch xxxx</span><br></pre></td></tr></table></figure><h2 id="git子模块管理：git-submodule"><a href="#git子模块管理：git-submodule" class="headerlink" title="git子模块管理：git submodule"></a>git子模块管理：git submodule</h2><p>在当我们项目较大的情况下，都会使用模块化编程，把不同的业务功能分割成数个子模块，git也拥有对子模块进行管理的方法，submodule，可以使用它来添加子模块与管理子模块。</p><p>如添加一个子模块：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git submodule add  http://192.168.1.88:7990/scm/wlibold/weye_lib.git</span><br></pre></td></tr></table></figure><p>使用如上命令会添加一个子模块，名为weye_lib的子模块到自己的仓库中，这样我们就可以使用了</p><p>在添加时会添加仓库的最新版本，但是此模块不会自动更新，需要我们手动更新，当子模块的仓库进行了更新，我们需要进到此子模块的文件夹中执行如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git submodule update</span><br></pre></td></tr></table></figure><p>这样就会自动化更新了模块到最新版本。</p><p>若我们想要使用指定版本的子模块也可以使用切换版本命令来完成子模块的版本切换，同时你也可以使用git log命令查看这个子模块的版本提交。</p><p>注意根据git版本不同的原因，你在添加时可能下来的子模块是空项目，这个时候可以使用如下命令：</p><p>首先进入到克隆下来的子模块目录，并执行如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git submodule init</span><br><span class="line">git submodule update</span><br></pre></td></tr></table></figure><p>最新的git在使用add添加子模块时会自动使用这两个命令。</p><p>这两个命令作用分别是初始化子模块仓库，更新远程子模块仓库到本地，最早的git添加子模块只是先在本地生成了映射关系，需要手动执行这两个命令。</p><p>最后别忘记使用git add与git commit提交一次。</p><p>在提醒一下，若你使用的子模块版本是0.17，最新版本是2.13，当别人拉取你仓库时子模块也会是0.17不会变动。</p><h2 id="git分支开发步骤"><a href="#git分支开发步骤" class="headerlink" title="git分支开发步骤"></a>git分支开发步骤</h2><p>一般情况下我们开发都要在不扰乱master代码的情况下进行开发</p><p>1.拉取分支，分支名简明摘要说要干什么，然后干活，在合并到master，合并之后在删除分支，这是基本步骤，不需要留额外分支，分支只是为了将来看代码时方便而已，能看到这个分支是干什么的。</p><h2 id="git强制删除分支：git-branch"><a href="#git强制删除分支：git-branch" class="headerlink" title="git强制删除分支：git branch"></a>git强制删除分支：git branch</h2><p>如果遇到无法删除的分支可以使用git branch -D 大写的D即可。</p><h2 id="git查看不同分支的文件差异：git-diff"><a href="#git查看不同分支的文件差异：git-diff" class="headerlink" title="git查看不同分支的文件差异：git diff"></a>git查看不同分支的文件差异：git diff</h2><p><img src="/./../images/git%E7%9A%84%E4%BD%BF%E7%94%A8/20210101213745449.png"></p><h2 id="git查看仓库信息：git-remote"><a href="#git查看仓库信息：git-remote" class="headerlink" title="git查看仓库信息：git remote"></a>git查看仓库信息：git remote</h2><p>使用git remote可以查看当前仓库名称</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote</span><br></pre></td></tr></table></figure><p>使用remote -v可以查看更详细的权限信息</p><p><img src="/./../images/git%E7%9A%84%E4%BD%BF%E7%94%A8/20210101214252440.png"></p><p>fetch代表可以拉取仓库，push代表可以推送。</p><p>如果没有权限只能拉取的情况下不会显示push。</p><p>git查看日志简洁方法：git log</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --graph --pretty=oneline --abbrev-commit</span><br></pre></td></tr></table></figure><h2 id="-2"><a href="#-2" class="headerlink" title=""></a><img src="/./../images/git%E7%9A%84%E4%BD%BF%E7%94%A8/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JqYnpfY3h5,size_16,color_FFFFFF,t_70-1683254816237-37.png"></h2><p>注意前面的字符串是有效的，你可以用它来切换版本或者合并分支。</p><h2 id="Git新增分支操作：git-switch、git-restore"><a href="#Git新增分支操作：git-switch、git-restore" class="headerlink" title="Git新增分支操作：git switch、git restore"></a>Git新增分支操作：git switch、git restore</h2><p>这两个命令是git 2.23以后引入的命令，目的是为了提供对新手更友好的分支操作，最早我们使用的是git checkout命令来对分支进行操作，这个命令相对于复杂了许多，使用很多子参数来进行操作，为此git新增了两个命令：switch、restore，switch是用来切换分支与新增分支的，而restore用来撤销文件的修改，使其变得更明确一点</p><p>切换分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git switch dev</span><br></pre></td></tr></table></figure><p>注意如果分支不存在，是不会创建的</p><p>切换到commit ID：</p><p>切换到指定id并创建一个分支，我们称之为分离HEAD状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git switch -d f8c540805b7e16753c65619ca3d7514178353f39</span><br></pre></td></tr></table></figure><p>只需要加上-d参数就可以了，而checkout是不需要加-d的，在switch里一切变得明确了很多</p><p>如果要合并一个分支必须加上-b</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git switch -b dev</span><br></pre></td></tr></table></figure><p>创建分支则是-c</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git switch -c dev</span><br></pre></td></tr></table></figure><p>git restore命令是用来撤销提交与修改的，如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git restore file</span><br></pre></td></tr></table></figure><p>使用这条命令会将文件从暂存区删除</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git restore file</span><br></pre></td></tr></table></figure><p>这条命令会不会将文件从暂存区里删除，会将文件在暂存区里的状态覆盖到工作区，如我在工作区对这个文件又进行了修改，那么使用这个命令可以将这个文件在暂存区里的内容恢复到工作区</p><h2 id="搭建本地git服务器"><a href="#搭建本地git服务器" class="headerlink" title="搭建本地git服务器"></a>搭建本地git服务器</h2><p>第一步在debian&#x2F;linux下使用此命令安装完整git</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install git</span><br></pre></td></tr></table></figure><p>安装完成之后我们可以新建一个用户用来做专门管理git服务的账户</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git adduser git</span><br></pre></td></tr></table></figure><p>这样，就创建了一个账户名为git组也为git的账户</p><p>我们切换到这个用户下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su git</span><br></pre></td></tr></table></figure><p>然后使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;你的邮箱&quot;</span></span><br></pre></td></tr></table></figure><p>配置好当前服务器的sshkey ，配置好之后会在用户目录下生成一个.ssh目录</p><p>然后在”.ssh”目录里面查看有没有authorized_keys文件，没有则创建一个</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">touch</span> authorized_keys</span><br></pre></td></tr></table></figure><p>这个文件是用来存放别人的公钥的，就像上面配置github一样，你把别人机器上的ssh key的公钥输入到这个文件中，这样git才会开启权限免密登录，让其拥有推送以及拉取的权限。</p><p>好了你现在是这台git服务器的管理者了。</p><p>那么你现在想要创建一个仓库，并分享给团队。</p><p>假如你们要做一个文本编辑器，你可以使用git init –bare创建一个名为txt的文件目录。</p><p>注意要用git init，这里我们以.git为结尾，通常git仓库都是这样命名。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo git init --bare txt.git</span><br></pre></td></tr></table></figure><p>很遗憾它报了个错</p><p><img src="/./../images/git%E7%9A%84%E4%BD%BF%E7%94%A8/20210101225626716.png"></p><p>这是因为我们新建的用户没有sudo权限，我们执行如下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/sudoers</span><br></pre></td></tr></table></figure><p>然后添加一行内容进去</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git  ALL=(ALL:ALL) ALL</span><br></pre></td></tr></table></figure><p>这样我们就可以执行sudo权限了，如果提示没有权限，则切回到可以执行sudo的用户中，执行上面的操作，在切回git。</p><p><img src="/./../images/git%E7%9A%84%E4%BD%BF%E7%94%A8/20210101225811169.png"></p><p>我们在改变一下文件所属用户与组，让这个文件属于当前用户与组</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">chown</span> -R git:git txt.git</span><br></pre></td></tr></table></figure><p>为了安全考虑我们需要禁用ssh登录到我们的shell，防止别人登录到shell之后对我们的电脑做增删改</p><p>输入如下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/passwd</span><br></pre></td></tr></table></figure><p>找到这一行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git:x:1001:1001:,,,:/home/git:/bin/bash</span><br></pre></td></tr></table></figure><p>改为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell</span><br></pre></td></tr></table></figure><p>我们将默认ssh登录改为到git-shell程序中，这个git提供的shell程序，一旦登录会自动秒退。</p><p>好了现在可以让你的小伙伴们来克隆txt.git这个仓库了。</p><p><img src="/./../images/git%E7%9A%84%E4%BD%BF%E7%94%A8/20210101232304323.png"></p><p>注意，你的服务器需要安装ssh服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install openssh-server</span><br></pre></td></tr></table></figure><p>在git用户下执行上面这个命令，因为每个环境都不一样。</p><p>不然的话可能出现如下状况，ssh无法解析主机名：</p><p><img src="/./../images/git%E7%9A%84%E4%BD%BF%E7%94%A8/20210101232734912.png"></p><h2 id="Git问题总汇"><a href="#Git问题总汇" class="headerlink" title="Git问题总汇"></a>Git问题总汇</h2><h2 id="error-src-refspec-main-does-not-match-any"><a href="#error-src-refspec-main-does-not-match-any" class="headerlink" title="error: src refspec main does not match any"></a><a href="https://jrhar.blog.csdn.net/article/details/113931821" title="error: src refspec main does not match any">error: src refspec main does not match any</a></h2><h2 id="Please-make-sure-you-have-the-correct-access-rights-and-the-repository-exists"><a href="#Please-make-sure-you-have-the-correct-access-rights-and-the-repository-exists" class="headerlink" title="Please make sure you have the correct access rights and the repository exists."></a><a href="https://jrhar.blog.csdn.net/article/details/113934922" title="Please make sure you have the correct access rights and the repository exists.">Please make sure you have the correct access rights and the repository exists.</a></h2><h2 id="git命令总结"><a href="#git命令总结" class="headerlink" title="git命令总结"></a>git命令总结</h2><blockquote><h2 id="创造"><a href="#创造" class="headerlink" title="创造"></a>创造</h2><p>克隆现有存储库</p><p>$ git clone ssh:&#x2F;&#x2F;<a href="mailto:&#x75;&#x73;&#x65;&#x72;&#64;&#100;&#111;&#109;&#97;&#x69;&#x6e;&#46;&#99;&#x6f;&#x6d;">&#x75;&#x73;&#x65;&#x72;&#64;&#100;&#111;&#109;&#97;&#x69;&#x6e;&#46;&#99;&#x6f;&#x6d;</a>&#x2F;repo.git</p><p>创建一个新的本地存储库</p><p>$ git init</p><h2 id="当地变化"><a href="#当地变化" class="headerlink" title="当地变化"></a>当地变化</h2><p>Changed files in your working directory</p><p>$ git status</p><p>Changes to tracked files</p><p>$ git diff</p><p>将所有当前更改添加到下一个提交</p><p>$ git add .</p><p>在中添加一些更改到下一次提交</p><p>$ git add -p</p><p>提交跟踪文件中的所有本地更改</p><p>$ git commit -a</p><p>提交先前进行的更改</p><p>$ git commit</p><p>更改最后一次提交</p><p>不要修改已发布的提交！</p><p>$ git commit –amend</p><h2 id="提交历史"><a href="#提交历史" class="headerlink" title="提交历史"></a>提交历史</h2><p>显示所有提交，从最新开始</p><p>$ git log</p><p>显示特定文件随时间的变化e</p><p>$ git log -p</p><p>谁更改了中的内容和时间</p><p>$ git blame</p><h2 id="分支机构和标签"><a href="#分支机构和标签" class="headerlink" title="分支机构和标签"></a>分支机构和标签</h2><p>列出所有现有分支</p><p>$ git branch -av</p><p>切换HEAD分支</p><p>$ git checkout</p><p>根据您当前的HEAD创建一个新分支</p><p>$ git branch</p><p>基于远程分支创建一个新的跟踪分支</p><p>$ git checkout –track</p><p>删除本地分支</p><p>$ git branch -d</p><p>用标签标记当前提交</p><p>$ git tag</p><h2 id="更新和发布"><a href="#更新和发布" class="headerlink" title="更新和发布"></a>更新和发布</h2><p>列出所有当前配置的遥控器</p><p>$ git remote -v</p><p>显示有关遥控器的信息</p><p>$ git remote show</p><p>添加名为的新远程存储库</p><p>$ git remote add</p><p>从下载所有更改，但不要集成到HEAD中</p><p>$ git fetch</p><p>下载更改并直接合并&#x2F;集成到HEAD中</p><p>$ git pull</p><p>在远程上发布本地更改</p><p>$ git push</p><p>删除遥控器上的分支</p><p>$ git branch -dr</p><p>发布标签</p><p>$ git push –tags</p><h2 id="合并与基础"><a href="#合并与基础" class="headerlink" title="合并与基础"></a>合并与基础</h2><p>将合并到当前HEAD中</p><p>$ git merge</p><p>将当前的HEAD重新设置到</p><p>不要重新发布已发布的提交！</p><p>$ git rebase</p><p>中止基准</p><p>$ git rebase –abort</p><p>解决冲突后继续进行基准</p><p>$ git rebase –continue</p><p>使用您配置的合并工具解决冲突</p><p>$ git mergetool</p><p>使用编辑器手动解决冲突，并（在解决之后）将文件标记为已解决</p><p>$ git add</p><p>$ git rm</p><h2 id="撤消"><a href="#撤消" class="headerlink" title="撤消"></a>撤消</h2><p>丢弃工作目录中的所有本地更改</p><p>$ git reset –hard HEAD</p><p>放弃特定文件中的本地更改</p><p>$ git checkout HEAD</p><p>还原提交（通过产生具有相反更改的新提交）</p><p>$ git revert</p><p>将HEAD指针重置为上一次提交</p><p>…并丢弃此后的所有更改</p><p>$ git reset –hard</p><p>…并将所有更改保留为未分阶段的更改</p><p>$ git reset</p><p>…并保留未提交的本地更改</p><p>$ git reset –keep</p><h2 id="提交相关更改"><a href="#提交相关更改" class="headerlink" title="提交相关更改"></a>提交相关更改</h2><p>提交应该是相关更改的包装。 例如，修复两个不同的错误应产生两个单独的提交。 小型提交使其他开发人员更容易理解更改，并在出现问题时将其回滚。 借助暂存区等工具以及仅暂存文件部分的功能，Git使得创建非常精细的提交变得容易。</p><h2 id="经常提交"><a href="#经常提交" class="headerlink" title="经常提交"></a>经常提交</h2><p>提交通常会使您的提交变小，并且再次帮助您仅提交相关的更改。 而且，它使您可以更频繁地与他人共享代码。 这样，每个人都可以更轻松地定期集成更改，避免合并冲突。 相比之下，大型提交很少且很少共享，因此很难解决冲突。</p><h2 id="不要做半成品"><a href="#不要做半成品" class="headerlink" title="不要做半成品"></a>不要做半成品</h2><p>您只应在完成代码后提交代码。 这并不意味着您在提交之前必须先完成一个完整的大型功能。 恰恰相反：将功能的实现分成逻辑块，并记住提早并经常提交。 但是，不要承诺在一天结束离开办公室之前在存储库中存放一些东西。 如果您只是因为需要干净的工作副本（来签出分支，进行更改等）而打算提交，请考虑改用Git的“隐藏”功能。</p><h2 id="提交之前的测试代码"><a href="#提交之前的测试代码" class="headerlink" title="提交之前的测试代码"></a>提交之前的测试代码</h2><p>抵制诱惑，以完成您“认为”的事情。 对其进行彻底的测试，以确保它确实完成并且没有副作用（据人们所知）。 虽然只需要原谅自己在本地存储库中提交的东西，但是在与他人推送&#x2F;共享代码时，测试代码就显得尤为重要。</p><h2 id="写好的提交信息"><a href="#写好的提交信息" class="headerlink" title="写好的提交信息"></a>写好的提交信息</h2><p>首先以简短的更改摘要（最多50个字符为准则）开始您的消息。 通过包含空白行将其与后续正文分开。 邮件正文应提供以下问题的详细答案：</p><p>›改变的动机是什么？</p><p>›它与以前的实现有何不同？</p><p>使用命令式现在时态（“ change”，而不是“ changed”或“ changes”）与git merge等命令生成的消息保持一致。</p><h2 id="版本控制不是备份系统"><a href="#版本控制不是备份系统" class="headerlink" title="版本控制不是备份系统"></a>版本控制不是备份系统</h2><p>将文件备份到远程服务器上是拥有版本控制系统的一个很好的副作用。 但是，您不应像将其用作备份系统那样使用VCS。 在进行版本控制时，您应注意语义上的提交（请参阅“相关更改”）-您不应该只是在文件中塞入。</p><h2 id="使用分支"><a href="#使用分支" class="headerlink" title="使用分支"></a>使用分支</h2><p>分支是Git最强大的功能之一-并不是偶然的：从一开始，快速便捷的分支就成为了中心需求。 分支是完美的工具，可帮助您避免混淆不同的开发路线。 您应该在开发工作流程中广泛使用分支：有关新功能，错误修复，想法…</p><h2 id="同意工作流程"><a href="#同意工作流程" class="headerlink" title="同意工作流程"></a>同意工作流程</h2><p>Git让您从许多不同的工作流程中进行选择：长期运行的分支，主题分支，合并或重新设置，git-flow…您选择哪个取决于两个因素：项目，整体开发和部署工作流程以及（也许 最重要的是），以了解您和您的队友的个人喜好。 无论您选择工作，只要确保在每个人都遵循的通用工作流程上达成一致即可。</p><h2 id="帮助和文档"><a href="#帮助和文档" class="headerlink" title="帮助和文档"></a>帮助和文档</h2><p>在命令行获取帮助</p><p>$ git help</p><h2 id="免费的在线资源"><a href="#免费的在线资源" class="headerlink" title="免费的在线资源"></a>免费的在线资源</h2><p><a href="http://www.git-tower.com/learn/?utm_source=Tower+Blog&utm_medium=cheat+sheet+pdf&utm_content=german+version&utm_campaign=Tower+website" title="http://www.git-tower.com/learn">http://www.git-tower.com/learn</a></p><p><a href="http://rogerdudler.github.io/git-guide/" title="git - the simple guide - no deep shit!">git - the simple guide - no deep shit!</a></p><p><a href="http://www.git-scm.org/" title="Git">Git</a></p></blockquote><p>这里我整理了一份word文档</p><p><img src="/./../images/git%E7%9A%84%E4%BD%BF%E7%94%A8/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JqYnpfY3h5,size_16,color_FFFFFF,t_70-1683254816239-38.png"></p><p>有需要的同学可以在这里下载:<a href="https://download.csdn.net/download/bjbz_cxy/14004358" title="https://download.csdn.net/download/bjbz_cxy/14004358">https://download.csdn.net/download/bjbz_cxy&#x2F;14004358</a></p><p>最后祝大家新年快乐</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本篇文章的环境是在Debian&amp;#x2F;Linux环境下编写。&lt;/p&gt;
&lt;p&gt;在日常工作中git少不了，所以编写</summary>
      
    
    
    
    <category term="工具使用" scheme="https://wx51815.github.io/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
    
    <category term="git" scheme="https://wx51815.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>异常</title>
    <link href="https://wx51815.github.io/page/Java%E5%9F%BA%E7%A1%80/%E5%BC%82%E5%B8%B8/"/>
    <id>https://wx51815.github.io/page/Java%E5%9F%BA%E7%A1%80/%E5%BC%82%E5%B8%B8/</id>
    <published>2023-05-09T07:24:34.000Z</published>
    <updated>2023-06-10T07:50:13.034Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>[TOC]</p><p><strong>Java中的异常（Exception）又称为例外，是一个在程序执行期间发生的事件，它中断正在执行程序的正常指令流。为了能够及时有效地处理程序中的运行错误，必须使用异常类。</strong></p></blockquote><h2 id="1-异常产生的原因和分类"><a href="#1-异常产生的原因和分类" class="headerlink" title="1. 异常产生的原因和分类"></a>1. 异常产生的原因和分类</h2><h2 id="1-1-异常产生的原因"><a href="#1-1-异常产生的原因" class="headerlink" title="1.1 异常产生的原因"></a>1.1 异常产生的原因</h2><p><strong>⚜️ 在Java中异常产生，主要是有三种原因：</strong></p><blockquote><p><strong>（1）编写程序代码中的错误产生的异常，比如数组越界、空指针异常等，这种异常叫做未检查的异常，一般需要在类中处理这些异常</strong></p><p><strong>（2）Java内部错误发生的异常，Java虚拟机产生异常</strong></p><p><strong>（3）通过throw（抛出异常）语句手动生成的异常，这种异常叫做检查的异常，一般是用来给方法调用者一些必要的信息</strong></p></blockquote><h2 id="1-2-异常分类"><a href="#1-2-异常分类" class="headerlink" title="1.2 异常分类"></a>1.2 异常分类</h2><p><img src="/./../images/%E5%BC%82%E5%B8%B8/b3097e573c674c35add84935c72c9811.png"></p><blockquote><p> <strong>（1）Throwable：是异常体系的顶层类，其派生出两个重要的子类, Error 和 Exception</strong></p><pre><code>  **而 Error 和 Exception 两子类分别表示错误和异常。**   **区别就是不检查异常（Unchecked Exception）和检查异常（Checked Exception）。**</code></pre><p> <strong>（2）Exception 类用于用户程序可能出现的异常情况，它也是用来创建自定义异常类型类的类。</strong></p><p> <strong>（3）Error 定义了在通常环境下不希望被程序捕获的异常。Error 类型的异常用于 Java 运行时由系统显示与运行时系统本身有关的错误。堆栈溢出是这种错误的一例。</strong></p></blockquote><p><strong>⚜️  异常可能在编译时发生，也有可能在程序运行时发生，根据发生时机不同，可以分为：</strong></p><blockquote><p><strong>运行时异常都是 RuntimeException 类及其子类异常，如 NullPointerException、IndexOutOfBoundsException 等，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般由程序逻辑错误引起，程序应该从逻辑角度尽可能避免这类异常的发生。</strong></p></blockquote><p>比如：</p><p><img src="/./../images/%E5%BC%82%E5%B8%B8/8cd741757bc94b22b919cfeb08317aae.png"></p><blockquote><p><strong>编译时异常是指 RuntimeException 以外的异常，类型上都属于 Exception 类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如 IOException、ClassNotFoundException 等以及用户自定义的 Exception 异常，一般情况下不自定义检查异常。</strong></p></blockquote><p>比如 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test01</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person1</span> <span class="operator">=</span>(Person) person.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <img src="/./../images/%E5%BC%82%E5%B8%B8/650974e578784080abb7e94013e844cb.png"></p><hr><h2 id="2-异常的处理"><a href="#2-异常的处理" class="headerlink" title="2. 异常的处理"></a>2. 异常的处理</h2><h2 id="2-1-防御式编程"><a href="#2-1-防御式编程" class="headerlink" title="2.1 防御式编程"></a>2.1 防御式编程</h2><p>错误在代码中是客观存在的. 所以要让程序出现问题的时候快速通知程序猿. </p><p>通知有两种方式：</p><p><strong>🤠（1）LBYL 在操作之前就做充分的检查</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">divide</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        a = scanner.nextInt();</span><br><span class="line">        b = scanner.nextInt();</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;除数为0&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> a / b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>缺点：正常流程和错误处理流程代码混在一起, 代码整体条理不清晰。</strong></p><p><strong>🤠 （2）EAFP 先操作遇到问题再处理</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">divide</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in)) &#123;</span><br><span class="line">            a = scanner.nextInt();</span><br><span class="line">            b = scanner.nextInt();</span><br><span class="line">            <span class="keyword">return</span> a / b;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ArithmeticException exception) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;除数为0&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>优点：正常流程和错误流程是分离开的, 程序员更关注正常流程，代码更清晰，容易理解代码</strong></p><blockquote><p><strong>处理异常的核心思想就是EAFP</strong> </p></blockquote><hr><h2 id="2-2-异常的抛出（throw）"><a href="#2-2-异常的抛出（throw）" class="headerlink" title="2.2 异常的抛出（throw）"></a>2.2 异常的抛出（throw）</h2><blockquote><p><strong>在编写程序时，如果程序中出现错误，这就需要将错误的信息通知给调用者</strong></p><p><strong>这里就可以借助关键字throw，抛出一个指定的异常对象，将错误信息告知给调用者。</strong></p></blockquote><p><strong>🤠 比如写一个运行时异常</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">func2</span><span class="params">(<span class="type">int</span> a)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(a == <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="comment">//抛出的是一个指定的异常，最多的使用方式是，抛出一个自定义的异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;a==0&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    func2(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/./../images/%E5%BC%82%E5%B8%B8/94552d7313d34efba687e234f99e1c4f.png"> 注意：</p><blockquote><p><strong>（1）throw必须写在方法体内部</strong></p><p><strong>（2）如果抛出的是编译时异常，用户就必须要处理，否则无法通过编译</strong></p><p><img src="/./../images/%E5%BC%82%E5%B8%B8/647f262b7295496db2851369990bfa83.png"></p><p><strong>（3）如果抛出的运行时异常，则可以不用处理，直接交给JVM来处理</strong></p><p><strong>（4）一旦出现异常，后面的代码就不会执行</strong></p><p><img src="/./../images/%E5%BC%82%E5%B8%B8/c964f1672ba544e782a288c2051876b1.png"></p></blockquote><hr><h2 id="2-3-异常的捕获"><a href="#2-3-异常的捕获" class="headerlink" title="2.3 异常的捕获"></a>2.3 异常的捕获</h2><h3 id="2-3-1-throws异常声明"><a href="#2-3-1-throws异常声明" class="headerlink" title="2.3.1 throws异常声明"></a>2.3.1 throws异常声明</h3><p><img src="/./../images/%E5%BC%82%E5%B8%B8/f3663ee4120b44eca9a7b43344304a71.png"></p><blockquote><p><strong>🤠  throws处在方法声明时参数列表之后，当方法中抛出编译时异常，用户不想处理该异常，</strong></p><p><strong>此时就可以借助throws将异常抛 给方法的调用者来处理。</strong></p><p><strong>格式：</strong></p><p><strong>修饰符 返回值类型 方法名(参数列表) throws 异常类型 {</strong></p><p><strong>}</strong></p></blockquote><p><strong>🤠 如果说方法内部抛出了多个异常，throws之后就必须跟多个异常类型，用逗号进行分隔</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">func2</span><span class="params">(<span class="type">int</span> a)</span> <span class="keyword">throws</span> CloneNotSupportedException, FileNotFoundException &#123;</span><br><span class="line">    <span class="keyword">if</span>(a == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CloneNotSupportedException</span>(<span class="string">&quot;a==0&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(a == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FileNotFoundException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>🤠  如果抛出多个异常类型有父子关系，直接声明父类</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">func2</span><span class="params">(<span class="type">int</span> a)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">if</span>(a == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CloneNotSupportedException</span>(<span class="string">&quot;a==0&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(a == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FileNotFoundException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>🤠 调用声明抛出异常的方法时，调用者必须对该异常进行处理，或者继续使用throws抛出</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException, CloneNotSupportedException &#123;</span><br><span class="line">     func2(<span class="number">0</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><hr><h3 id="2-3-2-try-catch捕获异常并处理"><a href="#2-3-2-try-catch捕获异常并处理" class="headerlink" title="2.3.2 try-catch捕获异常并处理"></a><strong>2.3.2 try-catch捕获异常并处理</strong></h3><p><strong>当程序抛出异常的时候，程序员通过try-each处理了异常</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] array = <span class="literal">null</span>;</span><br><span class="line">        System.out.println(array.length);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (NullPointerException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;捕获到了一个空指针异常！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;其他程序！&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>如果程序抛出异常，不处理异常，那就会交给JVM处理，JVM处理就会把程序立即终止</strong></p><p><strong>并且，即使用了try-each 也必须捕获一个对应的异常，如果不是对应异常，也会让JVM进行处理</strong></p><p><img src="/./../images/%E5%BC%82%E5%B8%B8/eb1782f4a39d411e98373d8da73d651a.png"></p><p><strong>🤠  如果try抛出多个异常，就必须用多个catch进行捕获</strong></p><p><strong>这里注意，用多个catch****进行捕获，不是同时进行捕获的，因为不可能同时抛不同的异常</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] array = <span class="literal">null</span>;</span><br><span class="line">        System.out.println(array.length);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (NullPointerException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;捕获到了一个空指针异常！&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (ArithmeticException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;捕获到了一个算术异常！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;其它代码逻辑！&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以简写一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] array = <span class="literal">null</span>;</span><br><span class="line">        System.out.println(array.length);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (NullPointerException  | ArithmeticException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;捕获到了一个空指针或算术异常！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;其它代码逻辑！&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>🤠 如果异常之间具有父子关系，那就必须子类异常在前，父类异常在后catch，不然会报错</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] array = <span class="literal">null</span>;</span><br><span class="line">        System.out.println(array.length);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (NullPointerException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;捕获到了一个空指针异常！&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;捕获到了一个算术异常！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;其它代码逻辑！&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="2-3-3-finally"><a href="#2-3-3-finally" class="headerlink" title="2.3.3 finally"></a>2.3.3 finally</h3><blockquote><p><strong>🤠 finally用来进行资源回收，不论程序正常运行还是退出，都需要回收资源</strong></p><p><strong>并且异常会引发程序的跳转，可能会导致有些语句执行不到</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] array = <span class="literal">null</span>;</span><br><span class="line">        System.out.println(array.length);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (NullPointerException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;捕获到了一个空指针异常！&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (ArithmeticException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;捕获到了一个算术异常！&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        scanner.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;进行资源关闭！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;其它代码逻辑！&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/./../images/%E5%BC%82%E5%B8%B8/97da2d4569224272b2b494fefc9e5ca0.png"></p><p> <strong>如果不为空，那么finally还会被执行吗</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] array = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        System.out.println(array.length);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (NullPointerException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;捕获到了一个空指针异常！&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (ArithmeticException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;捕获到了一个算术异常！&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        scanner.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;进行资源关闭！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;其它代码逻辑！&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/./../images/%E5%BC%82%E5%B8%B8/989c923c5e564ccd9a7a81fd5ca232dd.png"></p><p><strong>所以，不管程序会不会抛出异常，finally都会执行</strong></p><p><strong>⚜️ 如果将资源写在try中会自动帮助，关掉资源的</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in)) &#123;</span><br><span class="line">        <span class="type">int</span>[] array = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        System.out.println(array.length);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NullPointerException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;捕获到了一个空指针异常！&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ArithmeticException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;捕获到了一个算术异常！&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;进行资源关闭！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;其它代码逻辑！&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 下面看这一段代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> a)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span>  <span class="keyword">new</span> <span class="title class_">ArithmeticException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ArithmeticException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;算术异常！&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(func(<span class="number">10</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/./../images/%E5%BC%82%E5%B8%B8/20037895f8da45b290e0dea0fc06f157.png"></p><p> <strong>可以发现即使有return，finally也会被执行</strong></p><blockquote><p> <strong>总结一下：</strong></p><p> <strong>throw抛出异常，throws声明异常</strong></p><p> <strong>finally语句一定会执行</strong></p></blockquote><h2 id="3-自定义异常类"><a href="#3-自定义异常类" class="headerlink" title="3.自定义异常类"></a>3.自定义异常类</h2><blockquote><p><strong>虽然java中有很多异常类，但是在实际开发中所遇到的一些异常，不能完全表示，</strong></p><p><strong>所以这就需要我们自定义异常类</strong></p></blockquote><p><strong>举一个例子</strong></p><p><strong>先自定义一个运行时异常</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义了一个运行时异常</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyException</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyException</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>写一个类来捕获这个自定义异常</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> a )</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MyException</span>(<span class="string">&quot;呵呵！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            func(<span class="number">20</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (MyException myException) &#123;</span><br><span class="line">            myException.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;sadasdasd&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>下面写一个用户登录的自定义异常类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UserNameException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserNameException</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserNameException</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PasswordException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PasswordException</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PasswordException</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogIn</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">uName</span> <span class="operator">=</span> <span class="string">&quot;admin&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">pword</span> <span class="operator">=</span> <span class="string">&quot;1111&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">loginInfo</span><span class="params">(String userName, String password)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ( !uName.equals(userName)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UserNameException</span>(<span class="string">&quot;用户名错误！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( !pword.equals(password)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;密码错误！&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;登录成功！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            loginInfo(<span class="string">&quot;admin&quot;</span>,<span class="string">&quot;1111&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UserNameException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (PasswordException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><blockquote><p><strong>自定义异常默认会继承 Exception 或者 RuntimeException</strong></p><p><strong>继承于 Exception 的异常默认是受查异常</strong></p><p><strong>继承于 RuntimeException 的异常默认是非受查异常</strong></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Java中的异常（Exception）又称为例外，是一个在程序执行期间发生的事件，它中断正在执行程序的正常指令流。为了能够及时有效地处理程序中的运行错误，必须使用异常类。&lt;/strong&gt;&lt;/p&gt;
&lt;/bl</summary>
      
    
    
    
    <category term="Java基础" scheme="https://wx51815.github.io/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Java" scheme="https://wx51815.github.io/tags/Java/"/>
    
    <category term="异常" scheme="https://wx51815.github.io/tags/%E5%BC%82%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>线程概念</title>
    <link href="https://wx51815.github.io/page/Java%E5%9F%BA%E7%A1%80/%E7%BA%BF%E7%A8%8B%E6%A6%82%E5%BF%B5/"/>
    <id>https://wx51815.github.io/page/Java%E5%9F%BA%E7%A1%80/%E7%BA%BF%E7%A8%8B%E6%A6%82%E5%BF%B5/</id>
    <published>2023-05-09T07:24:16.000Z</published>
    <updated>2023-06-10T07:50:13.036Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1-多线程"><a href="#1-多线程" class="headerlink" title="1 多线程"></a>1 <strong>多线程</strong></h2><hr><p>我们在之前，学习的程序在没有跳转语句的前提下，都是由上⾄下依次执⾏，那现在想要设计⼀个程序， 边打游戏边听歌，怎么设计？</p><p>要解决上述问题，咱们得使⽤多进程或者多线程来解决。</p><h2 id="1-1-并发与并⾏"><a href="#1-1-并发与并⾏" class="headerlink" title="1.1 并发与并⾏"></a>1.1 <strong>并发与并⾏</strong></h2><ul><li><strong>并发</strong>：指两个或多个事件在<strong>同⼀个时间段内</strong>发⽣。</li><li><strong>并⾏</strong>：指两个或多个事件在<strong>同⼀时刻</strong>发⽣（同时发⽣）。</li></ul><p><img src="/./../images/%E7%BA%BF%E7%A8%8B%E6%A6%82%E5%BF%B5/e697dc63586b463e9f53c2345b7988ca.png"></p><p>在操作系统中，安装了多个程序，并发指的是在⼀段时间内宏观上有多个程序同时运⾏，这在单 CPU 系统中，每⼀时刻只能有⼀道程序执⾏，即微观上这些程序是分时的交替运⾏，只不过是给⼈的感觉是同时运 ⾏，那是因为分时交替运⾏的时间是⾮常短的。</p><p>⽽在多个 CPU 系统中，则这些可以并发执⾏的程序便可以分配到多个处理器上（ CPU ），实现多任务并⾏ 执⾏，即利⽤每个处理器来处理⼀个可以并发执⾏的程序，这样多个程序便可以同时执⾏。⽬前电脑市场 上说的多核 CPU ，便是多核处理器，核 越多，并⾏处理的程序越多，能⼤⼤的提⾼电脑运⾏的效率。</p><blockquote><p>注意：单核处理器的计算机肯定是不能并⾏的处理多个任务的，只能是多个任务在单个 CPU 上并发运 ⾏。同理 , 线程也是⼀样的，从宏观⻆度上理解线程是并⾏运⾏的，但是从微观⻆度上分析却是串⾏ 运⾏的，即⼀个线程⼀个线程的去运⾏，当系统只有⼀个 CPU 时，线程会以某种顺序执⾏多个线程， 我们把这种情况称之为线程调度。</p></blockquote><h2 id="1-2-线程与进程"><a href="#1-2-线程与进程" class="headerlink" title="1.2 线程与进程"></a>1.2 <strong>线程与进程</strong></h2><ul><li><strong>进程</strong>：是指⼀个内存中运⾏的应⽤程序，每个进程都有⼀个独⽴的内存空间，⼀个应⽤程序可以同时运⾏多个进程；进程也是程序的⼀次执⾏过程，是系统运⾏程序的基本单位；系统运⾏⼀个程序即是 ⼀个进程从创建、运⾏到消亡的过程。</li><li><strong>线程</strong>：线程是进程中的⼀个执⾏单元，负责当前进程中程序的执⾏，⼀个进程中⾄少有⼀个线程。⼀个进程中是可以有多个线程的，这个应⽤程序也可以称之为多线程程序。</li></ul><p>简⽽⾔之：⼀个程序运⾏后⾄少有⼀个进程，⼀个进程中可以包含多个线程</p><p>我们可以再电脑底部任务栏，右键 --&gt; 打开任务管理器，可以查看当前任务的进程：</p><p><strong>进程</strong></p><p><img src="/./../images/%E7%BA%BF%E7%A8%8B%E6%A6%82%E5%BF%B5/ed5d1ce2c4c44a6eb927a7abbf8393ae.png"></p><p> <img src="/./../images/%E7%BA%BF%E7%A8%8B%E6%A6%82%E5%BF%B5/0b7e941029304ee1b622b2e58ec697f3.png"></p><p><strong>线程调度：</strong></p><ul><li><p>分时调度</p><pre><code>所有线程轮流使⽤ CPU 的使⽤权，平均分配每个线程占⽤ CPU 的时间。</code></pre></li><li><p>抢占式调度</p><pre><code>优先让优先级⾼的线程使⽤ CPU，如果线程的优先级相同，那么会随机选择⼀个（线程随机性）， Java使⽤的为抢占式调度。</code></pre></li></ul><ol><li>设置线程的优先级</li></ol><p><img src="/./../images/%E7%BA%BF%E7%A8%8B%E6%A6%82%E5%BF%B5/8b8609a68d314757817b4146dd59288f.png"></p><pre><code>    2.抢占式调度详解    ⼤部分操作系统都⽀持多进程并发运⾏，现在的操作系统⼏乎都⽀持同时运⾏多个程序。⽐如： 现在我们上课⼀边使⽤编辑器，⼀边使⽤录屏软件，同时还开着画图板， dos 窗⼝等软件。此</code></pre><p>时，这些程序是在同时运⾏， “ 感觉这些软件好像在同⼀时刻运⾏着 ” 。</p><pre><code>    实际上，CPU （中央处理器）使⽤抢占式调度模式在多个线程间进⾏着⾼速的切换。对于 CPU 的 ⼀个核⽽⾔，某个时刻，只能执⾏⼀个线程，⽽ CPU 的在多个线程间切换速度相对我们的感觉 要快，看上去就是在同⼀时刻运⾏。    其实，多线程程序并不能提⾼程序的运⾏速度，但能够提⾼程序运⾏效率，让 CPU 的使⽤率更 ⾼。</code></pre><h2 id=""><a href="#" class="headerlink" title=""></a><img src="/./../images/%E7%BA%BF%E7%A8%8B%E6%A6%82%E5%BF%B5/7923ddf18b11435593a956fc119a8d07.png"></h2><h2 id="1-3-创建线程类"><a href="#1-3-创建线程类" class="headerlink" title="1.3 创建线程类"></a>1.3 <strong>创建线程类</strong></h2><p>Java 使⽤ java.lang.Thread 类代表 <strong>线程</strong> ，所有的线程对象都必须是 Thread 类或其⼦类的实例。每个线程的作⽤是完成⼀定的任务，实际上就是执⾏⼀段程序流即⼀段顺序执⾏的代码。 Java 使⽤线程执⾏体来 代表这段程序流。 Java 中通过继承 Thread 类来 <strong>创建</strong> 并 <strong>启动多线程</strong> 的步骤如下：</p><p>1. 定义 Thread 类的⼦类，并重写该类的 run() ⽅法，该 run() ⽅法的⽅法体就代表了线程需要完成的任务，因此把 run() ⽅法称为线程执⾏体。</p><p>2. 创建 Thread ⼦类的实例，即创建了线程对象</p><p>3. 调⽤线程对象的 start() ⽅法来启动该线程</p><p>代码如下：</p><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> <span class="comment">// 创建⾃定义线程对象</span></span><br><span class="line"> <span class="type">MyThread</span> <span class="variable">mt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(<span class="string">&quot;新的线程！&quot;</span>);</span><br><span class="line"> <span class="comment">// 开启新线程</span></span><br><span class="line"> mt.start();</span><br><span class="line"> <span class="comment">// 在主⽅法中执⾏for循环</span></span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line"> System.out.println(<span class="string">&quot;main线程！&quot;</span> + i);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>⾃定义线程类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"> <span class="comment">// 定义指定线程名称的构造⽅法</span></span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">MyThread</span><span class="params">(String name)</span> &#123;</span><br><span class="line"> <span class="comment">// 调⽤⽗类的String参数的构造⽅法，指定线程的名称</span></span><br><span class="line"> <span class="built_in">super</span>(name);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 重写run⽅法，完成该线程执⾏的逻辑</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line"> System.out.println(getName() + <span class="string">&quot;：正在执⾏！&quot;</span> + i);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-多线程详解"><a href="#2-多线程详解" class="headerlink" title="2 多线程详解"></a>2 <strong>多线程详解</strong></h2><hr><h2 id="2-1-多线程原理"><a href="#2-1-多线程原理" class="headerlink" title="2.1 多线程原理"></a>2.1 <strong>多线程原理</strong></h2><p>刚刚我们已经写过⼀版多线程的代码，很多同学对原理不是很清楚，那么现在我们先画个多线程执⾏时序 图来体现⼀下多线程程序的执⾏流程。 代码如下：</p><p>⾃定义线程类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 利⽤继承中的特点</span></span><br><span class="line"><span class="comment"> * 将线程名称传递 进⾏设置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">MyThread</span><span class="params">(String name)</span> &#123;</span><br><span class="line"> <span class="built_in">super</span>(name);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 重写run⽅法</span></span><br><span class="line"><span class="comment"> * 定义线程要执⾏的代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line"> <span class="comment">//getName()⽅法 来⾃⽗亲</span></span><br><span class="line"> System.out.println(getName() + i);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> System.out.println(<span class="string">&quot;这⾥是main线程&quot;</span>);</span><br><span class="line"> <span class="type">MyThread</span> <span class="variable">mt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(<span class="string">&quot;⼩强&quot;</span>);</span><br><span class="line"> mt.start(); <span class="comment">// 开启了⼀个新的线程</span></span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line"> System.out.println(<span class="string">&quot;旺财:&quot;</span> + i);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>流程图：</p><p><img src="/./../images/%E7%BA%BF%E7%A8%8B%E6%A6%82%E5%BF%B5/853c96fc0e64435bafec76bd233a2d19.png"></p><p>程序启动运⾏ main 时候， java 虚拟机启动⼀个进程，主线程 main 在 main() 调⽤时候被创建。随着调⽤mt 的对象的 start ⽅法，另外⼀个新的线程也启动了，这样，整个应⽤就在多线程下运⾏。</p><p>通过这张图我们可以很清晰的看到多线程的执⾏流程，那么为什么可以完成并发执⾏呢？我们再来讲⼀讲原理。</p><p>多线程执⾏时，到底在内存中是如何运⾏的呢？以上个程序为例，进⾏图解说明：</p><p>多线程执⾏时，在栈内存中，其实 <strong>每⼀个执⾏线程都有⼀⽚⾃⼰所属的栈内存空间。</strong> 进⾏⽅法的压栈和弹栈。</p><p><img src="/./../images/%E7%BA%BF%E7%A8%8B%E6%A6%82%E5%BF%B5/4ca6edb2d08940918ea684aa24e528dc.png"></p><p>当执⾏线程的任务结束了，线程⾃动在栈内存中释放了。但是当 <strong>所有的执⾏线程</strong> 都结束了（“前置”线程结束了），进程才结束了。</p><h2 id="2-2-Thread类"><a href="#2-2-Thread类" class="headerlink" title="2.2 Thread类"></a>2.2 Thread<strong>类</strong></h2><p>在上⼀章内容中我们已经可以完成最基本的线程开启，那么在我们完成操作过程中⽤到了 java.lang.Thread 类， API 中该类中定义了有关线程的⼀些⽅法，具体如下：</p><p><strong>构造⽅法：</strong></p><ul><li>public Thread() ：分配⼀个新的线程对象。</li><li>public Thread(String name) ：分配⼀个指定名字的新的线程对象。</li><li>public Thread(Runnable target) ：分配⼀个带有指定⽬标新的线程对象。</li><li>public Thread(Runnable target, String name) ：分配⼀个带有指定⽬标新的线程对象并指定名字。</li></ul><p><strong>常⽤⽅法：</strong></p><ul><li>public String getName() ：获取当前线程名称。</li><li>public void start() ：导致此线程开始执⾏；Java虚拟机调⽤此线程的run⽅法。</li><li>public void run() ：此线程要执⾏的任务在此处定义代码。</li><li>public static void sleep(long millis) ：使当前正在执⾏的线程以指定的毫秒数暂停（暂时停⽌执⾏）。</li><li>public static Thread currentThread() ：返回对当前正在执⾏的线程对象的引⽤。</li></ul><p>翻阅 API 后得知创建线程的⽅式总共有两种，⼀种是继承 Thread 类⽅式，⼀种是实现 Runnable 接⼝⽅式，⽅式⼀我们上⼀章已经完成，接下来讲解⽅式⼆实现的⽅式。</p><h2 id="2-3-创建线程⽅式⼆"><a href="#2-3-创建线程⽅式⼆" class="headerlink" title="2.3 创建线程⽅式⼆"></a>2.3 <strong>创建线程⽅式⼆</strong></h2><p>采⽤ java.lang.Runnable 也是⾮常常⻅的⼀种，我们只需要重写 run ⽅法即可。</p><p>步骤如下：</p><p>1. 定义 Runnable 接⼝的实现类，并重写该接⼝的 run() ⽅法，该 run() ⽅法的⽅法体同样是该线程的线程执⾏体。</p><p>2. 创建 Runnable 实现类的实例，并以此实例作为 Thread 的 target 来创建 Thread 对象，该 Thread 对象才是 真正的线程对象。</p><p>3. 调⽤线程对象的 start() ⽅法来启动线程。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line"> System.out.println(Thread.currentThread().getName() + <span class="string">&quot; &quot;</span> + i);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> <span class="comment">// 创建⾃定义类对象 线程任务对象</span></span><br><span class="line"> <span class="type">MyRunnable</span> <span class="variable">mr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line"> <span class="comment">// 创建线程对象</span></span><br><span class="line"> <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(mr, <span class="string">&quot;⼩强&quot;</span>);</span><br><span class="line"> t.start();</span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line"> System.out.println(<span class="string">&quot;旺财 &quot;</span> + i);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过实现 Runnable 接⼝，使得该类有了多线程类的特征。 run() ⽅法是多线程程序的⼀个执⾏⽬标。所有的多线程代码都在 run ⽅法⾥⾯。 Thread 类实际上也是实现了 Runnable 接⼝的类。</p><p>在启动的多线程的时候，需要先通过 Thread 类的构造⽅法 Thread(Runnable target) 构造出对象，然后调⽤Thread 对象的 start() ⽅法来运⾏多线程代码。</p><p>实际上所有的多线程代码都是通过运⾏ Thread 的 start() ⽅法来运⾏的。因此，不管是继承 Thread 类还是实现 Runnable 接⼝来实现多线程，最终还是通过 Thread 的对象的 API 来控制线程的，熟悉 Thread 类的 API 是进⾏多线程编程的基础。</p><blockquote><p>Tips ： Runnable 对象仅仅作为 Thread 对象的 target ， Runnable 实现类⾥包含的 run() ⽅法仅作为线程 执⾏体。⽽实际的线程对象依然是 Thread 实例，只是该 Thread 线程负责执⾏其 target 的 run() ⽅法。</p></blockquote><h2 id="2-4-Thread-和-Runnable-的区别"><a href="#2-4-Thread-和-Runnable-的区别" class="headerlink" title="2.4 Thread 和 Runnable 的区别"></a>2.4 Thread <strong>和</strong> Runnable <strong>的区别</strong></h2><p>如果⼀个类继承 Thread ，则不适合资源共享。但是如果实现了 Runable 接⼝的话，则很容易的实现资源共享。</p><p><strong>总结：</strong></p><p><strong>实现</strong> Runnable <strong>接⼝⽐继承</strong> Thread <strong>类所具有的优势：</strong></p><p>1. 适合多个相同的程序代码的线程去<strong>共享</strong>同⼀个资源。</p><p>2. 可以避免 java 中的单继承的局限性。</p><p>3. 增加程序的健壮性，实现解耦操作，代码可以被多个线程共享，代码和线程独⽴。</p><p>4. 线程池只能放⼊实现 Runable 或 Callable 类线程，不能直接放⼊继承 Thread 的类。</p><blockquote><p>扩充：在 java 中，每次程序运⾏⾄少启动 2 个线程。⼀个是 main 线程，⼀个是垃圾收集（GC）线程。因为 每当使⽤ java 命令执⾏⼀个类的时候，实际上都会启动⼀个 JVM ，每⼀个 JVM 其实在就是在操作系 统中启动了⼀个进程。</p></blockquote><h2 id="2-5-匿名内部类⽅式实现线程的创建"><a href="#2-5-匿名内部类⽅式实现线程的创建" class="headerlink" title="2.5 匿名内部类⽅式实现线程的创建"></a>2.5 <strong>匿名内部类⽅式实现线程的创建</strong></h2><p>使⽤线程的匿名内部类⽅式，可以⽅便的实现每个线程执⾏不同的线程任务操作。</p><p>使⽤匿名内部类的⽅式实现 Runnable 接⼝，重写 Runnable 接⼝中的 run ⽅法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NoNameInnerClassThread</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">// new Runnable() &#123;</span></span><br><span class="line"><span class="comment">// public void run() &#123;</span></span><br><span class="line"><span class="comment">// for (int i = 0; i &lt; 20; i++) &#123;</span></span><br><span class="line"><span class="comment">// System.out.println(&quot;张宇:&quot; + i);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// &#125;; //---这个整体 相当于new MyRunnable()</span></span><br><span class="line"> <span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line"> System.out.println(<span class="string">&quot;张宇:&quot;</span> + i);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">new</span> <span class="title class_">Thread</span>(r).start();</span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line"> System.out.println(<span class="string">&quot;费⽟清:&quot;</span> + i);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-线程安全"><a href="#3-线程安全" class="headerlink" title="3 线程安全"></a>3 <strong>线程安全</strong></h2><hr><h2 id="3-1-线程安全"><a href="#3-1-线程安全" class="headerlink" title="3.1 线程安全"></a>3.1 <strong>线程安全</strong></h2><p>如果有多个线程在同时运⾏，⽽这些线程可能会同时运⾏这段代码。程序每次运⾏结果和单线程运⾏的结果是⼀样的，⽽且其他的变量的值也和预期的是⼀样的，就是线程安全的。</p><p>我们通过⼀个案例，演示线程的安全问题：</p><p>电影院要卖票，我们模拟电影院的卖票过程。假设要播放的电影是 “ 葫芦娃⼤战奥特曼 ” ，本次电影的座位 共 100 个（本场电影只能卖 100 张票）。</p><p>我们来模拟电影院的售票窗⼝，实现多个窗⼝同时卖 “ 葫芦娃⼤战奥特曼 ” 这场电影票（多个窗⼝⼀起卖这100 张票）</p><p>需要窗⼝，采⽤线程对象来模拟；需要票， Runnable 接⼝⼦类来模拟</p><p>模拟票：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Ticket</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"> <span class="keyword">private</span> <span class="type">int</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 执⾏卖票操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"> <span class="comment">// 每个窗⼝卖票的操作</span></span><br><span class="line"> <span class="comment">// 窗⼝ 永远开启</span></span><br><span class="line"> <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"> <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;<span class="comment">// 有票 可以卖</span></span><br><span class="line"> <span class="comment">// 出票操作</span></span><br><span class="line"> <span class="comment">// 使⽤sleep模拟⼀下出票时间</span></span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line"> Thread.sleep(<span class="number">100</span>);</span><br><span class="line"> &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"> e.printStackTrace();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 获取当前线程对象的名字</span></span><br><span class="line"> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line"> System.out.println(name + <span class="string">&quot;正在卖:&quot;</span> + ticket--);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> <span class="comment">// 创建线程任务对象</span></span><br><span class="line"> <span class="type">Ticket</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Ticket</span>();</span><br><span class="line"> <span class="comment">// 创建三个窗⼝对象</span></span><br><span class="line"> <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ticket, <span class="string">&quot;窗⼝1&quot;</span>);</span><br><span class="line"> <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ticket, <span class="string">&quot;窗⼝2&quot;</span>);</span><br><span class="line"> <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ticket, <span class="string">&quot;窗⼝3&quot;</span>);</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 同时卖票</span></span><br><span class="line"> t1.start();</span><br><span class="line"> t2.start();</span><br><span class="line"> t3.start();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 结果中有⼀部分这样现象：</p><p><img src="/./../images/%E7%BA%BF%E7%A8%8B%E6%A6%82%E5%BF%B5/07fb6c6b02834c86b4b6e679bbc7f8bb.png"></p><p>发现程序出现了两个问题：</p><p>1. 相同的票数，⽐如 2 这张票被卖了两回。</p><p>2. 不存在的票，⽐如 0 票与 -1 票，是不存在的。</p><p>这种问题，⼏个窗⼝（线程）票数不同步了，这种问题称为线程安全性问题。</p><blockquote><p>线程安全问题都是由全局变量及静态变量引起的。若每个线程中对全局变量、静态变量只有读操作，⽽⽆写操作，⼀般来说，这个全局变量是线程安全的；若有多个线程同时执⾏写操作，⼀般都需要考 虑线程同步，否则的话就可能影响线程安全。</p></blockquote><h2 id="3-2-线程同步"><a href="#3-2-线程同步" class="headerlink" title="3.2 线程同步"></a>3.2 <strong>线程同步</strong></h2><p>当我们使⽤多个线程访问同⼀资源的时候，且多个线程中对资源有写的操作，就容易出现线程安全问题。</p><p>要解决上述多线程并发访问⼀个资源的安全性问题：也就是解决重复票与不存在票问题， Java 中提供了同 步机制 <strong>（</strong> synchronized <strong>）</strong> 来解决。</p><p>根据案例简述：</p><blockquote><p>窗⼝1线程进⼊操作的时候，窗⼝2和窗⼝3线程只能在外等着，窗⼝1操作结束，窗⼝1和窗⼝2和窗⼝3才有机会进⼊代码去执⾏。也就是说在某个线程修改共享资源的时候，其他线程不能修改该资源，等待修改完毕同步之后，才能去抢夺CPU资源，完成对应的操作，保证了数据的同步性，解决了线程不安全的现象。</p></blockquote><p>为了保证每个线程都能正常执⾏原⼦操作， Java 引⼊了线程同步机制。</p><p>那么怎么去使⽤呢？有三种⽅式完成同步操作：</p><p>1. 同步代码块。</p><p>2. 同步⽅法。</p><p>3. 锁机制。</p><h2 id="3-3-同步代码块"><a href="#3-3-同步代码块" class="headerlink" title="3.3 同步代码块"></a>3.3 <strong>同步代码块</strong></h2><ul><li><strong>同步代码块：</strong> synchronized 关键字可以⽤于⽅法中的某个区块中，表示只对这个区块的资源实⾏互斥访问。</li></ul><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(同步锁) &#123;</span><br><span class="line"> 需要同步操作的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>同步锁：</strong></p><p>对象的同步锁只是⼀个概念，可以想象为在对象上标记了⼀个锁。</p><p>1. 锁对象，可以是任意类型。</p><p>2. 多个线程对象，要使⽤同⼀把锁。</p><blockquote><p>注意：在任何时候，最多允许⼀个线程拥有同步锁，谁拿到锁就进⼊代码块，其他的线程只能在外等 着（ BLOCKED ）。</p></blockquote><p>使⽤同步代码块解决代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Ticket</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"> <span class="keyword">private</span> <span class="type">int</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 执⾏卖票操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"> <span class="comment">// 每个窗⼝卖票的操作</span></span><br><span class="line"> <span class="comment">// 窗⼝ 永远开启</span></span><br><span class="line"> <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"> <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line"> <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123; <span class="comment">// 有票 可以卖</span></span><br><span class="line"> <span class="comment">// 出票操作</span></span><br><span class="line"> <span class="comment">// 使⽤sleep模拟⼀下出票时间</span></span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line"> Thread.sleep(<span class="number">50</span>);</span><br><span class="line"> &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"> e.printStackTrace();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 获取当前线程对象的名字</span></span><br><span class="line"> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line"> System.out.println(name + <span class="string">&quot;正在卖: &quot;</span> + ticket--);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当使⽤了同步代码块后，上述的线程的安全问题，解决了。</p><h2 id="3-4-同步⽅法"><a href="#3-4-同步⽅法" class="headerlink" title="3.4 同步⽅法"></a>3.4 <strong>同步⽅法</strong></h2><ul><li><strong>同步⽅法：</strong>使⽤ synchronized 修饰的⽅法，就叫做同步⽅法，保证A线程执⾏该⽅法的时候，其他线程只能在⽅法外等着。</li></ul><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line"> 可能会产⽣线程安全问题的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>同步锁是谁？</p><p>对于⾮ static ⽅法，同步锁就是 this 。</p><p>对于 static ⽅法，我们使⽤当前⽅法所在类的字节码对象（类名 .class ）。</p></blockquote><p>使⽤同步⽅法代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Ticket</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"> <span class="keyword">private</span> <span class="type">int</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 执⾏卖票操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"> <span class="comment">// 每个窗⼝卖票的操作</span></span><br><span class="line"> <span class="comment">// 窗⼝ 永远开启</span></span><br><span class="line"> <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"> sellTicket();</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 锁对象 是 谁调⽤这个⽅法 就是谁</span></span><br><span class="line"><span class="comment"> * 隐含 锁对象 就是 this</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sellTicket</span><span class="params">()</span> &#123;</span><br><span class="line"> <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123; <span class="comment">// 有票 可以卖</span></span><br><span class="line"> <span class="comment">// 出票操作</span></span><br><span class="line"> <span class="comment">// 使⽤sleep模拟⼀下出票时间</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"> Thread.sleep(<span class="number">100</span>);</span><br><span class="line"> &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"> e.printStackTrace();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 获取当前线程对象的名字</span></span><br><span class="line"> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line"> System.out.println(name + <span class="string">&quot;正在卖:&quot;</span> + ticket--);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-5-Lock锁"><a href="#3-5-Lock锁" class="headerlink" title="3.5 Lock锁"></a>3.5 Lock<strong>锁</strong></h2><p>java.util.concurrent.locks.Lock 机制提供了⽐ synchronized 代码块和 synchronized ⽅法更⼴泛的</p><p>锁定操作，同步代码块 &#x2F; 同步⽅法具有的功能 Lock 都有，除此之外更强⼤，更体现⾯向对象。</p><p>Lock 锁也称同步锁，创建对象 Lock lock &#x3D; new ReentrantLock() ，加锁与释放锁⽅法如下：</p><ul><li>public void lock() ：加同步锁。</li><li>public void unlock() ：释放同步锁。</li></ul><p>使⽤如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Ticket</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"> <span class="keyword">private</span> <span class="type">int</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"> </span><br><span class="line"> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 执⾏卖票操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"> <span class="comment">// 每个窗⼝卖票的操作</span></span><br><span class="line"> <span class="comment">// 窗⼝ 永远开启</span></span><br><span class="line"> <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"> lock.lock();</span><br><span class="line"> <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123; <span class="comment">// 有票 可以卖</span></span><br><span class="line"> <span class="comment">// 出票操作</span></span><br><span class="line"> <span class="comment">// 使⽤sleep模拟⼀下出票时间</span></span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line"> Thread.sleep(<span class="number">50</span>);</span><br><span class="line"> &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"> e.printStackTrace();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 获取当前线程对象的名字</span></span><br><span class="line"> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">System.out.println(name + <span class="string">&quot;正在卖:&quot;</span> + ticket--);</span><br><span class="line"> &#125;</span><br><span class="line"> lock.unlock();</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-线程状态"><a href="#4-线程状态" class="headerlink" title="4 线程状态"></a>4 <strong>线程状态</strong></h2><hr><h2 id="4-1-线程状态概述"><a href="#4-1-线程状态概述" class="headerlink" title="4.1 线程状态概述"></a>4.1 <strong>线程状态概述</strong></h2><p>当线程被创建并启动以后，它既不是⼀启动就进⼊了执⾏状态，也不是⼀直处于执⾏状态。在线程的⽣命 周期中，有⼏种状态呢？在 API 中 java.lang.Thread.State 这个枚举中给出了六种线程状态：</p><p>这⾥先列出各个线程状态发⽣的条件，下⾯将会对每种状态进⾏详细解析</p><p><img src="/./../images/%E7%BA%BF%E7%A8%8B%E6%A6%82%E5%BF%B5/427c9cba8c5c40868d7ee42ef77f945c.png"></p><p>我们不需要去研究这⼏种状态的实现原理，我们只需知道在做线程操作中存在这样的状态。那我们怎么去理解这⼏个状态呢，新建与被终⽌还是很容易理解的，我们就研究⼀下线程从 Runnable （可运⾏）状态与 ⾮运⾏状态之间的转换问题。</p><h2 id="4-2-Timed-Waiting（计时等待）"><a href="#4-2-Timed-Waiting（计时等待）" class="headerlink" title="4.2 Timed Waiting（计时等待）"></a>4.2 Timed Waiting<strong>（计时等待）</strong></h2><p>Timed Waiting 在 API 中的描述为：⼀个正在限时等待另⼀个线程执⾏⼀个（唤醒）动作的线程处于这⼀状态。单独的去理解这句话，真是⽞之⼜⽞，其实我们在之前的操作中已经接触过这个状态了，在哪⾥呢？</p><p>在我们写卖票的案例中，为了减少线程执⾏太快，现象不明显等问题，我们在 run ⽅法中添加了 sleep 语句，这样就强制当前正在执⾏的线程休眠 <strong>（暂停执⾏）</strong> ，以 “ 减慢线程 ” 。</p><p>其实当我们调⽤了 sleep ⽅法之后，当前执⾏的线程就进⼊到 “ 休眠状态 ” ，其实就是所谓的 Timed Waiting（计时等待），那么我们通过⼀个案例加深对该状态的⼀个理解。</p><p><strong>实现⼀个计数器，计数到</strong> 100 <strong>，在每个数字之间暂停</strong> 1 <strong>秒，每隔</strong> 10 <strong>个数字输出⼀个字符串</strong></p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line"> <span class="keyword">if</span> ((i) % <span class="number">10</span> == <span class="number">0</span>) &#123;</span><br><span class="line"> System.out.println(<span class="string">&quot;-------&quot;</span> + i);</span><br><span class="line"> &#125;</span><br><span class="line"> System.out.print(i);</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line"> Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"> System.out.print(<span class="string">&quot; 线程睡眠1秒!\n&quot;</span>);</span><br><span class="line"> &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"> e.printStackTrace(); &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> <span class="keyword">new</span> <span class="title class_">MyThread</span>().start();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过案例可以发现， sleep ⽅法的使⽤还是很简单的。我们需要记住下⾯⼏点：</p><p>1. 进⼊ TIMED_WAITING 状态的⼀种常⻅情形是调⽤的 sleep ⽅法，单独的线程也可以调⽤，不⼀定⾮要有协作关系。</p><p>2. 为了让其他线程有机会执⾏，可以将 Thread.sleep() 的调⽤ <strong>放线程</strong> run() <strong>之内</strong> 。这样才能保证该线程执⾏过程中会睡眠。</p><p>3. sleep 与锁⽆关，线程睡眠到期⾃动苏醒，并返回到 Runnable （可运⾏）状态。</p><blockquote><p>⼩提示： sleep() 中指定的时间是线程不会运⾏的最短时间。因此， sleep() ⽅法不能保证该线程睡眠到期后就开始⽴刻执⾏。</p></blockquote><p> Timed Waiting 线程状态图：</p><p><img src="/./../images/%E7%BA%BF%E7%A8%8B%E6%A6%82%E5%BF%B5/551ded046dba4f308b8683983e2deff6.png"></p><h2 id="4-3-BLOCKED（锁阻塞）"><a href="#4-3-BLOCKED（锁阻塞）" class="headerlink" title="4.3 BLOCKED（锁阻塞）"></a>4.3 BLOCKED<strong>（锁阻塞）</strong></h2><p>Blocked 状态在 API 中的介绍为：⼀个正在阻塞等待⼀个监视器锁（锁对象）的线程处于这⼀状态。</p><p>我们已经学完同步机制，那么这个状态是⾮常好理解的了。⽐如，线程 A 与线程 B 代码中使⽤同⼀锁，如果 线程 A 获取到锁，线程 A 进⼊到 Runnable 状态，那么线程 B 就进⼊到 Blocked 锁阻塞状态。</p><p>这是由 Runnable 状态进⼊ Blocked 状态。除此 Waiting 以及 Time Waiting 状态也会在某种情况下进⼊阻塞状态，⽽这部分内容作为扩充知识点带领⼤家了解⼀下。</p><p>Blocked 线程状态图：</p><p><img src="/./../images/%E7%BA%BF%E7%A8%8B%E6%A6%82%E5%BF%B5/5c9b1865b4094e36860d96cd627f5521.png"></p><h2 id="4-4-Waiting（⽆限等待）"><a href="#4-4-Waiting（⽆限等待）" class="headerlink" title="4.4 Waiting（⽆限等待）"></a>4.4 Waiting<strong>（⽆限等待）</strong></h2><p>Wating 状态在 API 中介绍为：⼀个正在⽆限期等待另⼀个线程执⾏⼀个特别的（唤醒）动作的线程处于这⼀状态。</p><p>那么我们之前遇到过这种状态吗？答案是并没有，但并不妨碍我们进⾏⼀个简单深⼊的了解。我们通过⼀段代码来学习⼀下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WaitingTest</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> <span class="comment">// 演示waiting</span></span><br><span class="line"> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"> <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"> <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line"> System.out.println(Thread.currentThread().getName() + <span class="string">&quot;=== 获取到锁对</span></span><br><span class="line"><span class="string">象，调⽤wait⽅法，进⼊waiting状态，释放锁对象&quot;</span>);</span><br><span class="line"> obj.wait(); <span class="comment">// ⽆限等待</span></span><br><span class="line"> <span class="comment">// obj.wait(5000); // 计时等待, 5秒 时间到，⾃动醒来</span></span><br><span class="line"> &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"> e.printStackTrace();</span><br><span class="line"> &#125;</span><br><span class="line"> System.out.println(Thread.currentThread().getName() + <span class="string">&quot;=== 从waiting状态</span></span><br><span class="line"><span class="string">醒来，获取到锁对象，继续执⾏了&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;, <span class="string">&quot;等待线程&quot;</span>).start();</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// while (true) &#123; // 每隔3秒 唤醒⼀次</span></span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line"> System.out.println(Thread.currentThread().getName() + <span class="string">&quot;----- 等待3秒 钟&quot;</span>);</span><br><span class="line"> Thread.sleep(<span class="number">3000</span>);</span><br><span class="line"> &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"> e.printStackTrace();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line"> System.out.println(Thread.currentThread().getName() + <span class="string">&quot;----- 获取到锁对</span></span><br><span class="line"><span class="string">象,调⽤notify⽅法，释放锁对象&quot;</span>);</span><br><span class="line"> obj.notify();</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"> &#125;, <span class="string">&quot;唤醒线程&quot;</span>).start();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上述案例我们会发现，⼀个调⽤了某个对象的 Object.wait ⽅法的线程会等待另⼀个线程调⽤此对象的Object.notify() ⽅法 或 Object.notifyAll() ⽅法。</p><p>其实 waiting 状态并不是⼀个线程的操作，它体现的是多个线程间的通信，可以理解为多个线程之间的协作关系，多个线程会争取锁，同时相互之间⼜存在协作关系。就好⽐在公司⾥你和你的同事们，你们可能 存在晋升时的竞争，但更多时候你们更多是⼀起合作以完成某些任务。</p><p>当多个线程协作时，⽐如 A ， B 线程，如果 A 线程在 Runnable （可运⾏）状态中调⽤了 wait() ⽅法那么 A 线程 就进⼊了 Waiting （⽆限等待）状态，同时失去了同步锁。假如这个时候 B 线程获取到了同步锁，在运⾏状 态中调⽤了 notify() ⽅法，那么就会将⽆限等待的 A 线程唤醒。注意是唤醒，如果获取到锁对象，那么 A 线 程唤醒后就进⼊ Runnable （可运⾏）状态；如果没有获取锁对象，那么就进⼊到 Blocked （锁阻塞状 态）。</p><p>Waiting 线程状态图：</p><p><img src="/./../images/%E7%BA%BF%E7%A8%8B%E6%A6%82%E5%BF%B5/3bcf9d03b38a4ecea57edaf5fb799fe8.png"></p><blockquote><p>⼀条有意思的 Tips ：</p><p>我们在翻阅 API 的时候会发现 Timed Waiting （计时等待）与 Waiting （⽆限等待）状态联系还是很紧密的，⽐如 Waiting （⽆限等待）状态中 wait ⽅法是空参的，⽽ Timed Waiting （计时等待）中 wait ⽅ 法是带参的。这种带参的⽅法，其实是⼀种倒计时操作，相当于我们⽣活中的⼩闹钟，我们设定好时 间，到时通知，可是如果提前得到（唤醒）通知，那么设定好时间再通知也就显得多此⼀举了，那么 这种设计⽅案其实是⼀举两得。如果没有得到（唤醒）通知，那么线程就处于 Timed Waiting 状态， 直到倒计时完毕⾃动醒来；如果在倒计时期间得到（唤醒）通知，那么线程从 Timed Waiting 状态⽴</p><p>刻唤醒。</p></blockquote><h2 id="4-5-练习"><a href="#4-5-练习" class="headerlink" title="4.5 练习"></a>4.5 <strong>练习</strong></h2><p><strong>线程通信：练习1</strong></p><p>需求：两个线程</p><p>线程1：图片的加载  1%~100%</p><p>线程2：图片的显示  显示</p><p>同时开启线程</p><p>线程2 等待 线程1 结束后在执行，</p><p>在线程2中使用 线程1.join() -&gt; 线程2 进入阻塞状态</p><p>采用匿名内部类的方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">          <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">              System.out.println(<span class="string">&quot;开始加载...&quot;</span>);</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">              &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                  e.printStackTrace();</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">                  System.out.println(<span class="string">&quot;已加载&quot;</span> + i + <span class="string">&quot;%&quot;</span>);</span><br><span class="line">                  <span class="keyword">try</span> &#123;</span><br><span class="line">                      Thread.sleep((<span class="type">long</span>) (Math.random() * <span class="number">1000</span>));</span><br><span class="line">                  &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                      e.printStackTrace();</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              System.out.println(<span class="string">&quot;结束加载&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    t1.join();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;等待加载中。。。&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;显示图片&quot;</span>);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>线程通信：练习2</strong></p><p> 需求: 两个线程<br>       线程1: 图片的加载   1% ~ 100% (等待图片显示)  图片的下载 1%~100%<br>       线程2: 图片的显示<br>       同时开启线程: 显示之前 需要等待 加载完成<br>                   显示后 才能开始下载</p><p>wait(long): 等待指定的时间毫秒值<br>wait(): 无限等待, 可以被唤醒 notify()  notifyAll()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreadDemo4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();<span class="comment">//这是用来做加锁的工具的, 此案例中什么意义都没有</span></span><br><span class="line">        <span class="type">LoadThread</span> <span class="variable">load</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LoadThread</span>(obj);</span><br><span class="line">        <span class="type">ShowThread</span> <span class="variable">showT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShowThread</span>(obj);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">show</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(showT);</span><br><span class="line"></span><br><span class="line">        load.start();</span><br><span class="line">        show.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LoadThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object obj;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LoadThread</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开始加载...&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;已加载&quot;</span> + i + <span class="string">&quot;%&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep((<span class="type">long</span>) (Math.random() * <span class="number">300</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;结束加载&quot;</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (obj)&#123;</span><br><span class="line">            obj.notify();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (obj)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                obj.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;开始下载...&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;已下载&quot;</span> + i + <span class="string">&quot;%&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep((<span class="type">long</span>) (Math.random() * <span class="number">300</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;结束下载&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ShowThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object obj;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ShowThread</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//                try &#123;</span></span><br><span class="line"><span class="comment">//                    t1.join();</span></span><br><span class="line"><span class="comment">//                &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">//                    e.printStackTrace();</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line">        System.out.println(<span class="string">&quot;等待加载中。。。&quot;</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                obj.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;显示图片&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (obj)&#123;</span><br><span class="line">            obj.notify();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-小结"><a href="#5-小结" class="headerlink" title="5 小结"></a>5 小结</h2><p>到此为⽌我们已经对线程状态有了基本的认识，想要有更多的了解，详情可以⻅下图：</p><p><img src="/./../images/%E7%BA%BF%E7%A8%8B%E6%A6%82%E5%BF%B5/fa8531e5439e4bb28396bf544301c41c.png"></p><p><img src="/./../images/%E7%BA%BF%E7%A8%8B%E6%A6%82%E5%BF%B5/fa49df3f19e24c70aa5d46ba3040e9a6.png"></p><blockquote><p><strong>多线程:</strong> 父类 Thread<br><strong>程序:</strong> 软件, 工程<br><strong>进程:</strong> 正在运行的程序<br><strong>线程:</strong> 进程中的任务单位</p><p>CPU 可以”同时”处理多个线程<br><strong>并行:</strong> 同一时刻, 同时运行, 通常需要多核处理器<br><strong>并发:</strong> 多线程, 交替执行(交替速度足够快, 看起来是同时)</p><h3 id="实现多线程"><a href="#实现多线程" class="headerlink" title="实现多线程:"></a>实现多线程:</h3><p>main -&gt; 一个线程<br>执行多线程: 随机性</p><p><strong>方式一: 只能继承一个类, 功能性单一</strong><br>1.自定义类, 继承Thread<br>2.重写run方法<br>3.在主程序中创建线程对象<br>4.开启线程 start()</p><p><strong>方式二: 实现接口</strong><br>1.自定义类, 实现Runnable接口<br>2.实现run方法<br>3.创建线程对象  ※  使用Runnable对象来构造<br>4.开启线程 start</p><p><strong>方式三: 匿名内部类</strong></p><p>Thread 基础的API:<br>String getName(): Thread 属性 name<br>static Thread currentThread(): 获得当前线程对象<br>static void sleep(long time): 当前线程的阻塞时间</p><p><strong>线程的状态:</strong><br>见图</p><p><strong>线程安全:</strong> 多个线程共享资源<br><strong>解决安全:</strong> 实现线程同步<br>   <strong>加锁:</strong> 同步锁  synchronized, 需要借助一个对象<br>        Lock锁  接口  实现类 ReentrantLock()<br>           上锁 lock()  解锁 unlock()</p><p><strong>线程其他属性和方法:</strong><br>setPriority(1-10越来越大): 设置优先级, 提升了这个线程的执行概率<br>setDaemon(true): 设置守护线程, 所有的”前置”线程结束, 守护线程也将自动结束<br>               GC -&gt; 垃圾回收(守护线程)<br>               System.gc() -&gt; 手动清理</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;1-多线程&quot;&gt;&lt;a href=&quot;#1-多线程&quot; class=&quot;headerlink&quot; title=&quot;1 多线程&quot;&gt;&lt;/a&gt;1 &lt;strong&gt;多线程&lt;/strong&gt;&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;我们在之前，学习的程序在没有跳转语句的前提下，</summary>
      
    
    
    
    <category term="Java基础" scheme="https://wx51815.github.io/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Java" scheme="https://wx51815.github.io/tags/Java/"/>
    
    <category term="线程" scheme="https://wx51815.github.io/tags/%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>集合</title>
    <link href="https://wx51815.github.io/page/Java%E5%9F%BA%E7%A1%80/%E9%9B%86%E5%90%88/"/>
    <id>https://wx51815.github.io/page/Java%E5%9F%BA%E7%A1%80/%E9%9B%86%E5%90%88/</id>
    <published>2023-05-09T07:23:31.000Z</published>
    <updated>2023-06-10T07:50:13.037Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1 - 概述"></a>1 - 概述</h2><pre><code>    所有的集合类和集合接口都在java.util包下。    在内存中申请一块空间用来存储数据，在Java中集合就是替换掉定长的数组的一种**引用数据类型**。</code></pre><h2 id="2-集合与数组的区别"><a href="#2-集合与数组的区别" class="headerlink" title="2 - 集合与数组的区别"></a>2 - 集合与数组的区别</h2><p>长度区别</p><pre><code>    数组长度固定，定义长了造成内存空间的浪费，定义短了不够用。    集合大小可以变，用多少空间拿多少空间。</code></pre><p>内容区别</p><pre><code>    数组可以存储基本数据类型和引用数据类型    集合中能存储引用数据类型（存储的为对象的内存地址）   list.add(100);//为自动装箱，100为Integer包装的</code></pre><p>元素区别</p><pre><code>    数组中只能存储同一种类型成员    集合中可以存储不同类型数据（一般情况下也只存储同一种类型的数据）</code></pre><p>集合结构</p><pre><code>    在java中每一个不同的集合，底层会对应不同的数据结构。往不同的集合中  存储元素，等于将数据放到了不同的数据结构当中。什么是数据结构？数据存储的  结构就是数据结构。不同的数据结构，数据存储方式不同。</code></pre><ul><li><p>单列集合 <strong>Collection</strong></p><ul><li><p><strong>List</strong>可以重复：<em>ArrayList&#x2F;LinkedList</em></p></li><li><p><strong>Set</strong>不可重复：<em>HashSet&#x2F;TreeSet</em></p></li><li><p><img src="/./../images/%E9%9B%86%E5%90%88/7365658cde9840a5aa4cf2dcc0de115b.png"></p><hr><p>（大量文字插入会导致图片不清，所以在此进行更详细的描述）</p></li><li><p>List特点：此处顺序并不是大小顺序，而是存入数据的先后顺序。有序因为List集合都有下标，下标从0开始，以递增。</p></li><li><p>Set特点：取出顺序不一定为存入顺序，另外Set集合没有下标。</p></li><li><p>ArrayList是非线程安全的。</p></li><li><p>HashSet集合在new的时候，底层实际上new了一个HashMap集合。向HashSet集合中存储元素，实际上是存储到了HashMap的key中了。HashMap集合是一个Hash表数据结构。</p></li><li><p>SortedSet集合存储元素的特点：由于继承了Set集合，所以他的特点也是无序不可重复，但是放在SortedSet集合中的元素可以自动排序。放到该集合中的元素是自动按照大小顺序排序的。</p></li><li><p>TreeSet集合底层实际上是TreeMap。TreeSet集合在new的时候，底层实际上new了一个TreeMap集合。向TreeSet集合中存储元素，实际上是存储到了TreeMap的key中了。TreeMap集合是一个二叉树数据结构。</p></li></ul></li><li><p>双列集合<strong>Map</strong>:<em>HashMap&#x2F;TreeMap</em></p></li></ul><p><img src="/./../images/%E9%9B%86%E5%90%88/d64de167f8ec4e32b9a03b28995e3c7e.png"></p><blockquote><p>粗体是接口 斜体是实现类</p></blockquote><h2 id="3-Collection集合"><a href="#3-Collection集合" class="headerlink" title="3 - Collection集合"></a>3 - Collection集合</h2><h2 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 - 概述"></a>3.1 - 概述</h2><blockquote><p>单列集合的顶层接口，既然是接口就不能直接使用，需要通过实现类！~</p></blockquote><h2 id="3-2-Collection集合的的常用方法"><a href="#3-2-Collection集合的的常用方法" class="headerlink" title="3.2 - Collection集合的的常用方法"></a>3.2 - Collection集合的的常用方法</h2><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td><code>boolean add(E e)</code></td><td>添加元素到集合的末尾（追加）</td></tr><tr><td><code>boolean remove(Object o)</code></td><td>删除指定的元素，成功则返回true（底层调用equles）</td></tr><tr><td><code>void clear()</code></td><td>清空集合</td></tr><tr><td><code>boolean contains(Object o)</code></td><td>判断元素在集合中是否存在，存在则返回true（底层调用equles）</td></tr><tr><td><code>boolean isEmpty()</code></td><td>判断集合是否为空，空则返回true</td></tr><tr><td><code>int size()</code></td><td>返回集合中元素个数</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr.乐</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Collection_01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//父类的引用指向子类的对象，形成多态</span></span><br><span class="line">        Collection&lt;String&gt; con = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//追加的方式添加元素</span></span><br><span class="line">        con.add(<span class="string">&quot;东邪&quot;</span>);</span><br><span class="line">        con.add(<span class="string">&quot;西毒&quot;</span>);</span><br><span class="line">        con.add(<span class="string">&quot;南帝&quot;</span>);</span><br><span class="line">        con.add(<span class="string">&quot;北丐&quot;</span>);</span><br><span class="line">        con.add(<span class="string">&quot;中神通&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//删除,通过元素名称删除元素</span></span><br><span class="line">        System.out.println(con.remove(<span class="string">&quot;西毒&quot;</span>));</span><br><span class="line">        <span class="comment">//判断集合中是否包含指定参数元素</span></span><br><span class="line">        System.out.println(con.contains(<span class="string">&quot;西毒&quot;</span>));  <span class="comment">//false</span></span><br><span class="line">        System.out.println(con.contains(<span class="string">&quot;东邪&quot;</span>));    <span class="comment">//true</span></span><br><span class="line">        <span class="comment">//获取集合中元素个数</span></span><br><span class="line">        System.out.println(con.size());</span><br><span class="line">        <span class="comment">//判断是否为空</span></span><br><span class="line">        System.out.println(con.isEmpty());<span class="comment">//false</span></span><br><span class="line">        <span class="comment">//清空集合</span></span><br><span class="line">        con.clear();</span><br><span class="line">        <span class="comment">//判断是否为空</span></span><br><span class="line">        System.out.println(con.isEmpty());<span class="comment">//true</span></span><br><span class="line">        System.out.println(con);<span class="comment">//打印集合的元素</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-3-Collection集合的遍历"><a href="#3-3-Collection集合的遍历" class="headerlink" title="3.3 - Collection集合的遍历"></a>3.3 - Collection集合的遍历</h2><pre><code>    以下迭代方式，是所有Collection通用的一种方式。在Map集合中不能使用，在所有的Collection以及子类中使用。</code></pre><p><img src="/./../images/%E9%9B%86%E5%90%88/26b76cbf738e4269a33a5ac417cd2113.png"></p><p><img src="/./../images/%E9%9B%86%E5%90%88/897cfae09c564d29824d231577c79b71.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr.乐</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>  Collection 集合的遍历</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Connection_02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//多态</span></span><br><span class="line">        Collection&lt;String&gt; con = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//添加元素</span></span><br><span class="line">        con.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        con.add(<span class="string">&quot;def&quot;</span>);</span><br><span class="line">        con.add(<span class="string">&quot;100&quot;</span>);</span><br><span class="line">        con.add(<span class="string">&quot;444&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Collection集合的遍历方式</span></span><br><span class="line">        <span class="comment">//因为没有索引的概念，所以Collection集合不能使用fori进行遍历</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//增强版for循环，其实底层使用的也是迭代器，在字节码文件中查看</span></span><br><span class="line">        <span class="keyword">for</span> (String str : con) &#123;</span><br><span class="line">            System.out.print(str + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();<span class="comment">//换行</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//迭代器，集合专属的遍历工具</span></span><br><span class="line">        Iterator&lt;String&gt; it = con.iterator();<span class="comment">//创建迭代器对象</span></span><br><span class="line">        <span class="keyword">while</span> (it.hasNext())&#123;<span class="comment">//判断下一个位置是否有元素</span></span><br><span class="line">            System.out.print(it.next() + <span class="string">&quot;\t&quot;</span>);<span class="comment">//获取到下一个位置的元素</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-4-Iterator的remove"><a href="#3-4-Iterator的remove" class="headerlink" title="3.4 -  Iterator的remove"></a>3.4 -  Iterator的remove</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr.乐</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Connection_remove</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建集合</span></span><br><span class="line">        <span class="type">Collection</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注意：此时获取的迭代器，指向的是那是集合中没有元素状态下的迭代器。</span></span><br><span class="line">        <span class="comment">// 一定要注意：集合结构只要发生改变，迭代器必须重新获取。</span></span><br><span class="line">        <span class="comment">// 当集合结构发生了改变，迭代器没有重新获取时，调用next()方法时：java.util.ConcurrentModificationException</span></span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">it</span> <span class="operator">=</span> c.iterator();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加元素</span></span><br><span class="line">        c.add(<span class="number">1</span>); <span class="comment">// Integer类型</span></span><br><span class="line">        c.add(<span class="number">2</span>);</span><br><span class="line">        c.add(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取迭代器</span></span><br><span class="line">        <span class="comment">//Iterator it = c.iterator();</span></span><br><span class="line">        <span class="comment">/*while(it.hasNext())&#123;</span></span><br><span class="line"><span class="comment">            // 编写代码时next()方法返回值类型必须是Object。</span></span><br><span class="line"><span class="comment">            // Integer i = it.next();</span></span><br><span class="line"><span class="comment">            Object obj = it.next();</span></span><br><span class="line"><span class="comment">            System.out.println(obj);</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Collection</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        c2.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        c2.add(<span class="string">&quot;def&quot;</span>);</span><br><span class="line">        c2.add(<span class="string">&quot;xyz&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">it2</span> <span class="operator">=</span> c2.iterator();</span><br><span class="line">        <span class="keyword">while</span>(it2.hasNext())&#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> it2.next();</span><br><span class="line">            <span class="comment">// 删除元素</span></span><br><span class="line">            <span class="comment">// 删除元素之后，集合的结构发生了变化，应该重新去获取迭代器</span></span><br><span class="line">            <span class="comment">// 但是，循环下一次的时候并没有重新获取迭代器，所以会出现异常：java.util.ConcurrentModificationException</span></span><br><span class="line">            <span class="comment">// 出异常根本原因是：集合中元素删除了，但是没有更新迭代器（迭代器不知道集合变化了）</span></span><br><span class="line">            <span class="comment">//c2.remove(o); // 直接通过集合去删除元素，没有通知迭代器。（导致迭代器的快照和原集合状态不同。）</span></span><br><span class="line">            <span class="comment">// 使用迭代器来删除可以吗？</span></span><br><span class="line">            <span class="comment">// 迭代器去删除时，会自动更新迭代器，并且更新集合（删除集合中的元素）。</span></span><br><span class="line">            it2.remove(); <span class="comment">// 删除的一定是迭代器指向的当前元素。</span></span><br><span class="line">            System.out.println(o);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(c2.size()); <span class="comment">//0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-List"><a href="#4-List" class="headerlink" title="4 -List"></a>4 -List</h2><p><code>原型ArrayList&lt;E&gt;</code></p><ul><li><p>ArrayList是一个List接口的实现类，底层使用的是一个可以调整大小的数组实现的。</p></li><li><p><code>&lt;E&gt;</code>:是一种特殊的数据类型（引用数据类型） – 泛型</p><ul><li>ArrayList<String> 或者 ArrayList<Integer> 或者 ArrayList<Student></li></ul></li></ul><h2 id="4-1-ArrayList构造和添加方法"><a href="#4-1-ArrayList构造和添加方法" class="headerlink" title="4.1 - ArrayList构造和添加方法"></a>4.1 - ArrayList构造和添加方法</h2><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td><code>public ArrayList&lt;E&gt;()</code></td><td>创建一个空集合</td></tr><tr><td><code>public boolean add(E e)</code></td><td>将指定的参数元素追加到集合的末尾</td></tr><tr><td><code>public void add(int index ,E e)</code></td><td>在集合的指定位置添加指定的元素（插入元素）</td></tr><tr><td><code>public void addAll(E object)</code></td><td>用于将指定集合中所有元素添加到当前集合中</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr.乐</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>  ArrayList构造和添加方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList_01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建空集合</span></span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();<span class="comment">//泛型定义为String</span></span><br><span class="line">        <span class="comment">//采用默认追加的方式添加元素</span></span><br><span class="line">        System.out.println(list.add(<span class="string">&quot;刘德华&quot;</span>));</span><br><span class="line">        System.out.println(list.add(<span class="string">&quot;张学友&quot;</span>));</span><br><span class="line">        System.out.println(list.add(<span class="string">&quot;郭富城&quot;</span>));</span><br><span class="line">        System.out.println(list.add(<span class="string">&quot;黎明&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//插入的方式添加元素</span></span><br><span class="line"><span class="comment">//        list.add(10,&quot;谭咏麟&quot;);//插入元素方法索引值不能大于集合中元素个数</span></span><br><span class="line"><span class="comment">//        list.add(4,&quot;谭咏麟&quot;);//表示在集合中最后位置插入元素，与追加相同</span></span><br><span class="line">        list.add(<span class="number">1</span>,<span class="string">&quot;谭咏麟&quot;</span>);<span class="comment">//指定位置插入元素，索引位置之后的元素会自动向后进行移动</span></span><br><span class="line"></span><br><span class="line">        ArrayList&lt;String&gt; newList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();<span class="comment">//创建新的集合</span></span><br><span class="line">        newList.add(<span class="string">&quot;小沈阳&quot;</span>);</span><br><span class="line">        newList.add(<span class="string">&quot;宋小宝&quot;</span>);</span><br><span class="line">        newList.add(<span class="string">&quot;赵四&quot;</span>);</span><br><span class="line">        newList.add(<span class="string">&quot;刘能&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//查看集合中的元素</span></span><br><span class="line">        System.out.println(<span class="string">&quot;原集合内部元素：&quot;</span> + list);</span><br><span class="line">        System.out.println(<span class="string">&quot;新集合内部元素：&quot;</span> + newList);</span><br><span class="line"></span><br><span class="line">        list.addAll(newList); <span class="comment">//将新集合全部元素添加到原集合中</span></span><br><span class="line">        System.out.println(<span class="string">&quot;原集合内部元素：&quot;</span> + list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-2-ArrayList集合常用方法"><a href="#4-2-ArrayList集合常用方法" class="headerlink" title="4.2 - ArrayList集合常用方法"></a>4.2 - ArrayList集合常用方法</h2><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td><code>public boolean remove(Object o)</code></td><td>删除指定的元素，成功则返回true</td></tr><tr><td><code>public E remove(int index)</code></td><td>删除指定索引位置的元素，返回被删除的元素</td></tr><tr><td><code>public E set(int index,E e)</code></td><td>修改指定索引位置的元素，返回修改前的元素</td></tr><tr><td><code>public E get(int index)</code></td><td>获取指定索引对应的元素</td></tr><tr><td><code>public int size()</code></td><td>获取结合中元素个数</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr.乐</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>   ArrayList集合常用方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList_02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//追加方式添加元素</span></span><br><span class="line">        list.add(<span class="string">&quot;东邪&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;西毒&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;南帝&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;北丐&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;中神通&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//删除</span></span><br><span class="line">        System.out.println(list.remove(<span class="string">&quot;西毒&quot;</span>));<span class="comment">//通过元素名称删除，返回boolean</span></span><br><span class="line">        System.out.println(list.remove(<span class="number">1</span>));<span class="comment">//通过索引删除元素，返回被删除元素名</span></span><br><span class="line">        <span class="comment">//修改</span></span><br><span class="line">        System.out.println(list.set(<span class="number">1</span>,<span class="string">&quot;西毒&quot;</span>));<span class="comment">//指定索引位置修改元素，并返回被修改元素</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;原集合中元素有：&quot;</span> + list);</span><br><span class="line">        <span class="comment">//获取方法</span></span><br><span class="line">        System.out.println(list.get(<span class="number">1</span>));<span class="comment">//通过指定索引位置获取集合元素</span></span><br><span class="line">        <span class="comment">//获取集合元素个数</span></span><br><span class="line">        System.out.println(list.size());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//集合的遍历,普通for循环</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            System.out.print(list.get(i) + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//增强版for循环</span></span><br><span class="line">        <span class="keyword">for</span> (String name : list) &#123;</span><br><span class="line">            System.out.print(name+ <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//迭代器</span></span><br><span class="line">        Iterator&lt;String&gt; it = list.iterator();<span class="comment">//创建迭代器</span></span><br><span class="line">        <span class="keyword">while</span> (it.hasNext())&#123;<span class="comment">//判断下一个位置是否有元素</span></span><br><span class="line">            System.out.print(it.next() + <span class="string">&quot;\t&quot;</span>);  <span class="comment">//next方法表示获取下一个位置的元素</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Stream流</span></span><br><span class="line">        list.stream().forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-3-ArrayList实现原理"><a href="#4-3-ArrayList实现原理" class="headerlink" title="4.3 -ArrayList实现原理"></a>4.3 -ArrayList实现原理</h2><h3 id="底层代码："><a href="#底层代码：" class="headerlink" title="底层代码："></a><strong>底层代码：</strong></h3><pre><code>    **属性：**</code></pre><blockquote><p>DEFAULT_CAPACITY &#x3D; 10 默认长度，初始化容量为10</p><p>Object[] EMPTY_ELEMENTDATA &#x3D; {} &#x2F;&#x2F;有参构造所创建</p><p>Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA &#x3D; {} &#x2F;&#x2F;无参构造所创建的</p><p>Object[] elementData;底层为Object类型的数组，存储的元素都在此。</p><p>int size 实际存放的个数</p></blockquote><pre><code>     **构造方法 ：**</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个参数的构造</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//参数如果大于零，则为创建数组的长度；</span></span><br><span class="line"><span class="comment">//参数如果等于零，EMPTY_ELEMENTDATA；</span></span><br><span class="line"><span class="comment">//参数如果小于0，抛出异常。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//无参构造</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//DEFAULTCAPACITY_EMPTY_ELEMENTDATA  new对象时默认为0 当添加第一个元素的时候，数组扩容至10</span></span><br></pre></td></tr></table></figure><pre><code>    **add方法源码：（jdk1.8与之不同，此处为jdk16）**</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//源码</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        modCount++;<span class="comment">//操作次数</span></span><br><span class="line">        add(e, elementData, size);</span><br><span class="line"><span class="comment">//e 操作对象;  elementData 底层操作的数组;size 默认大小0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">------------------------------------------------</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E e, Object[] elementData, <span class="type">int</span> s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s == elementData.length)<span class="comment">//ture</span></span><br><span class="line">            elementData = grow();</span><br><span class="line">        elementData[s] = e;  <span class="comment">//存数据</span></span><br><span class="line">        size = s + <span class="number">1</span>; <span class="comment">//最小需要长度</span></span><br><span class="line">    &#125;</span><br><span class="line">----------------------------------------------------------</span><br><span class="line"> <span class="keyword">private</span> Object[] grow() &#123;</span><br><span class="line">        <span class="keyword">return</span> grow(size + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">-----------------------------------------------------</span><br><span class="line"> <span class="keyword">private</span> Object[] grow(<span class="type">int</span> minCapacity) &#123; <span class="comment">//初始传入为size+1  为1</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length; <span class="comment">//初始为0</span></span><br><span class="line">        <span class="keyword">if</span> (oldCapacity &gt; <span class="number">0</span> || elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">       <span class="comment">//if条件为初始数组长度&gt;0或者数组不是无参构造构建的</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> ArraysSupport.newLength(oldCapacity, <span class="comment">//旧数组的长度</span></span><br><span class="line">                    minCapacity - oldCapacity, <span class="comment">/* minimum growth */</span>  </span><br><span class="line">                    <span class="comment">//最小需要长度-旧数组的长度  大于0代表空间不足</span></span><br><span class="line">                    oldCapacity &gt;&gt; <span class="number">1</span>           <span class="comment">/* preferred growth */</span>);</span><br><span class="line">                   <span class="comment">//二进制位右移1位  位旧数组长度/2</span></span><br><span class="line">            <span class="type">return</span> <span class="variable">elementData</span> <span class="operator">=</span> Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">            将数据放入新数组中</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">return</span> <span class="variable">elementData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>[Math.max(DEFAULT_CAPACITY, minCapacity)];</span><br><span class="line">            <span class="comment">//数组长度  DEFAULT_CAPACITY为10  此处代表无参构造默认长度为10</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">----------------------------------------------------</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">newLength</span><span class="params">(<span class="type">int</span> oldLength, <span class="type">int</span> minGrowth, <span class="type">int</span> prefGrowth)</span> &#123;</span><br><span class="line">        <span class="comment">// assert oldLength &gt;= 0</span></span><br><span class="line">        <span class="comment">// assert minGrowth &gt; 0</span></span><br><span class="line">          </span><br><span class="line">        <span class="type">int</span> <span class="variable">newLength</span> <span class="operator">=</span> Math.max(minGrowth, prefGrowth) + oldLength;</span><br><span class="line">         <span class="comment">//如果prefGrowth&gt;minGrowth  扩容1.5倍    minGrowth&gt;prefGrowth为需要多少给多少</span></span><br><span class="line">        <span class="keyword">if</span> (newLength - MAX_ARRAY_LENGTH &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">     <span class="comment">//MAX_ARRAY_LENGTH为int最大值   表示新数组长度如果小于int的最大值</span></span><br><span class="line">            <span class="keyword">return</span> newLength;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hugeLength(oldLength, minGrowth);</span><br><span class="line">         <span class="comment">//返回int最大值</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>ArrayList集合底层是数组，怎么优化？<br>  尽可能少的扩容。因为数组扩容效率比较低，建议在使用ArrayList集合 的时候预估计元素的个数，给定一个初始化容量。</p><p>数组优点：<br>检索效率比较高。（每个元素占用空间大小相同，内存地址是连续的，知道首元素内存地址，<br>然后知道下标，通过数学表达式计算出元素的内存地址，所以检索效率最高。）</p><p>数组缺点：<br>随机增删元素效率比较低。<br>另外数组无法存储大数据量。（很难找到一块非常巨大的连续的内存空间。）</p><p>向数组末尾添加元素，效率很高，不受影响。</p></blockquote><h2 id="4-4-LinkedList实现原理"><a href="#4-4-LinkedList实现原理" class="headerlink" title="4.4 -LinkedList实现原理"></a>4.4 -<strong>LinkedList</strong>实现原理</h2><p><strong>底层代码</strong></p><pre><code>    **属性：**</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//初始长度</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first;<span class="comment">//头节点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last;<span class="comment">//尾节点</span></span><br></pre></td></tr></table></figure><pre><code>    **add方法源码：（jdk1.8与之不同，此处为jdk16）**</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        linkLast(e);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">--------------------------------------</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">linkLast</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; l = last; <span class="comment">//初始为null</span></span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(l, e, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">//参数1：位上一个节点的内存地址,参数2：e为插入的数据,参数3：下一个节点的内存地址</span></span><br><span class="line">        last = newNode; <span class="comment">// 最后节点为新节点</span></span><br><span class="line">        <span class="keyword">if</span> (l == <span class="literal">null</span>)  <span class="comment">//如果newNode的前一个节点为null,则将新节点赋给first</span></span><br><span class="line">            first = newNode;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l.next = newNode;  <span class="comment">//尾节点下一个节点为新节点</span></span><br><span class="line">        size++;<span class="comment">//大小</span></span><br><span class="line">        modCount++;<span class="comment">//操作数</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="4-5-LinkedList和ArrayList"><a href="#4-5-LinkedList和ArrayList" class="headerlink" title="4.5 -LinkedList和ArrayList"></a><strong>4.5 -LinkedList和ArrayList</strong></h2><blockquote><pre><code>    LinkedList和ArrayList方法一样，只是底层实现不一样。ArrayList底层为数组存储，LinkedList是以双向链表存储。LinkedList集合没有初始化容量。最初这个链表中没有任何元素。first和last引用都是null。    链表的优点：    由于链表上的元素在空间存储上内存地址不连续。    所以随机增删元素的时候不会有大量元素位移，因此随机增删效率较高。    在以后的开发中，如果遇到随机增删集合中元素的业务比较多时，建议    使用LinkedList。    链表的缺点：    不能通过数学表达式计算被查找元素的内存地址，每一次查找都是从头    节点开始遍历，直到找到为止。所以LinkedList集合检索/查找的效率    较低。    ArrayList：把检索发挥到极致。（末尾添加元素效率还是很高的。）    LinkedList：把随机增删发挥到极致。    加元素都是往末尾添加，所以ArrayList用的比LinkedList多。</code></pre></blockquote><h2 id="4-6-Vector"><a href="#4-6-Vector" class="headerlink" title="4.6  -Vector"></a>4.6  -Vector</h2><blockquote><p>1、底层也是一个数组。<br>2、初始化容量：10<br>3、怎么扩容的？<br>扩容之后是原容量的2倍。<br>10–&gt; 20 –&gt; 40 –&gt; 80<br>4、Vector中所有的方法都是线程同步的，都带有synchronized关键字，<br>是线程安全的。效率比较低，使用较少了。<br>5、怎么将一个线程不安全的ArrayList集合转换成线程安全的呢？<br>使用集合工具类：<br>  java.util.Collections;<br>  java.util.Collection 是集合接口。<br>  java.util.Collections 是集合工具类。<br>Collections.synchronizedList();&#x2F;&#x2F;将及格转换为线程安全的。</p></blockquote><h2 id="5-Set"><a href="#5-Set" class="headerlink" title="5 -Set"></a>5 -Set</h2><h2 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 -概述"></a>5.1 -概述</h2><ul><li><p>Set集合也是一个接口，继承自Collection，与List类似，都需要通过实现类来进行操作。</p></li><li><p>特点</p><ul><li><p>不允许包含重复的值</p></li><li><p>没有索引（就不能使用普通的for循环进行遍历）</p></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr.乐</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> Set集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//使用多态，父类的引用指向子类对象</span></span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加元素</span></span><br><span class="line">        set.add(<span class="string">&quot;黄固&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;欧阳锋&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;段智兴&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;洪七公&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;段智兴&quot;</span>);</span><br><span class="line">        System.out.println(set);<span class="comment">//打印集合</span></span><br><span class="line">         <span class="comment">//[洪七公, 黄固, 欧阳锋, 段智兴]</span></span><br><span class="line">        <span class="comment">//HashSet集合对于元素的读写顺序不做保证</span></span><br><span class="line">        <span class="comment">//相同的元素，多次存储，只能保留一个，并且不会报错</span></span><br><span class="line">        <span class="comment">//List集合可以存储重复元素，Set集合不行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>     **例：双色球**</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr.乐</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>  双色球 -Set版</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Random</span> <span class="variable">ran</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();<span class="comment">//创建随机类对象</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">blueBall</span> <span class="operator">=</span> ran.nextInt(<span class="number">16</span>) + <span class="number">1</span>;</span><br><span class="line"><span class="comment">//        HashSet&lt;Integer&gt; redBalls = new HashSet&lt;&gt;();//创建集合用来存储红球</span></span><br><span class="line">        TreeSet&lt;Object&gt; redBalls = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();<span class="comment">//TreeSet集合自带排序规则</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (redBalls.size() &lt; <span class="number">6</span>)&#123;</span><br><span class="line">            redBalls.add(ran.nextInt(<span class="number">33</span>) + <span class="number">1</span>);<span class="comment">//将当前生成的红球直接存进集合中</span></span><br><span class="line">            <span class="comment">//因为Set集合不能存储重复的元素，所以去重的操作可以省略不做。</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;红球：&quot;</span> + redBalls + <span class="string">&quot;篮球 [&quot;</span> + blueBall + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-2-哈希值"><a href="#5-2-哈希值" class="headerlink" title="5.2 -哈希值"></a>5.2 -哈希值</h2><pre><code>    Set集合的去重原理使用的是哈希值。</code></pre><blockquote><p>哈希值就是JDK根据对象地址 或者 字符串 或者数值 通过自己内部的计算出来的一个整数类型数据</p></blockquote><blockquote><p><code>public int hashCode()</code> - 用来获取哈希值，来自于Object顶层类</p><ul><li><p>对象的哈希值特点</p><ul><li><p>同一个对象多次调用<code>hashCode()</code>方法，得到的结果是相同的。</p></li><li><p>默认情况下，不同的对象的哈希值也是不同的（特殊情况除外）</p></li></ul></li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr.乐</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>  哈希值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//相同对象哈希值相同</span></span><br><span class="line">        System.out.println(<span class="string">&quot;张三&quot;</span>.hashCode());<span class="comment">//774889</span></span><br><span class="line">        System.out.println(<span class="string">&quot;张三&quot;</span>.hashCode());<span class="comment">//774889</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//不同对象哈希值不同</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">Object</span>().hashCode());</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">Object</span>().hashCode());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//不同的对象的哈希值也有可能相同，例外情况</span></span><br><span class="line">        System.out.println(<span class="string">&quot;辂鹅&quot;</span>.hashCode());<span class="comment">//1179395</span></span><br><span class="line">        System.out.println(<span class="string">&quot;较鸦&quot;</span>.hashCode());<span class="comment">//1179395</span></span><br><span class="line">        System.out.println(<span class="string">&quot;辄鸇&quot;</span>.hashCode());<span class="comment">//1179395</span></span><br><span class="line">        System.out.println(<span class="string">&quot;辅鷨&quot;</span>.hashCode());<span class="comment">//1179395</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-3-HashSet去重原理"><a href="#5-3-HashSet去重原理" class="headerlink" title="5.3 -HashSet去重原理"></a>5.3 -HashSet去重原理</h2><ul><li><p>HashSet集合的特点</p><ul><li><p>底层结构是“哈希表”</p></li><li><p>集合对于读写顺序不做保证</p></li><li><p>没有索引</p></li><li><p>Set集合中的内容不能重复</p></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr.乐</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>  HashSet去重原理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        HashSet&lt;Student&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//添加元素</span></span><br><span class="line">        set.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;黄固&quot;</span>,<span class="number">28</span>));</span><br><span class="line">        set.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;欧阳锋&quot;</span>,<span class="number">38</span>));</span><br><span class="line">        set.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;段智兴&quot;</span>,<span class="number">48</span>));</span><br><span class="line">        set.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;洪七公&quot;</span>,<span class="number">40</span>));</span><br><span class="line">        set.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;段智兴&quot;</span>,<span class="number">48</span>));</span><br><span class="line">        <span class="comment">//从程序的角度来考虑，两个段智兴不是同一个对象，都有自己的存储空间，所以哈希值也不一样。</span></span><br><span class="line">        <span class="keyword">for</span> (Student stu : set) &#123;</span><br><span class="line">            System.out.println(stu);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        重写hashcode和equals</span></span><br><span class="line"><span class="comment">        Student&#123;name=&#x27;段智兴&#x27;, age=48&#125;</span></span><br><span class="line"><span class="comment">        Student&#123;name=&#x27;欧阳锋&#x27;, age=38&#125;</span></span><br><span class="line"><span class="comment">        Student&#123;name=&#x27;洪七公&#x27;, age=40&#125;</span></span><br><span class="line"><span class="comment">        Student&#123;name=&#x27;黄固&#x27;, age=28&#125;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-4-LinkedHashSet"><a href="#5-4-LinkedHashSet" class="headerlink" title="5.4 -LinkedHashSet"></a>5.4 -LinkedHashSet</h2><ul><li><p>特点</p><ul><li><p>LinkedHashSet是哈希表和链表实现的Set接口，具有可预测的读写顺序。</p></li><li><p>有链表来保证元素有序</p></li><li><p>有哈希表来保证元素的唯一性</p></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr.乐</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> LinkedHashSet</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo05</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        LinkedHashSet&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加元素</span></span><br><span class="line">        set.add(<span class="string">&quot;黄固&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;欧阳锋&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;段智兴&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;洪七公&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;段智兴&quot;</span>);<span class="comment">//重复的元素不能存进去</span></span><br><span class="line"></span><br><span class="line">        System.out.println(set);<span class="comment">//打印集合 [黄固, 欧阳锋, 段智兴, 洪七公]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-5-TreeSet"><a href="#5-5-TreeSet" class="headerlink" title="5.5 -TreeSet"></a>5.5 -TreeSet</h2><blockquote><p>1、TreeSet集合底层实际上是一个TreeMap</p><p>2、TreeMap集合底层是一个二叉树。</p><p>3、放到TreeSet集合中的元素，等同于放到TreeMap集合key部分了。</p><p>4、TreeSet集合中的元素：无序不可重复，但是可以按照元素的大小顺序自动排序。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeSetTest02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个TreeSet集合</span></span><br><span class="line">        TreeSet&lt;String&gt; ts = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 添加String</span></span><br><span class="line">        ts.add(<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">        ts.add(<span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">        ts.add(<span class="string">&quot;wangwu&quot;</span>);</span><br><span class="line">        ts.add(<span class="string">&quot;zhangsi&quot;</span>);</span><br><span class="line">        ts.add(<span class="string">&quot;wangliu&quot;</span>);</span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        <span class="keyword">for</span>(String s : ts)&#123;</span><br><span class="line">            <span class="comment">// 按照字典顺序，升序！</span></span><br><span class="line">            System.out.println(s);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        lisi</span></span><br><span class="line"><span class="comment">         wangliu</span></span><br><span class="line"><span class="comment">         wangwu</span></span><br><span class="line"><span class="comment">         zhangsan</span></span><br><span class="line"><span class="comment">         zhangsi</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        TreeSet&lt;Integer&gt; ts2 = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line">        ts2.add(<span class="number">100</span>);</span><br><span class="line">        ts2.add(<span class="number">200</span>);</span><br><span class="line">        ts2.add(<span class="number">900</span>);</span><br><span class="line">        ts2.add(<span class="number">800</span>);</span><br><span class="line">        ts2.add(<span class="number">600</span>);</span><br><span class="line">        ts2.add(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span>(Integer elt : ts2)&#123;</span><br><span class="line">            <span class="comment">// 升序！</span></span><br><span class="line">            System.out.println(elt);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-5-1-自定义排序规则"><a href="#5-5-1-自定义排序规则" class="headerlink" title="5.5.1 -自定义排序规则"></a>5.5.1 -自定义排序规则</h3><blockquote><p>对于自定义的类无法排序，因为类中对象之间没有比较规则，不知道谁大谁小。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr.乐</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>  自定义比较器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeSetTest04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Customer</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Customer</span>(<span class="number">32</span>);</span><br><span class="line">        <span class="type">Customer</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Customer</span>(<span class="number">20</span>);</span><br><span class="line">        <span class="type">Customer</span> <span class="variable">c3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Customer</span>(<span class="number">30</span>);</span><br><span class="line">        <span class="type">Customer</span> <span class="variable">c4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Customer</span>(<span class="number">25</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建TreeSet集合</span></span><br><span class="line">        TreeSet&lt;Customer&gt; customers = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 添加元素</span></span><br><span class="line">        customers.add(c1);</span><br><span class="line">        customers.add(c2);</span><br><span class="line">        customers.add(c3);</span><br><span class="line">        customers.add(c4);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        <span class="keyword">for</span> (Customer c : customers)&#123;</span><br><span class="line">            System.out.println(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 放在TreeSet集合中的元素需要实现java.lang.Comparable接口。</span></span><br><span class="line"><span class="comment">// 并且实现compareTo方法。equals可以不写。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Customer</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Customer&gt;&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Customer</span><span class="params">(<span class="type">int</span> age)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 需要在这个方法中编写比较的逻辑，或者说比较的规则，按照什么进行比较！</span></span><br><span class="line">    <span class="comment">// k.compareTo(t.key)</span></span><br><span class="line">    <span class="comment">// 拿着参数k和集合中的每一个k进行比较，返回值可能是&gt;0 &lt;0 =0</span></span><br><span class="line">    <span class="comment">// 比较规则最终还是由程序员指定的：例如按照年龄升序。或者按照年龄降序。</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Customer c)</span> &#123; <span class="comment">// c1.compareTo(c2);</span></span><br><span class="line">        <span class="keyword">return</span> c.age - <span class="built_in">this</span>.age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Customer[age=&quot;</span>+age+<span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>      **匿名内部类方式**</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeSetTest05</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//        TreeSet&lt;Student&gt; ts = new TreeSet&lt;&gt;();//默认排序规则</span></span><br><span class="line">        TreeSet&lt;Student&gt; ts = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Student&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Student o1, Student o2)</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> o1.getAge() - o2.getAge();</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span> == res ? o1.getName().compareTo(o2.getName()) : res;</span><br><span class="line">                 <span class="comment">//三目运算符  等于零用姓名排序</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);<span class="comment">//默认排序规则</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加元素</span></span><br><span class="line">        ts.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Andy&quot;</span>,<span class="number">19</span>));</span><br><span class="line">        ts.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Jack&quot;</span>,<span class="number">18</span>));</span><br><span class="line">        ts.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Tom&quot;</span>,<span class="number">21</span>));</span><br><span class="line">        ts.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Lucy&quot;</span>,<span class="number">17</span>));</span><br><span class="line">        ts.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Bob&quot;</span>,<span class="number">21</span>)); <span class="comment">//当年龄相同时，按照姓名的字典顺序排序</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Student stu : ts) &#123;</span><br><span class="line">            System.out.println(stu);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Comparable和Comparator怎么选择呢？<br>当比较规则不会发生改变的时候，或者说当比较规则只有1个的时候，建议实现Comparable接口。<br>如果比较规则有多个，并且需要多个比较规则之间频繁切换，建议使用Comparator接口。</p></blockquote><h2 id="6-Map"><a href="#6-Map" class="headerlink" title="6 -Map"></a>6 -Map</h2><h2 id="6-1-概述"><a href="#6-1-概述" class="headerlink" title="6.1 -概述"></a>6.1 -概述</h2><blockquote><p>双列集合：用来存储键值对的集合。</p><ul><li><p><code>interface Map&lt;K,V&gt;</code> : K(key)键 ，V(value)值</p></li><li><p>将键映射到值的对象，不能出现重复的键，每个键最多可以映射到一个值</p></li></ul></blockquote><blockquote><p>1、Map和Collection没有继承关系。<br>2、Map集合以key和value的方式存储数据：键值对<br>key和value都是引用数据类型。<br>key和value都是存储对象的内存地址。<br>key起到主导的地位，value是key的一个附属品。</p></blockquote><p>例子：</p><table><thead><tr><th>学号（Key）</th><th>姓名(Value)</th></tr></thead><tbody><tr><td>STU001</td><td>张三</td></tr><tr><td>STU002</td><td>李四</td></tr><tr><td>STU003</td><td>张三</td></tr></tbody></table><h2 id="6-2-Map的基本方法"><a href="#6-2-Map的基本方法" class="headerlink" title="6.2 -Map的基本方法"></a>6.2 -Map的基本方法</h2><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td><code>V put(K key,V value)</code></td><td>设置键值对</td></tr><tr><td><code>V remove(Object key)</code></td><td>删除元素</td></tr><tr><td><code>void clear()</code></td><td>清空集合</td></tr><tr><td><code>boolean containsKey(Object key)</code></td><td>判断键是否存在，存在则返回true</td></tr><tr><td><code>boolean containsValue(Object value)</code></td><td>判断值是否存在，存在则返回true</td></tr><tr><td><code>boolean isEmpty()</code></td><td>判断集合是否为空</td></tr><tr><td><code>int size()</code></td><td>获取集合元素个数</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr.乐</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>  集合的基本方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Map01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Map&lt;String,String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        map.put(<span class="string">&quot;STU001&quot;</span>,<span class="string">&quot;Andy&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;STU002&quot;</span>,<span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;STU003&quot;</span>,<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;STU004&quot;</span>,<span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;STU004&quot;</span>,<span class="string">&quot;Smith&quot;</span>);<span class="comment">//设置（修改）</span></span><br><span class="line">        <span class="comment">//如果键不存在，则表示添加元素。如果键存在，则表示设置值。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//删除</span></span><br><span class="line">        System.out.println(map.remove(<span class="string">&quot;STU003&quot;</span>));  <span class="comment">//Tom</span></span><br><span class="line">        <span class="comment">//判断是否包含</span></span><br><span class="line">        System.out.println(map.containsKey(<span class="string">&quot;STU003&quot;</span>));  <span class="comment">//false</span></span><br><span class="line">        System.out.println(map.containsKey(<span class="string">&quot;STU004&quot;</span>));  <span class="comment">//true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------------&quot;</span>);</span><br><span class="line">        System.out.println(map.containsValue(<span class="string">&quot;Tom&quot;</span>));  <span class="comment">//false</span></span><br><span class="line">        System.out.println(map.containsValue(<span class="string">&quot;Smith&quot;</span>)); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------------&quot;</span>);</span><br><span class="line">        System.out.println(map.isEmpty());<span class="comment">//判断集合是否为空   false</span></span><br><span class="line">        map.clear();<span class="comment">//清空集合</span></span><br><span class="line">        System.out.println(map.isEmpty()); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">        System.out.println(map); <span class="comment">//&#123;&#125;</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-3-Map集合的获取功能"><a href="#6-3-Map集合的获取功能" class="headerlink" title="6.3 -Map集合的获取功能"></a>6.3 -Map集合的获取功能</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr.乐</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">map_get</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Map&lt;String,String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        map.put(<span class="string">&quot;STU001&quot;</span>,<span class="string">&quot;Andy&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;STU002&quot;</span>,<span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;STU003&quot;</span>,<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;STU004&quot;</span>,<span class="string">&quot;Bob&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//get通过键获取值</span></span><br><span class="line">        System.out.println(map.get(<span class="string">&quot;STU003&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;------------------&quot;</span>);</span><br><span class="line">        <span class="comment">//keySet 获取所有键的Set集合</span></span><br><span class="line">        Set&lt;String&gt; keySet = map.keySet();</span><br><span class="line">        System.out.println(keySet);</span><br><span class="line">        <span class="comment">//values  获取所有值的Collection集合</span></span><br><span class="line">        Collection&lt;String&gt; values = map.values();</span><br><span class="line">        System.out.println(values);</span><br><span class="line">        <span class="comment">//entrySet  获取所有键值对对象的Set集合</span></span><br><span class="line">        Set&lt;Map.Entry&lt;String, String&gt;&gt; es = map.entrySet();</span><br><span class="line">        <span class="comment">//Map集合通过entrySet()方法转换成的这个Set集合，Set集合中元素的类型是 Map.Entry&lt;K,V&gt;</span></span><br><span class="line">        <span class="comment">//Map.Entry和String一样，都是一种类型的名字，只不过：Map.Entry是静态内部类，是Map中的静态内部类</span></span><br><span class="line">        System.out.println(es);</span><br><span class="line">         <span class="comment">//[STU001=Andy, STU003=Tom, STU002=Jack, STU004=Bob]</span></span><br><span class="line">         <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry:es)&#123;</span><br><span class="line">             System.out.println(<span class="string">&quot;key:&quot;</span>+entry.getKey()+<span class="string">&quot;    &quot;</span>+<span class="string">&quot;value:&quot;</span>+entry.getValue());</span><br><span class="line">         &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        key:STU001    value:Andy</span></span><br><span class="line"><span class="comment">        key:STU003    value:Tom</span></span><br><span class="line"><span class="comment">        key:STU002    value:Jack</span></span><br><span class="line"><span class="comment">        key:STU004    value:Bob</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-4-哈希表"><a href="#6-4-哈希表" class="headerlink" title="6.4 -哈希表"></a>6.4 -哈希表</h2><blockquote><p>通过 数组 + 链表 实现的一种数据结构</p></blockquote><blockquote><p>哈希表的构造方法的参数是一个长度为16个元素的数组，通过哈希值 % 16 的值，作为头节点在数组中选择对应的位置，就形成了哈希表。</p></blockquote><p><img src="/./../images/%E9%9B%86%E5%90%88/a8e00ce4205c4456a021997b4b3a4a52.png">         注：图转自动力节点。</p><h2 id="6-5-HashMap"><a href="#6-5-HashMap" class="headerlink" title="6.5 -HashMap"></a>6.5 -HashMap</h2><h3 id="6-5-1-底层源码"><a href="#6-5-1-底层源码" class="headerlink" title="6.5.1 -底层源码"></a>6.5.1 -底层源码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMap</span>&#123;</span><br><span class="line">           <span class="comment">// HashMap底层实际上就是一个数组。（一维数组）</span></span><br><span class="line">           Node&lt;K,V&gt;[] table;</span><br><span class="line">           <span class="comment">// 静态的内部类HashMap.Node</span></span><br><span class="line">           <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; &#123;</span><br><span class="line">               <span class="keyword">final</span> <span class="type">int</span> hash; <span class="comment">// 哈希值（哈希值是key的hashCode()方法的执行结果。hash值通过哈希函数/算法，可以转换存储成数组的下标。）</span></span><br><span class="line">               <span class="keyword">final</span> K key; <span class="comment">// 存储到Map集合中的那个key</span></span><br><span class="line">               V value; <span class="comment">// 存储到Map集合中的那个value</span></span><br><span class="line">               Node&lt;K,V&gt; next; <span class="comment">// 下一个节点的内存地址。</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><h3 id="6-5-2-特点"><a href="#6-5-2-特点" class="headerlink" title="6.5.2 -特点"></a>6.5.2 -特点</h3><blockquote><p>1、无序，不可重复。<br>为什么无序？ 因为不一定挂到哪个单向链表上。<br>不可重复是怎么保证的？ equals方法来保证HashMap集合的key不可重复。<br>如果key重复了，value会覆盖。</p><p>2、放在HashMap集合key部分的元素其实就是放到HashSet集合中了。<br>所以HashSet集合中的元素也需要同时重写hashCode()+equals()方法。</p><p>3、HashMap集合的默认初始化容量是16，默认加载因子是0.75<br>这个默认加载因子是当HashMap集合底层数组的容量达到75%的时候，数组以二叉树开始扩容。</p><p>重点，记住：HashMap集合初始化容量必须是2的倍数，这也是官方推荐的，<br>这是因为达到散列均匀，为了提高HashMap集合的存取效率，所必须的。</p></blockquote><h3 id="6-5-3-注意"><a href="#6-5-3-注意" class="headerlink" title="6.5.3 -注意"></a><strong>6.5.3 -注意</strong></h3><blockquote><p>1.向Map集合中存，以及从Map集合中取，都是先调用key的hashCode方法，然后再调用equals方法！</p><p>  equals方法有可能调用，也有可能不调用。</p><p>  拿put(k,v)举例，什么时候equals不会调用？ k.hashCode()方法返回哈希值， 哈希值经过哈希算法转换成数组下标。 数组下标位置上如果是null，equals不需要执行。 拿get(k)举例，什么时候equals不会调用？ k.hashCode()方法返回哈希值， 哈希值经过哈希算法转换成数组下标。 数组下标位置上如果是null，equals不需要执行。</p><p>4.假设将所有的hashCode()方法返回值固定为某个值，那么会导致底层哈希表变成了 纯单向链表。</p><p>这种情况我们成为：散列分布不均匀。</p><p>什么是散列分布均匀？</p><p>假设有100个元素，10个单向链表，那么每个单向链表上有10个节点，这是最好的， 是散列分布均匀的。假设将所有的hashCode()方法返回值都设定为不一样的值，可以吗，有什么问题？ 不行，因为这样的话导致底层哈希表就成为一维数组了，没有链表的概念了。 也是散列分布不均匀。散列分布均匀需要你重写hashCode()方法时有一定的技巧。</p></blockquote><h2 id="7-Properties"><a href="#7-Properties" class="headerlink" title="7 -Properties"></a>7 -Properties</h2><blockquote><p>Properties是一个Map集合，继承Hashtable，Properties的key和value都是String类型。 Properties被称为属性类对象。 Properties是线程安全的。</p></blockquote><h2 id="7-1-方法"><a href="#7-1-方法" class="headerlink" title="7.1 -方法"></a>7.1 -方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr.乐</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> Properties特有方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Properties01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Properties</span> <span class="variable">prop</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SRC</span> <span class="operator">=</span> <span class="string">&quot;./myConf.ini&quot;</span>;<span class="comment">//定义配置信息存储路径</span></span><br><span class="line"><span class="comment">//        mySave(prop,SRC);//存储配置文件</span></span><br><span class="line">        myLoad(prop,SRC);<span class="comment">//加载配置文件信息</span></span><br><span class="line">        <span class="comment">//PASSWORD&lt;---&gt;123456</span></span><br><span class="line">        <span class="comment">//DATABASE&lt;---&gt;YX2115</span></span><br><span class="line">        <span class="comment">//PORT&lt;---&gt;3306</span></span><br><span class="line">        <span class="comment">//USERNAME&lt;---&gt;root</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">myLoad</span><span class="params">(Properties prop, String src)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(src);</span><br><span class="line">        prop.load(fr);<span class="comment">//通过流，加载指定路径的配置文件</span></span><br><span class="line">        fr.close();</span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        Set&lt;String&gt; keySet = prop.stringPropertyNames();<span class="comment">//获取对象键的Set集合</span></span><br><span class="line">        <span class="keyword">for</span> (String key : keySet) &#123;</span><br><span class="line">            System.out.println(key + <span class="string">&quot;&lt;---&gt;&quot;</span> + prop.getProperty(key));<span class="comment">//通过键拿到值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mySave</span><span class="params">(Properties prop, String src)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//将配置信息存储到对象中</span></span><br><span class="line">        prop.setProperty(<span class="string">&quot;USERNAME&quot;</span>,<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        prop.setProperty(<span class="string">&quot;PASSWORD&quot;</span>,<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        prop.setProperty(<span class="string">&quot;DATABASE&quot;</span>,<span class="string">&quot;YX2115&quot;</span>);</span><br><span class="line">        prop.setProperty(<span class="string">&quot;PORT&quot;</span>,<span class="string">&quot;3306&quot;</span>);</span><br><span class="line">        <span class="comment">//写入文件</span></span><br><span class="line">        <span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(src);<span class="comment">//创建输出流对象</span></span><br><span class="line">        prop.store(fw,<span class="string">&quot;MyDataBase Configure!~&quot;</span>);</span><br><span class="line">        fw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-总结"><a href="#8-总结" class="headerlink" title="8 -总结"></a>8 -总结</h2><pre><code>    本篇文章介绍了集合的常用方法以及个别集合的底层是如何实现的。介绍了集合的继承与实现结构。各个集合的扩容方式及扩容大小以及各个集合的优点和用途。希望大家可以根据本篇文章可以更加深刻的理解java中的集合。</code></pre><p><img src="/./../images/%E9%9B%86%E5%90%88/0a1b1c280aca421e9fbfda8d57494c75.jpeg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1 - 概述&quot;&gt;&lt;/a&gt;1 - 概述&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;    所有的集合类和集合接口都在java.util包下。

    在内</summary>
      
    
    
    
    <category term="Java基础" scheme="https://wx51815.github.io/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Java" scheme="https://wx51815.github.io/tags/Java/"/>
    
    <category term="集合" scheme="https://wx51815.github.io/tags/%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>过滤器(Filter)和拦截器(Interceptor)的区别</title>
    <link href="https://wx51815.github.io/page/Java%E6%A1%86%E6%9E%B6/%E8%BF%87%E6%BB%A4%E5%99%A8(Filter)%E5%92%8C%E6%8B%A6%E6%88%AA%E5%99%A8(Interceptor)%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://wx51815.github.io/page/Java%E6%A1%86%E6%9E%B6/%E8%BF%87%E6%BB%A4%E5%99%A8(Filter)%E5%92%8C%E6%8B%A6%E6%88%AA%E5%99%A8(Interceptor)%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2023-05-09T07:13:55.000Z</published>
    <updated>2023-06-10T07:50:13.036Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1 介绍"></a>1 介绍</h2><h3 id="1-1-Filter介绍"><a href="#1-1-Filter介绍" class="headerlink" title="1.1 Filter介绍"></a>1.1 Filter介绍</h3><p>   Filter可以认为是<a href="https://so.csdn.net/so/search?q=Servlet&spm=1001.2101.3001.7020">Servlet</a>的一种“加强版”，它主要用于对用户请求进行预处理，也可以对HttpServletResponse进行后处理，是个典型的处理链。Filter也可以对用户请求生成响应，这一点与Servlet相同，但实际上很少会使用Filter向用户请求生成响应。使用Filter完整的流程是：Filter对用户请求进行预处理，接着将请求交给Servlet进行预处理并生成响应，最后Filter再对服务器响应进行后处理。</p><p>   Filter有如下几个用处。</p><ul><li><p>在HttpServletRequest到达Servlet之前，拦截客户的HttpServletRequest。</p></li><li><p>根据需要检查HttpServletRequest，也可以修改HttpServletRequest头和数据。</p></li><li><p>在HttpServletResponse到达客户端之前，拦截HttpServletResponse。</p></li><li><p>根据需要检查HttpServletResponse，也可以修改HttpServletResponse头和数据。</p><p>  Filter有如下几个种类。</p></li><li><p>用户授权的Filter：Filter负责检查用户请求，根据请求过滤用户非法请求。</p></li><li><p>日志Filter：详细记录某些特殊的用户请求。</p></li><li><p>负责解码的Filter:包括对非标准编码的请求解码。</p></li><li><p>能改变XML内容的XSLT Filter等。</p></li><li><p>Filter可以负责拦截多个请求或响应；一个请求或响应也可以被多个Filter拦截。</p><p>  创建一个Filter只需两个步骤</p></li></ul><ol><li>创建Filter处理类</li><li>web.xml文件中配置Filter</li></ol><p>  创建Filter必须实现javax.servlet.Filter接口，在该接口中定义了如下三个方法。</p><ul><li>void init(FilterConfig config):用于完成Filter的初始化。</li><li>void destory():用于Filter销毁前，完成某些资源的回收。</li><li>void doFilter(ServletRequest request,ServletResponse response,FilterChain chain):实现过滤功能，该方法就是对每个请求及响应增加的额外处理。该方法可以实现对用户请求进行预处理(ServletRequest request)，也可实现对服务器响应进行后处理(ServletResponse response)—它们的分界线为是否调用了chain.doFilter(),执行该方法之前，即对用户请求进行预处理；执行该方法之后，即对服务器响应进行后处理</li></ul><h3 id="1-2-Interceptor介绍"><a href="#1-2-Interceptor介绍" class="headerlink" title="1.2 Interceptor介绍"></a>1.2 Interceptor介绍</h3><p>拦截器，在AOP(Aspect-Oriented Programming)中用于在某个方法或字段被访问之前，进行拦截，然后在之前或之后加入某些操作。拦截是AOP的一种实现策略。</p><p>   在WebWork的中文文档的解释为—拦截器是动态拦截Action调用的对象。它提供了一种机制可以使开发者可以定义在一个Action执行的前后执行的代码，也可以在一个Action执行前阻止其执行。同时也提供了一种可以提取Action中可重用的部分的方式。</p><p>   拦截器将Action共用的行为独立出来，在Action执行前后执行。这也就是我们所说的AOP，它是分散关注的编程方法，它将通用需求功能从不相关类之中分离出来；同时，能够共享一个行为，一旦行为发生变化，不必修改很多类，只要修改这个行为就可以。</p><p>   拦截器将很多功能从我们的Action中独立出来，大量减少了我们Action的代码，独立出来的行为就有很好的重用性。</p><p>   当你提交对Action(默认是.action结尾的url)的请求时，ServletDispatcher会根据你的请求，去调度并执行相应的Action。在Action执行之前，调用被Interceptor截取，Interceptor在Action执行前后执行。</p><p>   创建Interceptor必须实现com.opensymphony.xwork2.interceptor.Interceptor接口，该接口定义了如下三个方法。</p><ul><li><p>void init():在该拦截器被实例化之后，在该拦截器执行拦截之前，系统将回调该方法。对于每个拦截器而言，其init()方法只执行一次。因此，该方法的方法体主要用于初始化资源。</p></li><li><p>void destory():该方法与init()方法对应。在拦截器实例被销毁之前，系统将回调该拦截器的destory方法，该方法用于销毁在init方法里打开的资源。</p></li><li><p>String intercept(ActionInvocation invocation):该方法是用户需要实现的拦截动作。就像Action的execute方法一样。intercept方法会返回一个字符串作为逻辑视图。如果该方法直接返回了一个字符串，系统会将跳转到该逻辑视图对应的实际视图资源，不会调用被拦截的Action。该方法的ActionInvocation参数包含了被拦截的Action的引用，可以通过调用该参数的invoke方法，将控制权转给下一个拦截器，或者转给Action的execute方法(如果该拦截器后没有其他拦截器，则直接执行Action的execute方法)。</p></li></ul><h2 id="2-Filter和Interceptor的区别"><a href="#2-Filter和Interceptor的区别" class="headerlink" title="2 Filter和Interceptor的区别"></a>2 Filter和Interceptor的区别</h2><ul><li>Filter是基于函数回调的，而Interceptor则是基于Java反射的。</li><li>Filter依赖于Servlet容器，而Interceptor不依赖于Servlet容器。</li><li>Filter对几乎所有的请求起作用，而Interceptor只能对action请求起作用。</li><li>Interceptor可以访问Action的上下文，值栈里的对象，而Filter不能。</li><li>在action的生命周期里，Interceptor可以被多次调用，而Filter只能在容器初始化时调用一次。</li></ul><h2 id="3-Filter和Interceptor的执行顺序"><a href="#3-Filter和Interceptor的执行顺序" class="headerlink" title="3 Filter和Interceptor的执行顺序"></a>3 Filter和Interceptor的执行顺序</h2><p>过滤前-拦截前-action执行-拦截后-过滤后</p><p>过滤器和拦截器非常相似，但是它们有很大的区别<br>最简单明了的区别就是<strong>过滤器可以修改request，而拦截器不能<br>过滤器需要在servlet容器中实现，拦截器可以适用于javaEE，javaSE等各种环境<br>拦截器可以调用IOC容器中的各种依赖，而过滤器不能<br>过滤器只能在请求的前后使用，而拦截器可以详细到每个方法</strong></p><p><img src="/./../images/%E8%BF%87%E6%BB%A4%E5%99%A8(Filter)%E5%92%8C%E6%8B%A6%E6%88%AA%E5%99%A8(Interceptor)%E7%9A%84%E5%8C%BA%E5%88%AB/70-1683201013709-3.png"></p><p><strong>过滤器（Filter）     ：可以拿到原始的http请求，但是拿不到你请求的控制器和请求控制器中的方法的信息。</strong></p><p><strong>拦截器（Interceptor）：可以拿到你请求的控制器和方法，却拿不到请求方法的参数。</strong></p><p><strong>切片  （Aspect）    : 可以拿到方法的参数，但是却拿不到http请求和响应的对象</strong></p><p><img src="/./../images/%E8%BF%87%E6%BB%A4%E5%99%A8(Filter)%E5%92%8C%E6%8B%A6%E6%88%AA%E5%99%A8(Interceptor)%E7%9A%84%E5%8C%BA%E5%88%AB/70-1683201071751-5-1683201074589-8.png"></p><p>参考地址：<a href="https://blog.csdn.net/testcs_dn/article/details/80279578?ops_request_misc=%7B%22request_id%22:%22168319915416782427446687%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168319915416782427446687&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-80279578-null-null.142%5Ev86%5Einsert_down1,239%5Ev2%5Einsert_chatgpt&utm_term=%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8C%E6%8B%A6%E6%88%AA%E5%99%A8&spm=1018.2226.3001.4187">过滤器(Filter)和拦截器(Interceptor)的区别_微wx</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;1-介绍&quot;&gt;&lt;a href=&quot;#1-介绍&quot; class=&quot;headerlink&quot; title=&quot;1 介绍&quot;&gt;&lt;/a&gt;1 介绍&lt;/h2&gt;&lt;h3 id=&quot;1-1-Filter介绍&quot;&gt;&lt;a href=&quot;#1-1-Filter介绍&quot; class=</summary>
      
    
    
    
    <category term="Java框架" scheme="https://wx51815.github.io/categories/Java%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="Java" scheme="https://wx51815.github.io/tags/Java/"/>
    
    <category term="框架" scheme="https://wx51815.github.io/tags/%E6%A1%86%E6%9E%B6/"/>
    
    <category term="过滤器" scheme="https://wx51815.github.io/tags/%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
    
    <category term="拦截器" scheme="https://wx51815.github.io/tags/%E6%8B%A6%E6%88%AA%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Java虚拟机</title>
    <link href="https://wx51815.github.io/page/Java%E5%9F%BA%E7%A1%80/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    <id>https://wx51815.github.io/page/Java%E5%9F%BA%E7%A1%80/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/</id>
    <published>2023-05-09T05:30:37.000Z</published>
    <updated>2023-06-10T07:50:13.028Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Java-内存区域与内存溢出异常"><a href="#1-Java-内存区域与内存溢出异常" class="headerlink" title="1. Java 内存区域与内存溢出异常"></a>1. Java 内存区域与内存溢出异常</h2><h3 id="1-1-运行时数据区域"><a href="#1-1-运行时数据区域" class="headerlink" title="1.1 运行时数据区域"></a>1.1 运行时数据区域</h3><blockquote><p>根据《Java 虚拟机规范(Java SE 7 版)》规定，Java 虚拟机所管理的内存如下图所示。</p></blockquote><p><img src="/./../images/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvZGQzYjE1YjNkODgyNmZhZWFlMjA2Mzk3NmZiOTkyMTM_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ.webp"></p><h4 id="1-1-1-程序计数器"><a href="#1-1-1-程序计数器" class="headerlink" title="1.1.1 程序计数器"></a>1.1.1 程序计数器</h4><blockquote><p>内存空间小，线程私有。字节码解释器工作是就是通过改变这个计数器的值来选取下一条需要执行指令的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖计数器完成</p></blockquote><p>如果线程正在执行一个 Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是 Native 方法，这个计数器的值则为 (Undefined)。此内存区域是唯一一个在 Java 虚拟机规范中没有规定任何 OutOfMemoryError 情况的区域。</p><h4 id="1-1-2-Java-虚拟机栈"><a href="#1-1-2-Java-虚拟机栈" class="headerlink" title="1.1.2 Java 虚拟机栈"></a>1.1.2 Java 虚拟机栈</h4><blockquote><p>线程私有，生命周期和线程一致。描述的是 Java 方法执行的内存模型：每个方法在执行时都会床创建一个栈帧(Stack Frame)用于存储<code>局部变量表</code>、<code>操作数栈</code>、<code>动态链接</code>、<code>方法出口</code>等信息。每一个方法从调用直至执行结束，就对应着一个栈帧从虚拟机栈中入栈到出栈的过程。</p></blockquote><p>局部变量表：存放了编译期可知的各种基本类型(boolean、byte、char、short、int、float、long、double)、对象引用(reference 类型)和 returnAddress 类型(指向了一条字节码指令的地址)</p><p>StackOverflowError：线程请求的栈深度大于虚拟机所允许的深度。<br>OutOfMemoryError：如果虚拟机栈可以动态扩展，而扩展时无法申请到足够的内存。</p><h4 id="1-1-3-本地方法栈"><a href="#1-1-3-本地方法栈" class="headerlink" title="1.1.3 本地方法栈"></a>1.1.3 本地方法栈</h4><blockquote><p>区别于 Java 虚拟机栈的是，Java 虚拟机栈为虚拟机执行 Java 方法(也就是字节码)服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。也会有 StackOverflowError 和 OutOfMemoryError 异常。</p></blockquote><h4 id="1-1-4-Java-堆"><a href="#1-1-4-Java-堆" class="headerlink" title="1.1.4 Java 堆"></a>1.1.4 Java 堆</h4><blockquote><p>对于绝大多数应用来说，这块区域是 JVM 所管理的内存中最大的一块。线程共享，主要是存放对象实例和数组。内部会划分出多个线程私有的分配缓冲区(Thread Local Allocation Buffer, TLAB)。可以位于物理上不连续的空间，但是逻辑上要连续。</p></blockquote><p>OutOfMemoryError：如果堆中没有内存完成实例分配，并且堆也无法再扩展时，抛出该异常。</p><h4 id="1-1-5-方法区"><a href="#1-1-5-方法区" class="headerlink" title="1.1.5 方法区"></a>1.1.5 方法区</h4><blockquote><p>属于共享内存区域，存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p></blockquote><p>现在用一张图来介绍每个区域存储的内容。</p><p><img src="/./../images/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvZGE3N2Q5MDE0Njc4NmMwY2IzZTE3MGI5YzkzNzZhZTQ_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ.webp"></p><h4 id="1-1-6-运行时常量池"><a href="#1-1-6-运行时常量池" class="headerlink" title="1.1.6 运行时常量池"></a>1.1.6 运行时常量池</h4><blockquote><p>属于方法区一部分，用于存放编译期生成的各种字面量和符号引用。编译器和运行期(String 的 intern() )都可以将常量放入池中。内存有限，无法申请时抛出 OutOfMemoryError。</p></blockquote><h4 id="1-1-7-直接内存"><a href="#1-1-7-直接内存" class="headerlink" title="1.1.7 直接内存"></a>1.1.7 直接内存</h4><blockquote><p>非虚拟机运行时数据区的部分</p></blockquote><p>在 JDK 1.4 中新加入 NIO (New Input&#x2F;Output) 类，引入了一种基于通道(Channel)和缓存(Buffer)的 I&#x2F;O 方式，它可以使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。可以避免在 Java 堆和 Native 堆中来回的数据耗时操作。<br>OutOfMemoryError：会受到本机内存限制，如果内存区域总和大于物理内存限制从而导致动态扩展时出现该异常。</p><h3 id="1-2-HotSpot-虚拟机对象探秘"><a href="#1-2-HotSpot-虚拟机对象探秘" class="headerlink" title="1.2 HotSpot 虚拟机对象探秘"></a>1.2 HotSpot 虚拟机对象探秘</h3><blockquote><p>主要介绍数据是如何创建、如何布局以及如何访问的。</p></blockquote><h4 id="1-2-1-对象的创建"><a href="#1-2-1-对象的创建" class="headerlink" title="1.2.1 对象的创建"></a>1.2.1 对象的创建</h4><blockquote><p>创建过程比较复杂，建议看书了解，这里提供个人的总结。</p></blockquote><p>遇到 new 指令时，首先检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化过。如果没有，执行相应的类加载。</p><p>类加载检查通过之后，为新对象分配内存(内存大小在类加载完成后便可确认)。在堆的空闲内存中划分一块区域(‘指针碰撞-内存规整’或‘空闲列表-内存交错’的分配方式)。</p><p>前面讲的每个线程在堆中都会有私有的分配缓冲区(TLAB)，这样可以很大程度避免在并发情况下频繁创建对象造成的线程不安全。</p><p>内存空间分配完成后会初始化为 0(不包括对象头)，接下来就是填充对象头，把对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息存入对象头。</p><p>执行 new 指令后执行 init 方法后才算一份真正可用的对象创建完成。</p><h4 id="1-2-2-对象的内存布局"><a href="#1-2-2-对象的内存布局" class="headerlink" title="1.2.2 对象的内存布局"></a>1.2.2 对象的内存布局</h4><blockquote><p>在 HotSpot 虚拟机中，分为 3 块区域：<code>对象头(Header)</code>、<code>实例数据(Instance Data)</code>和<code>对齐填充(Padding)</code></p></blockquote><p><code>对象头(Header)</code>：包含两部分，第一部分用于存储对象自身的运行时数据，如哈希码、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等，32 位虚拟机占 32 bit，64 位虚拟机占 64 bit。官方称为 ‘Mark Word’。第二部分是类型指针，即对象指向它的类的元数据指针，虚拟机通过这个指针确定这个对象是哪个类的实例。另外，如果是 Java 数组，对象头中还必须有一块用于记录数组长度的数据，因为普通对象可以通过 Java 对象元数据确定大小，而数组对象不可以。</p><p><code>实例数据(Instance Data)</code>：程序代码中所定义的各种类型的字段内容(包含父类继承下来的和子类中定义的)。</p><p><code>对齐填充(Padding)</code>：不是必然需要，主要是占位，保证对象大小是某个字节的整数倍。</p><h4 id="1-2-3-对象的访问定位"><a href="#1-2-3-对象的访问定位" class="headerlink" title="1.2.3 对象的访问定位"></a>1.2.3 对象的访问定位</h4><blockquote><p>使用对象时，通过栈上的 reference 数据来操作堆上的具体对象。</p></blockquote><p>通过句柄访问</p><blockquote><p>Java 堆中会分配一块内存作为句柄池。reference 存储的是句柄地址。详情见图。</p></blockquote><p><img src="/./../images/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvZWJmMDBlZDI2YzM1YWVmZDkzZDVhM2EzNmIzYjE2MTM_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ.webp"></p><p>使用直接指针访问</p><blockquote><p>reference 中直接存储对象地址</p></blockquote><p><img src="/./../images/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvZGU2OTI0YjZlOWQ1NzYxMDViYTI0NzAwZjFmMzU3ZjQ_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ.webp"></p><p>比较：使用句柄的最大好处是 reference 中存储的是稳定的句柄地址，在对象移动(GC)是只改变实例数据指针地址，reference 自身不需要修改。直接指针访问的最大好处是速度快，节省了一次指针定位的时间开销。如果是对象频繁 GC 那么句柄方法好，如果是对象频繁访问则直接指针访问好。</p><h3 id="1-3-实战"><a href="#1-3-实战" class="headerlink" title="1.3 实战"></a>1.3 实战</h3><blockquote><p>&#x2F;&#x2F; 待填</p></blockquote><h2 id="2-垃圾回收器与内存分配策略"><a href="#2-垃圾回收器与内存分配策略" class="headerlink" title="2. 垃圾回收器与内存分配策略"></a>2. 垃圾回收器与内存分配策略</h2><h3 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h3><blockquote><p>程序计数器、虚拟机栈、本地方法栈 3 个区域随线程生灭(因为是线程私有)，栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作。而 Java 堆和方法区则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序处于运行期才知道那些对象会创建，这部分内存的分配和回收都是动态的，垃圾回收期所关注的就是这部分内存。</p></blockquote><h3 id="2-2-对象已死吗？"><a href="#2-2-对象已死吗？" class="headerlink" title="2.2 对象已死吗？"></a>2.2 对象已死吗？</h3><blockquote><p>在进行内存回收之前要做的事情就是判断那些对象是‘死’的，哪些是‘活’的。</p></blockquote><h4 id="2-2-1-引用计数法"><a href="#2-2-1-引用计数法" class="headerlink" title="2.2.1 引用计数法"></a>2.2.1 引用计数法</h4><blockquote><p>给对象添加一个引用计数器。但是难以解决循环引用问题。</p></blockquote><p><img src="/./../images/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvNGMyODlhMjI0Y2I0OTQ0ZTQ5OWZiNWJmZDMzZTU5MmY_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ.webp"></p><p>从图中可以看出，如果不下小心直接把 Obj1-reference 和 Obj2-reference 置 null。则在 Java 堆当中的两块内存依然保持着互相引用无法回收。</p><h4 id="2-2-2-可达性分析法"><a href="#2-2-2-可达性分析法" class="headerlink" title="2.2.2 可达性分析法"></a>2.2.2 可达性分析法</h4><blockquote><p>通过一系列的 ‘GC Roots’ 的对象作为起始点，从这些节点出发所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连的时候说明对象不可用。</p></blockquote><p><img src="/./../images/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvNThiZmFjMTVjYTZkMzA3NmRlZjUxNzRlZDVjYTVhOTk_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ.webp"></p><p>可作为 GC Roots 的对象：</p><ul><li>虚拟机栈(栈帧中的本地变量表)中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中 JNI(即一般说的 Native 方法) 引用的对象</li></ul><h4 id="2-2-3-再谈引用"><a href="#2-2-3-再谈引用" class="headerlink" title="2.2.3 再谈引用"></a>2.2.3 再谈引用</h4><blockquote><p>前面的两种方式判断存活时都与‘引用’有关。但是 JDK 1.2 之后，引用概念进行了扩充，下面具体介绍。</p></blockquote><p>下面四种引用强度一次逐渐减弱</p><p>强引用</p><blockquote><p>类似于 <code>Object obj = new Object();</code> 创建的，只要强引用在就不回收。</p></blockquote><p>软引用</p><blockquote><p>SoftReference 类实现软引用。在系统要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行二次回收。</p></blockquote><p>弱引用</p><blockquote><p>WeakReference 类实现弱引用。对象只能生存到下一次垃圾收集之前。在垃圾收集器工作时，无论内存是否足够都会回收掉只被弱引用关联的对象。</p></blockquote><p>虚引用</p><blockquote><p>PhantomReference 类实现虚引用。无法通过虚引用获取一个对象的实例，为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。</p></blockquote><h4 id="2-2-4-生存还是死亡"><a href="#2-2-4-生存还是死亡" class="headerlink" title="2.2.4 生存还是死亡"></a>2.2.4 生存还是死亡</h4><blockquote><p>即使在可达性分析算法中不可达的对象，也并非是“facebook”的，这时候它们暂时出于“缓刑”阶段，一个对象的真正死亡至少要经历两次标记过程：如果对象在进行中可达性分析后发现没有与 GC Roots 相连接的引用链，那他将会被第一次标记并且进行一次筛选，筛选条件是此对象是否有必要执行 finalize() 方法。当对象没有覆盖 finalize() 方法，或者 finalize() 方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。</p><p>如果这个对象被判定为有必要执行 finalize() 方法，那么这个对象竟会放置在一个叫做 F-Queue 的队列中，并在稍后由一个由虚拟机自动建立的、低优先级的 Finalizer 线程去执行它。这里所谓的“执行”是指虚拟机会出发这个方法，并不承诺或等待他运行结束。finalize() 方法是对象逃脱死亡命运的最后一次机会，稍后 GC 将对 F-Queue 中的对象进行第二次小规模的标记，如果对象要在 finalize() 中成功拯救自己 —— 只要重新与引用链上的任何一个对象简历关联即可。</p><p>finalize() 方法只会被系统自动调用一次。</p></blockquote><h4 id="2-2-5-回收方法区"><a href="#2-2-5-回收方法区" class="headerlink" title="2.2.5 回收方法区"></a>2.2.5 回收方法区</h4><blockquote><p>在堆中，尤其是在新生代中，一次垃圾回收一般可以回收 70% ~ 95% 的空间，而永久代的垃圾收集效率远低于此。</p><p>永久代垃圾回收主要两部分内容：废弃的常量和无用的类。</p></blockquote><p>判断废弃常量：一般是判断没有该常量的引用。</p><p>判断无用的类：要以下三个条件都满足</p><ul><li>该类所有的实例都已经回收，也就是 Java 堆中不存在该类的任何实例</li><li>加载该类的 ClassLoader 已经被回收</li><li>该类对应的 java.lang.Class 对象没有任何地方呗引用，无法在任何地方通过反射访问该类的方法</li></ul><h3 id="2-3-垃圾回收算法"><a href="#2-3-垃圾回收算法" class="headerlink" title="2.3 垃圾回收算法"></a>2.3 垃圾回收算法</h3><blockquote><p>仅提供思路</p></blockquote><h4 id="2-3-1-标记-——-清除算法"><a href="#2-3-1-标记-——-清除算法" class="headerlink" title="2.3.1 标记 —— 清除算法"></a>2.3.1 标记 —— 清除算法</h4><blockquote><p>直接标记清除就可。</p></blockquote><p>两个不足：</p><ul><li>效率不高</li><li>空间会产生大量碎片</li></ul><h4 id="2-3-2-复制算法"><a href="#2-3-2-复制算法" class="headerlink" title="2.3.2 复制算法"></a>2.3.2 复制算法</h4><blockquote><p>把空间分成两块，每次只对其中一块进行 GC。当这块内存使用完时，就将还存活的对象复制到另一块上面。</p></blockquote><p>解决前一种方法的不足，但是会造成空间利用率低下。因为大多数新生代对象都不会熬过第一次 GC。所以没必要 1 : 1 划分空间。可以分一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 空间和其中一块 Survivor。当回收时，将 Eden 和 Survivor 中还存活的对象一次性复制到另一块 Survivor 上，最后清理 Eden 和 Survivor 空间。大小比例一般是 8 : 1 : 1，每次浪费 10% 的 Survivor 空间。但是这里有一个问题就是如果存活的大于 10% 怎么办？这里采用一种分配担保策略：多出来的对象直接进入老年代。</p><h4 id="2-3-3-标记-整理算法"><a href="#2-3-3-标记-整理算法" class="headerlink" title="2.3.3 标记-整理算法"></a>2.3.3 标记-整理算法</h4><blockquote><p>不同于针对新生代的复制算法，针对老年代的特点，创建该算法。主要是把存活对象移到内存的一端。</p></blockquote><h4 id="2-3-4-分代回收"><a href="#2-3-4-分代回收" class="headerlink" title="2.3.4 分代回收"></a>2.3.4 分代回收</h4><blockquote><p>根据存活对象划分几块内存区，一般是分为新生代和老年代。然后根据各个年代的特点制定相应的回收算法。</p></blockquote><p>新生代</p><blockquote><p>每次垃圾回收都有大量对象死去，只有少量存活，选用复制算法比较合理。</p></blockquote><p>老年代</p><blockquote><p>老年代中对象存活率较高、没有额外的空间分配对它进行担保。所以必须使用 <code>标记 —— 清除</code> 或者 <code>标记 —— 整理</code> 算法回收。</p></blockquote><h3 id="2-4-HotSpot-的算法实现"><a href="#2-4-HotSpot-的算法实现" class="headerlink" title="2.4 HotSpot 的算法实现"></a>2.4 HotSpot 的算法实现</h3><blockquote><p>&#x2F;&#x2F; 待填</p></blockquote><h3 id="2-5-垃圾回收器"><a href="#2-5-垃圾回收器" class="headerlink" title="2.5 垃圾回收器"></a>2.5 垃圾回收器</h3><blockquote><p>收集算法是内存回收的理论，而垃圾回收器是内存回收的实践。</p></blockquote><p><img src="/./../images/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvMTVmYjc1NDc2MmZmNWRmM2Y3ZjYzZTVjMjZkNGQzYWU_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ.webp"></p><p>说明：如果两个收集器之间存在连线说明他们之间可以搭配使用。</p><h4 id="2-5-1-Serial-收集器"><a href="#2-5-1-Serial-收集器" class="headerlink" title="2.5.1 Serial 收集器"></a>2.5.1 Serial 收集器</h4><blockquote><p>这是一个单线程收集器。意味着它只会使用一个 CPU 或一条收集线程去完成收集工作，并且在进行垃圾回收时必须暂停其它所有的工作线程直到收集结束。</p></blockquote><p><img src="/./../images/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvYjE4NDk0YjFlNTQ4NTFiYmJkMmVlNTI3NjBjYzM3NTQ_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ.webp"></p><h4 id="2-5-2-ParNew-收集器"><a href="#2-5-2-ParNew-收集器" class="headerlink" title="2.5.2 ParNew 收集器"></a>2.5.2 ParNew 收集器</h4><blockquote><p>可以认为是 Serial 收集器的多线程版本。</p></blockquote><p><img src="/./../images/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvMTU0NjVmYjJlMTdjYjVkNjY1YzI1YmI5OGFjZmVhOTM_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ.webp"></p><p>并行：Parallel</p><blockquote><p>指多条垃圾收集线程并行工作，此时用户线程处于等待状态</p></blockquote><p>并发：Concurrent</p><blockquote><p>指用户线程和垃圾回收线程同时执行(不一定是并行，有可能是交叉执行)，用户进程在运行，而垃圾回收线程在另一个 CPU 上运行。</p></blockquote><h4 id="2-5-3-Parallel-Scavenge-收集器"><a href="#2-5-3-Parallel-Scavenge-收集器" class="headerlink" title="2.5.3 Parallel Scavenge 收集器"></a>2.5.3 Parallel Scavenge 收集器</h4><blockquote><p>这是一个新生代收集器，也是使用复制算法实现，同时也是并行的多线程收集器。</p></blockquote><p>CMS 等收集器的关注点是尽可能地缩短垃圾收集时用户线程所停顿的时间，而 Parallel Scavenge 收集器的目的是达到一个可控制的吞吐量(Throughput &#x3D; 运行用户代码时间 &#x2F; (运行用户代码时间 + 垃圾收集时间))。</p><p>作为一个吞吐量优先的收集器，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整停顿时间。这就是 GC 的自适应调整策略(GC Ergonomics)。</p><h4 id="2-5-4-Serial-Old-收集器"><a href="#2-5-4-Serial-Old-收集器" class="headerlink" title="2.5.4 Serial Old 收集器"></a>2.5.4 Serial Old 收集器</h4><blockquote><p>收集器的老年代版本，单线程，使用 <code>标记 —— 整理</code>。</p></blockquote><p><img src="/./../images/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvYjE4NDk0YjFlNTQ4NTFiYmJkMmVlNTI3NjBjYzM3NTQ_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ.webp"></p><h4 id="2-5-5-Parallel-Old-收集器"><a href="#2-5-5-Parallel-Old-收集器" class="headerlink" title="2.5.5 Parallel Old 收集器"></a>2.5.5 Parallel Old 收集器</h4><blockquote><p>Parallel Old 是 Parallel Scavenge 收集器的老年代版本。多线程，使用 <code>标记 —— 整理</code></p></blockquote><p><img src="/./../images/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvMjU2NDEzNjZiNDNkOTcxMzEwYTBhN2NlZGU0ZTQwNmE_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ.webp"></p><h4 id="2-5-6-CMS-收集器"><a href="#2-5-6-CMS-收集器" class="headerlink" title="2.5.6 CMS 收集器"></a>2.5.6 CMS 收集器</h4><blockquote><p>CMS (Concurrent Mark Sweep) 收集器是一种以获取最短回收停顿时间为目标的收集器。基于 <code>标记 —— 清除</code> 算法实现。</p></blockquote><p>运作步骤:</p><ol><li>初始标记(CMS initial mark)：标记 GC Roots 能直接关联到的对象</li><li>并发标记(CMS concurrent mark)：进行 GC Roots Tracing</li><li>重新标记(CMS remark)：修正并发标记期间的变动部分</li><li>并发清除(CMS concurrent sweep)</li></ol><p><img src="/./../images/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvNmY0ZDY4MzY0NGExNTQ1MzdiM2UyM2Q2MGQ0OWMwNzQ_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ.webp"></p><p>缺点：对 CPU 资源敏感、无法收集浮动垃圾、<code>标记 —— 清除</code> 算法带来的空间碎片</p><h4 id="2-5-7-G1-收集器"><a href="#2-5-7-G1-收集器" class="headerlink" title="2.5.7 G1 收集器"></a>2.5.7 G1 收集器</h4><blockquote><p>面向服务端的垃圾回收器。</p></blockquote><p>优点：并行与并发、分代收集、空间整合、可预测停顿。</p><p>运作步骤:</p><ol><li>初始标记(Initial Marking)</li><li>并发标记(Concurrent Marking)</li><li>最终标记(Final Marking)</li><li>筛选回收(Live Data Counting and Evacuation)</li></ol><p><img src="/./../images/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvNDBhNTc1OTMxYjI1NGE4ZjQwYmI1NDNjMjRlOGZhZGY_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ.webp"></p><h3 id="2-6-内存分配与回收策略"><a href="#2-6-内存分配与回收策略" class="headerlink" title="2.6 内存分配与回收策略"></a>2.6 内存分配与回收策略</h3><p>2.6.1 对象优先在 Eden 分配</p><blockquote><p>对象主要分配在新生代的 Eden 区上，如果启动了本地线程分配缓冲区，将线程优先在 (TLAB) 上分配。少数情况会直接分配在老年代中。</p></blockquote><p>一般来说 Java 堆的内存模型如下图所示：  </p><p><img src="/./../images/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvOTcxMDE4MDMxNWQzNTc1NmI2OGU5YzVkYWY0NGQ2ZTU_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ.webp"></p><p>新生代 GC (Minor GC)</p><blockquote><p>发生在新生代的垃圾回收动作，频繁，速度快。</p></blockquote><p>老年代 GC (Major GC &#x2F; Full GC)</p><blockquote><p>发生在老年代的垃圾回收动作，出现了 Major GC 经常会伴随至少一次 Minor GC(非绝对)。Major GC 的速度一般会比 Minor GC 慢十倍以上。</p></blockquote><p>2.6.2 大对象直接进入老年代</p><p>2.6.3 长期存活的对象将进入老年代</p><p>2.6.4 动态对象年龄判定</p><p>2.6.5 空间分配担保</p><h2 id="3-Java-内存模型与线程"><a href="#3-Java-内存模型与线程" class="headerlink" title="3. Java 内存模型与线程"></a>3. Java 内存模型与线程</h2><p><img src="/./../images/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvMjBhOTk2ODc0NmFmYTJhZmRlNGIzNzE2YmFiZjU1Y2U_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ.webp"></p><h3 id="3-1-Java-内存模型"><a href="#3-1-Java-内存模型" class="headerlink" title="3.1 Java 内存模型"></a>3.1 Java 内存模型</h3><blockquote><p>屏蔽掉各种硬件和操作系统的内存访问差异。</p></blockquote><p><img src="/./../images/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvOGY5ODMzMGRjOGFmNGNlOGNmNTM5N2EwMTMzMDhlYzI_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ.webp"></p><h4 id="3-1-1-主内存和工作内存之间的交互"><a href="#3-1-1-主内存和工作内存之间的交互" class="headerlink" title="3.1.1 主内存和工作内存之间的交互"></a>3.1.1 主内存和工作内存之间的交互</h4><table><thead><tr><th>操作</th><th>作用对象</th><th>解释</th></tr></thead><tbody><tr><td>lock</td><td>主内存</td><td>把一个变量标识为一条线程独占的状态</td></tr><tr><td>unlock</td><td>主内存</td><td>把一个处于锁定状态的变量释放出来，释放后才可被其他线程锁定</td></tr><tr><td>read</td><td>主内存</td><td>把一个变量的值从主内存传输到线程工作内存中，以便 load 操作使用</td></tr><tr><td>load</td><td>工作内存</td><td>把 read 操作从主内存中得到的变量值放入工作内存中</td></tr><tr><td>use</td><td>工作内存</td><td>把工作内存中一个变量的值传递给执行引擎，</td></tr><tr><td>每当虚拟机遇到一个需要使用到变量值的字节码指令时将会执行这个操作</td><td></td><td></td></tr><tr><td>assign</td><td>工作内存</td><td>把一个从执行引擎接收到的值赋接收到的值赋给工作内存的变量，</td></tr><tr><td>每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作</td><td></td><td></td></tr><tr><td>store</td><td>工作内存</td><td>把工作内存中的一个变量的值传送到主内存中，以便 write 操作</td></tr><tr><td>write</td><td>工作内存</td><td>把 store 操作从工作内存中得到的变量的值放入主内存的变量中</td></tr></tbody></table><h4 id="3-1-2-对于-volatile-型变量的特殊规则"><a href="#3-1-2-对于-volatile-型变量的特殊规则" class="headerlink" title="3.1.2 对于 volatile 型变量的特殊规则"></a>3.1.2 对于 volatile 型变量的特殊规则</h4><blockquote><p>关键字 volatile 是 Java 虚拟机提供的最轻量级的同步机制。</p></blockquote><p>一个变量被定义为 volatile 的特性：</p><ol><li>保证此变量对所有线程的可见性。但是操作并非原子操作，并发情况下不安全。</li></ol><blockquote><p>如果不符合 <code>运算结果并不依赖变量当前值，或者能够确保只有单一的线程修改变量的值</code> 和 <code>变量不需要与其他的状态变量共同参与不变约束</code> 就要通过加锁(使用 synchronize 或 java.util.concurrent 中的原子类)来保证原子性。</p></blockquote><ol><li>禁止指令重排序优化。</li></ol><blockquote><p>通过插入内存屏障保证一致性。</p></blockquote><h4 id="3-1-3-对于-long-和-double-型变量的特殊规则"><a href="#3-1-3-对于-long-和-double-型变量的特殊规则" class="headerlink" title="3.1.3 对于 long 和 double 型变量的特殊规则"></a>3.1.3 对于 long 和 double 型变量的特殊规则</h4><blockquote><p>Java 要求对于主内存和工作内存之间的八个操作都是原子性的，但是对于 64 位的数据类型，有一条宽松的规定：允许虚拟机将没有被 volatile 修饰的 64 位数据的读写操作划分为两次 32 位的操作来进行，即允许虚拟机实现选择可以不保证 64 位数据类型的 load、store、read 和 write 这 4 个操作的原子性。这就是 long 和 double 的非原子性协定。</p></blockquote><h4 id="3-1-4-原子性、可见性与有序性"><a href="#3-1-4-原子性、可见性与有序性" class="headerlink" title="3.1.4 原子性、可见性与有序性"></a>3.1.4 原子性、可见性与有序性</h4><blockquote><p>回顾下并发下应该注意操作的那些特性是什么，同时加深理解。</p></blockquote><ul><li>原子性(Atomicity)</li></ul><blockquote><p>由 Java 内存模型来直接保证的原子性变量操作包括 read、load、assign、use、store 和 write。大致可以认为基本数据类型的操作是原子性的。同时 lock 和 unlock 可以保证更大范围操作的原子性。而 synchronize 同步块操作的原子性是用更高层次的字节码指令 monitorenter 和 monitorexit 来隐式操作的。</p></blockquote><ul><li>可见性(Visibility)</li></ul><blockquote><p>是指当一个线程修改了共享变量的值，其他线程也能够立即得知这个通知。主要操作细节就是修改值后将值同步至主内存(volatile 值使用前都会从主内存刷新)，除了 volatile 还有 synchronize 和 final 可以保证可见性。同步块的可见性是由“对一个变量执行 unlock 操作之前，必须先把此变量同步会主内存中( store、write 操作)”这条规则获得。而 final 可见性是指：被 final 修饰的字段在构造器中一旦完成，并且构造器没有把 “this” 的引用传递出去( this 引用逃逸是一件很危险的事情，其他线程有可能通过这个引用访问到“初始化了一半”的对象)，那在其他线程中就能看见 final 字段的值。</p></blockquote><ul><li>有序性(Ordering)</li></ul><blockquote><p>如果在被线程内观察，所有操作都是有序的；如果在一个线程中观察另一个线程，所有操作都是无序的。前半句指“线程内表现为串行的语义”，后半句是指“指令重排”现象和“工作内存与主内存同步延迟”现象。Java 语言通过 volatile 和 synchronize 两个关键字来保证线程之间操作的有序性。volatile 自身就禁止指令重排，而 synchronize 则是由“一个变量在同一时刻指允许一条线程对其进行 lock 操作”这条规则获得，这条规则决定了持有同一个锁的两个同步块只能串行的进入。</p></blockquote><h4 id="3-1-5-先行发生原则"><a href="#3-1-5-先行发生原则" class="headerlink" title="3.1.5 先行发生原则"></a>3.1.5 先行发生原则</h4><blockquote><p>也就是 happens-before 原则。这个原则是判断数据是否存在竞争、线程是否安全的主要依据。先行发生是 Java 内存模型中定义的两项操作之间的偏序关系。</p></blockquote><p>天然的先行发生关系</p><table><thead><tr><th>规则</th><th>解释</th></tr></thead><tbody><tr><td>程序次序规则</td><td>在一个线程内，代码按照书写的控制流顺序执行</td></tr><tr><td>管程锁定规则</td><td>一个 unlock 操作先行发生于后面对同一个锁的 lock 操作</td></tr><tr><td>volatile 变量规则</td><td>volatile 变量的写操作先行发生于后面对这个变量的读操作</td></tr><tr><td>线程启动规则</td><td>Thread 对象的 start() 方法先行发生于此线程的每一个动作</td></tr><tr><td>线程终止规则</td><td>线程中所有的操作都先行发生于对此线程的终止检测</td></tr><tr><td>(通过 Thread.join() 方法结束、 Thread.isAlive() 的返回值检测)</td><td></td></tr><tr><td>线程中断规则</td><td>对线程 interrupt() 方法调用优先发生于被中断线程的代码检测到中断事件的发生</td></tr><tr><td>(通过 Thread.interrupted() 方法检测)</td><td></td></tr><tr><td>对象终结规则</td><td>一个对象的初始化完成(构造函数执行结束)先行发生于它的 finalize() 方法的开始</td></tr><tr><td>传递性</td><td>如果操作 A 先于 操作 B 发生，操作 B 先于 操作 C 发生，那么操作 A 先于 操作 C</td></tr></tbody></table><h3 id="3-2-Java-与线程"><a href="#3-2-Java-与线程" class="headerlink" title="3.2 Java 与线程"></a>3.2 Java 与线程</h3><p>3.2.1 线程的实现</p><p>使用内核线程实现</p><blockquote><p>直接由操作系统内核支持的线程，这种线程由内核完成切换。程序一般不会直接去使用内核线程，而是去使用内核线程的一种高级接口 —— 轻量级进程(LWP)，轻量级进程就是我们通常意义上所讲的线程，每个轻量级进程都有一个内核级线程支持。</p></blockquote><p><img src="/./../images/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvNGMwYTk1OTQ1ZTdjN2E1MmVmNmNjYmE0YWJiNzNkNDM_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ.webp"></p><p>使用用户线程实现</p><blockquote><p>广义上来说，只要不是内核线程就可以认为是用户线程，因此可以认为轻量级进程也属于用户线程。狭义上说是完全建立在用户空间的线程库上的并且内核系统不可感知的。</p></blockquote><p><img src="/./../images/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvZDE1YjY5NDgyNTIyMTAxMDRkOWNjY2YxODJkYjU4MjU_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ.webp"></p><p>使用用户线程夹加轻量级进程混合实现</p><blockquote><p>直接看图</p></blockquote><p><img src="/./../images/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvZjE2MmMwYmUwMGU0NzI5NTIyZmNlNDhkMjA5ODk5MTM_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ.webp"></p><p><strong>Java 线程实现</strong></p><blockquote><p>平台不同实现方式不同，可以认为是一条 Java 线程映射到一条轻量级进程。</p></blockquote><h4 id="3-2-2-Java-线程调度"><a href="#3-2-2-Java-线程调度" class="headerlink" title="3.2.2 Java 线程调度"></a>3.2.2 Java 线程调度</h4><p>协同式线程调度</p><blockquote><p>线程执行时间由线程自身控制，实现简单，切换线程自己可知，所以基本没有线程同步问题。坏处是执行时间不可控，容易阻塞。</p></blockquote><p>抢占式线程调度</p><blockquote><p>每个线程由系统来分配执行时间。</p></blockquote><h4 id="3-2-3-状态转换"><a href="#3-2-3-状态转换" class="headerlink" title="3.2.3 状态转换"></a>3.2.3 状态转换</h4><p>五种状态：</p><ul><li>新建(new)</li></ul><blockquote><p>创建后尚未启动的线程。</p></blockquote><ul><li>运行(Runable)</li></ul><blockquote><p>Runable 包括了操作系统线程状态中的 Running 和 Ready，也就是出于此状态的线程有可能正在执行，也有可能正在等待 CPU 为他分配时间。</p></blockquote><ul><li>无限期等待(Waiting)</li></ul><blockquote><p>出于这种状态的线程不会被 CPU 分配时间，它们要等其他线程显示的唤醒。</p></blockquote><p>以下方法会然线程进入无限期等待状态：<br>1.没有设置 Timeout 参数的 Object.wait() 方法。<br>2.没有设置 Timeout 参数的 Thread.join() 方法。<br>3.LookSupport.park() 方法。</p><ul><li>限期等待(Timed Waiting)</li></ul><blockquote><p>处于这种状态的线程也不会分配时间，不过无需等待配其他线程显示地唤醒，在一定时间后他们会由系统自动唤醒。</p></blockquote><p>以下方法会让线程进入限期等待状态：<br>1.Thread.sleep() 方法。<br>2.设置了 Timeout 参数的 Object.wait() 方法。<br>3.设置了 Timeout 参数的 Thread.join() 方法。<br>4.LockSupport.parkNanos() 方法。<br>5.LockSupport.parkUntil() 方法。</p><ul><li>阻塞(Blocked)</li></ul><blockquote><p>线程被阻塞了，“阻塞状态”和“等待状态”的区别是：“阻塞状态”在等待着获取一个排他锁，这个时间将在另外一个线程放弃这个锁的时候发生；而“等待状态”则是在等待一段时间，或者唤醒动作的发生。在程序等待进入同步区域的时候，线程将进入这种状态。</p></blockquote><ul><li>结束(Terminated)</li></ul><blockquote><p>已终止线程的线程状态。</p></blockquote><p><img src="/./../images/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvNmFmOGVlNThhNTU0YWYzMmFjOTI0NGQ2NDY5MjFiYzc_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ.webp"></p><h2 id="4-线程安全与锁优化"><a href="#4-线程安全与锁优化" class="headerlink" title="4. 线程安全与锁优化"></a>4. 线程安全与锁优化</h2><blockquote><p>&#x2F;&#x2F; 待填</p></blockquote><h2 id="5-类文件结构"><a href="#5-类文件结构" class="headerlink" title="5. 类文件结构"></a>5. 类文件结构</h2><blockquote><p>&#x2F;&#x2F; 待填</p></blockquote><p>有点懒了。。。先贴几个网址吧。</p><p><a href="https://link.juejin.im/?target=https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html">1. Official：The class File Format</a><br><a href="https://link.juejin.im/?target=http://blog.csdn.net/luanlouis/article/details/39892027">2.亦山: 《Java虚拟机原理图解》 1.1、class文件基本组织结构</a></p><h2 id="6-虚拟机类加载机制"><a href="#6-虚拟机类加载机制" class="headerlink" title="6. 虚拟机类加载机制"></a>6. 虚拟机类加载机制</h2><blockquote><p>虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验、装换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型。</p></blockquote><p>在 Java 语言中，类型的加载、连接和初始化过程都是在程序运行期间完成的。</p><h3 id="6-1-类加载时机"><a href="#6-1-类加载时机" class="headerlink" title="6.1 类加载时机"></a>6.1 类加载时机</h3><p>类的生命周期( 7 个阶段)</p><p><img src="/./../images/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvMjdhYzg3ZjQzOTJmMGFiOTllNGM2NWMyM2NjNzE5NDU_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ.webp"></p><p>其中加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的。解析阶段可以在初始化之后再开始(运行时绑定或动态绑定或晚期绑定)。</p><p>以下五种情况必须对类进行初始化(而加载、验证、准备自然需要在此之前完成)：</p><ol><li>遇到 new、getstatic、putstatic 或 invokestatic 这 4 条字节码指令时没初始化触发初始化。使用场景：使用 new 关键字实例化对象、读取一个类的静态字段(被 final 修饰、已在编译期把结果放入常量池的静态字段除外)、调用一个类的静态方法。</li><li>使用 java.lang.reflect 包的方法对类进行反射调用的时候。</li><li>当初始化一个类的时候，如果发现其父类还没有进行初始化，则需先触发其父类的初始化。</li><li>当虚拟机启动时，用户需指定一个要加载的主类(包含 main() 方法的那个类)，虚拟机会先初始化这个主类。</li><li>当使用 JDK 1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果 REF_getStatic、REF_putStatic、REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需先触发其初始化。</li></ol><p>前面的五种方式是对一个类的主动引用，除此之外，所有引用类的方法都不会触发初始化，佳作被动引用。举几个例子~</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SuperClass</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;SuperClass init!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">1127</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubClass</span> <span class="keyword">extends</span> <span class="title class_">SuperClass</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;SubClass init!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConstClass</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ConstClass init!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">HELLOWORLD</span> <span class="operator">=</span> <span class="string">&quot;hello world!&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NotInitialization</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(SubClass.value);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *  output : SuperClass init!</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         * 通过子类引用父类的静态对象不会导致子类的初始化</span></span><br><span class="line"><span class="comment">         * 只有直接定义这个字段的类才会被初始化</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        SuperClass[] sca = <span class="keyword">new</span> <span class="title class_">SuperClass</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *  output : </span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         * 通过数组定义来引用类不会触发此类的初始化</span></span><br><span class="line"><span class="comment">         * 虚拟机在运行时动态创建了一个数组类</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        System.out.println(ConstClass.HELLOWORLD);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *  output : </span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         * 常量在编译阶段会存入调用类的常量池当中，本质上并没有直接引用到定义类常量的类，</span></span><br><span class="line"><span class="comment">         * 因此不会触发定义常量的类的初始化。</span></span><br><span class="line"><span class="comment">         * “hello world” 在编译期常量传播优化时已经存储到 NotInitialization 常量池中了。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-2-类的加载过程"><a href="#6-2-类的加载过程" class="headerlink" title="6.2 类的加载过程"></a>6.2 类的加载过程</h3><h4 id="6-2-1-加载"><a href="#6-2-1-加载" class="headerlink" title="6.2.1 加载"></a>6.2.1 加载</h4><ol><li>通过一个类的全限定名来获取定义次类的二进制流(ZIP 包、网络、运算生成、JSP 生成、数据库读取)。</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li><li>在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法去这个类的各种数据的访问入口。</li></ol><p>数组类的特殊性：数组类本身不通过类加载器创建，它是由 Java 虚拟机直接创建的。但数组类与类加载器仍然有很密切的关系，因为数组类的元素类型最终是要靠类加载器去创建的，数组创建过程如下：</p><ol><li>如果数组的组件类型是引用类型，那就递归采用类加载加载。</li><li>如果数组的组件类型不是引用类型，Java 虚拟机会把数组标记为引导类加载器关联。</li><li>数组类的可见性与他的组件类型的可见性一致，如果组件类型不是引用类型，那数组类的可见性将默认为 public。</li></ol><p>内存中实例的 java.lang.Class 对象存在方法区中。作为程序访问方法区中这些类型数据的外部接口。<br>加载阶段与连接阶段的部分内容是交叉进行的，但是开始时间保持先后顺序。</p><h4 id="6-2-2-验证"><a href="#6-2-2-验证" class="headerlink" title="6.2.2 验证"></a>6.2.2 验证</h4><blockquote><p>是连接的第一步，确保 Class 文件的字节流中包含的信息符合当前虚拟机要求。</p></blockquote><p>文件格式验证</p><ol><li>是否以魔数 0xCAFEBABE 开头</li><li>主、次版本号是否在当前虚拟机处理范围之内</li><li>常量池的常量是否有不被支持常量的类型（检查常量 tag 标志）</li><li>指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量</li><li>CONSTANT_Utf8_info 型的常量中是否有不符合 UTF8 编码的数据</li><li>Class 文件中各个部分集文件本身是否有被删除的附加的其他信息</li><li>……</li></ol><p>只有通过这个阶段的验证后，字节流才会进入内存的方法区进行存储，所以后面 3 个验证阶段全部是基于方法区的存储结构进行的，不再直接操作字节流。</p><p>元数据验证</p><ol><li>这个类是否有父类（除 java.lang.Object 之外）</li><li>这个类的父类是否继承了不允许被继承的类（final 修饰的类）</li><li>如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法</li><li>类中的字段、方法是否与父类产生矛盾（覆盖父类 final 字段、出现不符合规范的重载）</li></ol><p>这一阶段主要是对类的元数据信息进行语义校验，保证不存在不符合 Java 语言规范的元数据信息。</p><p>字节码验证</p><ol><li>保证任意时刻操作数栈的数据类型与指令代码序列都鞥配合工作（不会出现按照 long 类型读一个 int 型数据）</li><li>保证跳转指令不会跳转到方法体以外的字节码指令上</li><li>保证方法体中的类型转换是有效的（子类对象赋值给父类数据类型是安全的，反过来不合法的）</li><li>……</li></ol><p>这是整个验证过程中最复杂的一个阶段，主要目的是通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。这个阶段对类的方法体进行校验分析，保证校验类的方法在运行时不会做出危害虚拟机安全的事件。</p><p>符号引用验证</p><ol><li>符号引用中通过字符创描述的全限定名是否能找到对应的类</li><li>在指定类中是否存在符方法的字段描述符以及简单名称所描述的方法和字段</li><li>符号引用中的类、字段、方法的访问性（private、protected、public、default）是否可被当前类访问</li><li>……</li></ol><p>最后一个阶段的校验发生在迅疾将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段——解析阶段中发生。符号引用验证可以看做是对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验，还有以上提及的内容。<br>符号引用的目的是确保解析动作能正常执行，如果无法通过符号引用验证将抛出一个 java.lang.IncompatibleClass.ChangeError 异常的子类。如 java.lang.IllegalAccessError、java.lang.NoSuchFieldError、java.lang.NoSuchMethodError 等。</p><h4 id="6-2-3-准备"><a href="#6-2-3-准备" class="headerlink" title="6.2.3 准备"></a>6.2.3 准备</h4><blockquote><p>这个阶段正式为类分配内存并设置类变量初始值，内存在方法去中分配(含 static 修饰的变量不含实例变量)。</p></blockquote><p><code>public static int value = 1127;</code><br>这句代码在初始值设置之后为 0，因为这时候尚未开始执行任何 Java 方法。而把 value 赋值为 1127 的 putstatic 指令是程序被编译后，存放于 clinit() 方法中，所以初始化阶段才会对 value 进行赋值。</p><p>基本数据类型的零值</p><table><thead><tr><th>数据类型</th><th>零值</th><th>数据类型</th><th>零值</th></tr></thead><tbody><tr><td>int</td><td>0</td><td>boolean</td><td>false</td></tr><tr><td>long</td><td>0L</td><td>float</td><td>0.0f</td></tr><tr><td>short</td><td>(short) 0</td><td>double</td><td>0.0d</td></tr><tr><td>char</td><td>‘\u0000’</td><td>reference</td><td>null</td></tr><tr><td>byte</td><td>(byte) 0</td><td></td><td></td></tr></tbody></table><p>特殊情况：如果类字段的字段属性表中存在 ConstantValue 属性，在准备阶段虚拟机就会根据 ConstantValue 的设置将 value 赋值为 1127。</p><h4 id="6-2-4-解析"><a href="#6-2-4-解析" class="headerlink" title="6.2.4 解析"></a>6.2.4 解析</h4><blockquote><p>这个阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。</p></blockquote><ol><li>符号引用<br>符号引用以一组符号来描述所引用的目标，符号可以使任何形式的字面量。</li><li>直接引用<br>直接引用可以使直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用和迅疾的内存布局实现有关</li></ol><p>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符 7 类符号引用进行，分别对应于常量池的 7 中常量类型。</p><h4 id="6-2-5-初始化"><a href="#6-2-5-初始化" class="headerlink" title="6.2.5 初始化"></a>6.2.5 初始化</h4><blockquote><p>前面过程都是以虚拟机主导，而初始化阶段开始执行类中的 Java 代码。</p></blockquote><h3 id="6-3-类加载器"><a href="#6-3-类加载器" class="headerlink" title="6.3 类加载器"></a>6.3 类加载器</h3><blockquote><p>通过一个类的全限定名来获取描述此类的二进制字节流。</p></blockquote><h4 id="6-3-1-双亲委派模型"><a href="#6-3-1-双亲委派模型" class="headerlink" title="6.3.1 双亲委派模型"></a>6.3.1 双亲委派模型</h4><blockquote><p>从 Java 虚拟机角度讲，只存在两种类加载器：一种是启动类加载器（C++ 实现，是虚拟机的一部分）；另一种是其他所有类的加载器（Java 实现，独立于虚拟机外部且全继承自 java.lang.ClassLoader）</p></blockquote><ol><li><p>启动类加载器<br>加载 lib 下或被 -Xbootclasspath 路径下的类</p></li><li><p>扩展类加载器<br>加载 lib&#x2F;ext 或者被 java.ext.dirs 系统变量所指定的路径下的类</p></li><li><p>引用程序类加载器<br>ClassLoader负责，加载用户路径上所指定的类库。</p></li></ol><p><img src="/./../images/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvYzQyNzA0NzNjNDJjNGE1ZDE0ZWI0NzRjOGQ5NTcwZWI_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ-1683615954402-23.webp"></p><p>除顶层启动类加载器之外，其他都有自己的父类加载器。<br>工作过程：如果一个类加载器收到一个类加载的请求，它首先不会自己加载，而是把这个请求委派给父类加载器。只有父类无法完成时子类才会尝试加载。</p><h4 id="6-3-2-破坏双亲委派模型"><a href="#6-3-2-破坏双亲委派模型" class="headerlink" title="6.3.2 破坏双亲委派模型"></a>6.3.2 破坏双亲委派模型</h4><blockquote><p>keyword：线程上下文加载器(Thread Context ClassLoader)</p></blockquote><p>参考地址：<a href="https://blog.csdn.net/qq_41701956/article/details/81664921?ops_request_misc=%7B%22request_id%22:%22168346565016800225523124%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168346565016800225523124&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-81664921-null-null.142%5Ev86%5Einsert_down1,239%5Ev2%5Einsert_chatgpt&utm_term=Java%E8%99%9A%E6%8B%9F%E6%9C%BA&spm=1018.2226.3001.4187">Java虚拟机（JVM）你只要看这一篇就够了！</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-Java-内存区域与内存溢出异常&quot;&gt;&lt;a href=&quot;#1-Java-内存区域与内存溢出异常&quot; class=&quot;headerlink&quot; title=&quot;1. Java 内存区域与内存溢出异常&quot;&gt;&lt;/a&gt;1. Java 内存区域与内存溢出异常&lt;/h2&gt;&lt;h3 id=</summary>
      
    
    
    
    <category term="Java基础" scheme="https://wx51815.github.io/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Java" scheme="https://wx51815.github.io/tags/Java/"/>
    
    <category term="虚拟机" scheme="https://wx51815.github.io/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
</feed>
